<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:doc="http://www.gtk.org/introspection/doc/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="GObject" version="2.0"/>
  <include name="Gio" version="2.0"/>
  <package name="vips"/>
  <c:include name="vips/vips.h"/>
  <doc:format name="unknown"/>
  <namespace name="Vips"
             version="8.0"
             shared-library="libvips.42.dylib"
             c:identifier-prefixes="Vips"
             c:symbol-prefixes="vips">
    <alias name="ArgumentTable" c:type="VipsArgumentTable">
      <source-position filename="libvips/include/vips/object.h" line="309"/>
      <type name="GLib.HashTable" c:type="GHashTable"/>
    </alias>
    <alias name="Pel" c:type="VipsPel">
      <doc xml:space="preserve"
           filename="libvips/include/vips/basic.h"
           line="85">A picture element. Cast this to whatever the associated VipsBandFormat says
to get the value.</doc>
      <source-position filename="libvips/include/vips/basic.h" line="91"/>
      <type name="guint8" c:type="unsigned char"/>
    </alias>
    <function-macro name="ABS" c:identifier="VIPS_ABS" introspectable="0">
      <source-position filename="libvips/include/vips/util.h" line="64"/>
      <parameters>
        <parameter name="V">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ALIGNED"
                    c:identifier="VIPS_ALIGNED"
                    introspectable="0">
      <source-position filename="libvips/include/vips/util.h" line="68"/>
      <parameters>
        <parameter name="P">
        </parameter>
        <parameter name="N">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="AREA" c:identifier="VIPS_AREA" introspectable="0">
      <source-position filename="libvips/include/vips/type.h" line="141"/>
      <parameters>
        <parameter name="X">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ARGUMENT_COLLECT_GET"
                    c:identifier="VIPS_ARGUMENT_COLLECT_GET"
                    introspectable="0">
      <source-position filename="libvips/include/vips/object.h" line="402"/>
      <parameters>
        <parameter name="PSPEC">
        </parameter>
        <parameter name="ARG_CLASS">
        </parameter>
        <parameter name="AP">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ARGUMENT_COLLECT_SET"
                    c:identifier="VIPS_ARGUMENT_COLLECT_SET"
                    introspectable="0">
      <source-position filename="libvips/include/vips/object.h" line="384"/>
      <parameters>
        <parameter name="PSPEC">
        </parameter>
        <parameter name="ARG_CLASS">
        </parameter>
        <parameter name="AP">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ARGUMENT_FOR_ALL"
                    c:identifier="VIPS_ARGUMENT_FOR_ALL"
                    introspectable="0">
      <source-position filename="libvips/include/vips/object.h" line="345"/>
      <parameters>
        <parameter name="OBJECT">
        </parameter>
        <parameter name="PSPEC">
        </parameter>
        <parameter name="ARG_CLASS">
        </parameter>
        <parameter name="ARG_INSTANCE">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="ARGUMENT_OPTIONAL_INPUT"
              value="18"
              c:type="VIPS_ARGUMENT_OPTIONAL_INPUT">
      <source-position filename="libvips/include/vips/object.h" line="95"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ARGUMENT_OPTIONAL_OUTPUT"
              value="34"
              c:type="VIPS_ARGUMENT_OPTIONAL_OUTPUT">
      <source-position filename="libvips/include/vips/object.h" line="99"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ARGUMENT_REQUIRED_INPUT"
              value="19"
              c:type="VIPS_ARGUMENT_REQUIRED_INPUT">
      <source-position filename="libvips/include/vips/object.h" line="93"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ARGUMENT_REQUIRED_OUTPUT"
              value="35"
              c:type="VIPS_ARGUMENT_REQUIRED_OUTPUT">
      <source-position filename="libvips/include/vips/object.h" line="97"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="ARG_BOOL"
                    c:identifier="VIPS_ARG_BOOL"
                    introspectable="0">
      <source-position filename="libvips/include/vips/object.h" line="130"/>
      <parameters>
        <parameter name="CLASS">
        </parameter>
        <parameter name="NAME">
        </parameter>
        <parameter name="PRIORITY">
        </parameter>
        <parameter name="LONG">
        </parameter>
        <parameter name="DESC">
        </parameter>
        <parameter name="FLAGS">
        </parameter>
        <parameter name="OFFSET">
        </parameter>
        <parameter name="VALUE">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ARG_BOXED"
                    c:identifier="VIPS_ARG_BOXED"
                    introspectable="0">
      <source-position filename="libvips/include/vips/object.h" line="156"/>
      <parameters>
        <parameter name="CLASS">
        </parameter>
        <parameter name="NAME">
        </parameter>
        <parameter name="PRIORITY">
        </parameter>
        <parameter name="LONG">
        </parameter>
        <parameter name="DESC">
        </parameter>
        <parameter name="FLAGS">
        </parameter>
        <parameter name="OFFSET">
        </parameter>
        <parameter name="TYPE">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ARG_DOUBLE"
                    c:identifier="VIPS_ARG_DOUBLE"
                    introspectable="0">
      <source-position filename="libvips/include/vips/object.h" line="143"/>
      <parameters>
        <parameter name="CLASS">
        </parameter>
        <parameter name="NAME">
        </parameter>
        <parameter name="PRIORITY">
        </parameter>
        <parameter name="LONG">
        </parameter>
        <parameter name="DESC">
        </parameter>
        <parameter name="FLAGS">
        </parameter>
        <parameter name="OFFSET">
        </parameter>
        <parameter name="MIN">
        </parameter>
        <parameter name="MAX">
        </parameter>
        <parameter name="VALUE">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ARG_ENUM"
                    c:identifier="VIPS_ARG_ENUM"
                    introspectable="0">
      <source-position filename="libvips/include/vips/object.h" line="195"/>
      <parameters>
        <parameter name="CLASS">
        </parameter>
        <parameter name="NAME">
        </parameter>
        <parameter name="PRIORITY">
        </parameter>
        <parameter name="LONG">
        </parameter>
        <parameter name="DESC">
        </parameter>
        <parameter name="FLAGS">
        </parameter>
        <parameter name="OFFSET">
        </parameter>
        <parameter name="TYPE">
        </parameter>
        <parameter name="VALUE">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ARG_FLAGS"
                    c:identifier="VIPS_ARG_FLAGS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/object.h" line="208"/>
      <parameters>
        <parameter name="CLASS">
        </parameter>
        <parameter name="NAME">
        </parameter>
        <parameter name="PRIORITY">
        </parameter>
        <parameter name="LONG">
        </parameter>
        <parameter name="DESC">
        </parameter>
        <parameter name="FLAGS">
        </parameter>
        <parameter name="OFFSET">
        </parameter>
        <parameter name="TYPE">
        </parameter>
        <parameter name="VALUE">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ARG_IMAGE"
                    c:identifier="VIPS_ARG_IMAGE"
                    introspectable="0">
      <source-position filename="libvips/include/vips/object.h" line="101"/>
      <parameters>
        <parameter name="CLASS">
        </parameter>
        <parameter name="NAME">
        </parameter>
        <parameter name="PRIORITY">
        </parameter>
        <parameter name="LONG">
        </parameter>
        <parameter name="DESC">
        </parameter>
        <parameter name="FLAGS">
        </parameter>
        <parameter name="OFFSET">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ARG_INT"
                    c:identifier="VIPS_ARG_INT"
                    introspectable="0">
      <source-position filename="libvips/include/vips/object.h" line="169"/>
      <parameters>
        <parameter name="CLASS">
        </parameter>
        <parameter name="NAME">
        </parameter>
        <parameter name="PRIORITY">
        </parameter>
        <parameter name="LONG">
        </parameter>
        <parameter name="DESC">
        </parameter>
        <parameter name="FLAGS">
        </parameter>
        <parameter name="OFFSET">
        </parameter>
        <parameter name="MIN">
        </parameter>
        <parameter name="MAX">
        </parameter>
        <parameter name="VALUE">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ARG_INTERPOLATE"
                    c:identifier="VIPS_ARG_INTERPOLATE"
                    introspectable="0">
      <source-position filename="libvips/include/vips/object.h" line="127"/>
      <parameters>
        <parameter name="CLASS">
        </parameter>
        <parameter name="NAME">
        </parameter>
        <parameter name="PRIORITY">
        </parameter>
        <parameter name="LONG">
        </parameter>
        <parameter name="DESC">
        </parameter>
        <parameter name="FLAGS">
        </parameter>
        <parameter name="OFFSET">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ARG_OBJECT"
                    c:identifier="VIPS_ARG_OBJECT"
                    introspectable="0">
      <source-position filename="libvips/include/vips/object.h" line="114"/>
      <parameters>
        <parameter name="CLASS">
        </parameter>
        <parameter name="NAME">
        </parameter>
        <parameter name="PRIORITY">
        </parameter>
        <parameter name="LONG">
        </parameter>
        <parameter name="DESC">
        </parameter>
        <parameter name="FLAGS">
        </parameter>
        <parameter name="OFFSET">
        </parameter>
        <parameter name="TYPE">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ARG_POINTER"
                    c:identifier="VIPS_ARG_POINTER"
                    introspectable="0">
      <source-position filename="libvips/include/vips/object.h" line="234"/>
      <parameters>
        <parameter name="CLASS">
        </parameter>
        <parameter name="NAME">
        </parameter>
        <parameter name="PRIORITY">
        </parameter>
        <parameter name="LONG">
        </parameter>
        <parameter name="DESC">
        </parameter>
        <parameter name="FLAGS">
        </parameter>
        <parameter name="OFFSET">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ARG_STRING"
                    c:identifier="VIPS_ARG_STRING"
                    introspectable="0">
      <source-position filename="libvips/include/vips/object.h" line="221"/>
      <parameters>
        <parameter name="CLASS">
        </parameter>
        <parameter name="NAME">
        </parameter>
        <parameter name="PRIORITY">
        </parameter>
        <parameter name="LONG">
        </parameter>
        <parameter name="DESC">
        </parameter>
        <parameter name="FLAGS">
        </parameter>
        <parameter name="OFFSET">
        </parameter>
        <parameter name="VALUE">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ARG_UINT64"
                    c:identifier="VIPS_ARG_UINT64"
                    introspectable="0">
      <source-position filename="libvips/include/vips/object.h" line="182"/>
      <parameters>
        <parameter name="CLASS">
        </parameter>
        <parameter name="NAME">
        </parameter>
        <parameter name="PRIORITY">
        </parameter>
        <parameter name="LONG">
        </parameter>
        <parameter name="DESC">
        </parameter>
        <parameter name="FLAGS">
        </parameter>
        <parameter name="OFFSET">
        </parameter>
        <parameter name="MIN">
        </parameter>
        <parameter name="MAX">
        </parameter>
        <parameter name="VALUE">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ARRAY" c:identifier="VIPS_ARRAY" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/memory.c"
           line="114">Allocate memory for an array of objects of type @T. The memory is not
cleared.

This macro cannot fail. See [func@tracked_malloc] if you are
allocating large amounts of memory.

::: seealso
    [func@malloc].</doc>
      <source-position filename="libvips/include/vips/memory.h" line="71"/>
      <parameters>
        <parameter name="OBJ">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/memory.c"
               line="116">allocate memory local to @OBJ, or `NULL` for no auto-free</doc>
        </parameter>
        <parameter name="N">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/memory.c"
               line="117">number of @T 's to allocate</doc>
        </parameter>
        <parameter name="T">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/memory.c"
               line="118">type of thing to allocate</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ARRAY_ADDR"
                    c:identifier="VIPS_ARRAY_ADDR"
                    introspectable="0">
      <source-position filename="libvips/include/vips/type.h" line="118"/>
      <parameters>
        <parameter name="X">
        </parameter>
        <parameter name="I">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="A_X0" value="109.850300" c:type="VIPS_A_X0">
      <doc xml:space="preserve"
           filename="libvips/colour/colour.c"
           line="82">Areas under curves for illuminant A (2856K), 2 degree observer.</doc>
      <source-position filename="libvips/include/vips/colour.h" line="72"/>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="A_Y0" value="100.000000" c:type="VIPS_A_Y0">
      <source-position filename="libvips/include/vips/colour.h" line="73"/>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="A_Z0" value="35.584900" c:type="VIPS_A_Z0">
      <source-position filename="libvips/include/vips/colour.h" line="74"/>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <enumeration name="Access"
                 glib:type-name="VipsAccess"
                 glib:get-type="vips_access_get_type"
                 c:type="VipsAccess">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/image.c"
           line="148">The type of access an operation has to supply. See [method@Image.tilecache]
and [class@Foreign].

[enum@Vips.Access.RANDOM] means requests can come in any order.

[enum@Vips.Access.SEQUENTIAL] means requests will be top-to-bottom, but with some
amount of buffering behind the read point for small non-local accesses.</doc>
      <member name="random"
              value="0"
              c:identifier="VIPS_ACCESS_RANDOM"
              glib:nick="random"
              glib:name="VIPS_ACCESS_RANDOM">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="150">can read anywhere</doc>
      </member>
      <member name="sequential"
              value="1"
              c:identifier="VIPS_ACCESS_SEQUENTIAL"
              glib:nick="sequential"
              glib:name="VIPS_ACCESS_SEQUENTIAL">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="151">top-to-bottom reading only, but with a small buffer</doc>
      </member>
      <member name="sequential_unbuffered"
              value="2"
              c:identifier="VIPS_ACCESS_SEQUENTIAL_UNBUFFERED"
              glib:nick="sequential-unbuffered"
              glib:name="VIPS_ACCESS_SEQUENTIAL_UNBUFFERED">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="152">deprecated, use [enum@Vips.Access.SEQUENTIAL] instead</doc>
      </member>
    </enumeration>
    <enumeration name="Align"
                 glib:type-name="VipsAlign"
                 glib:get-type="vips_align_get_type"
                 c:type="VipsAlign">
      <doc xml:space="preserve"
           filename="libvips/conversion/conversion.c"
           line="162">See [method@Image.join] and so on.

Operations like [method@Image.join] need to be told whether to align images on the
low or high coordinate edge, or centre.

::: seealso
    [method@Image.join].</doc>
      <member name="low"
              value="0"
              c:identifier="VIPS_ALIGN_LOW"
              glib:nick="low"
              glib:name="VIPS_ALIGN_LOW">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="164">align low coordinate edge</doc>
      </member>
      <member name="centre"
              value="1"
              c:identifier="VIPS_ALIGN_CENTRE"
              glib:nick="centre"
              glib:name="VIPS_ALIGN_CENTRE">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="165">align centre</doc>
      </member>
      <member name="high"
              value="2"
              c:identifier="VIPS_ALIGN_HIGH"
              glib:nick="high"
              glib:name="VIPS_ALIGN_HIGH">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="166">align high coordinate edge</doc>
      </member>
    </enumeration>
    <enumeration name="Angle"
                 glib:type-name="VipsAngle"
                 glib:get-type="vips_angle_get_type"
                 c:type="VipsAngle">
      <doc xml:space="preserve"
           filename="libvips/conversion/conversion.c"
           line="177">See [method@Image.rot] and so on.

Fixed rotate angles.

::: seealso
    [method@Image.rot].</doc>
      <member name="d0"
              value="0"
              c:identifier="VIPS_ANGLE_D0"
              glib:nick="d0"
              glib:name="VIPS_ANGLE_D0">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="179">no rotate</doc>
      </member>
      <member name="d90"
              value="1"
              c:identifier="VIPS_ANGLE_D90"
              glib:nick="d90"
              glib:name="VIPS_ANGLE_D90">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="180">90 degrees clockwise</doc>
      </member>
      <member name="d180"
              value="2"
              c:identifier="VIPS_ANGLE_D180"
              glib:nick="d180"
              glib:name="VIPS_ANGLE_D180">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="181">180 degree rotate</doc>
      </member>
      <member name="d270"
              value="3"
              c:identifier="VIPS_ANGLE_D270"
              glib:nick="d270"
              glib:name="VIPS_ANGLE_D270">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="182">90 degrees anti-clockwise</doc>
      </member>
    </enumeration>
    <enumeration name="Angle45"
                 glib:type-name="VipsAngle45"
                 glib:get-type="vips_angle45_get_type"
                 c:type="VipsAngle45">
      <doc xml:space="preserve"
           filename="libvips/conversion/conversion.c"
           line="229">See [method@Image.rot45] and so on.

Fixed rotate angles.

::: seealso
    [method@Image.rot45].</doc>
      <member name="d0"
              value="0"
              c:identifier="VIPS_ANGLE45_D0"
              glib:nick="d0"
              glib:name="VIPS_ANGLE45_D0">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="231">no rotate</doc>
      </member>
      <member name="d45"
              value="1"
              c:identifier="VIPS_ANGLE45_D45"
              glib:nick="d45"
              glib:name="VIPS_ANGLE45_D45">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="232">45 degrees clockwise</doc>
      </member>
      <member name="d90"
              value="2"
              c:identifier="VIPS_ANGLE45_D90"
              glib:nick="d90"
              glib:name="VIPS_ANGLE45_D90">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="233">90 degrees clockwise</doc>
      </member>
      <member name="d135"
              value="3"
              c:identifier="VIPS_ANGLE45_D135"
              glib:nick="d135"
              glib:name="VIPS_ANGLE45_D135">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="234">135 degrees clockwise</doc>
      </member>
      <member name="d180"
              value="4"
              c:identifier="VIPS_ANGLE45_D180"
              glib:nick="d180"
              glib:name="VIPS_ANGLE45_D180">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="235">180 degrees</doc>
      </member>
      <member name="d225"
              value="5"
              c:identifier="VIPS_ANGLE45_D225"
              glib:nick="d225"
              glib:name="VIPS_ANGLE45_D225">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="236">135 degrees anti-clockwise</doc>
      </member>
      <member name="d270"
              value="6"
              c:identifier="VIPS_ANGLE45_D270"
              glib:nick="d270"
              glib:name="VIPS_ANGLE45_D270">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="237">90 degrees anti-clockwise</doc>
      </member>
      <member name="d315"
              value="7"
              c:identifier="VIPS_ANGLE45_D315"
              glib:nick="d315"
              glib:name="VIPS_ANGLE45_D315">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="238">45 degrees anti-clockwise</doc>
      </member>
    </enumeration>
    <record name="Area"
            c:type="VipsArea"
            glib:type-name="VipsArea"
            glib:get-type="vips_area_get_type"
            c:symbol-prefix="area">
      <source-position filename="libvips/include/vips/type.h" line="98"/>
      <field name="data" writable="1">
        <type name="gpointer" c:type="void*"/>
      </field>
      <field name="length" writable="1">
        <type name="gsize" c:type="size_t"/>
      </field>
      <field name="n" writable="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="count" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="lock" readable="0" private="1">
        <type name="GLib.Mutex" c:type="GMutex"/>
      </field>
      <field name="free_fn" readable="0" private="1">
        <type name="CallbackFn" c:type="VipsCallbackFn"/>
      </field>
      <field name="client" readable="0" private="1">
        <type name="gpointer" c:type="void*"/>
      </field>
      <field name="type" readable="0" private="1">
        <type name="GType" c:type="GType"/>
      </field>
      <field name="sizeof_type" readable="0" private="1">
        <type name="gsize" c:type="size_t"/>
      </field>
      <constructor name="new" c:identifier="vips_area_new">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/type.c"
             line="215">A VipsArea wraps a chunk of memory. It adds reference counting and a free
function. It also keeps a count and a [alias@GObject.Type], so the area can
be an array.

This type is used for things like passing an array of double or an array of
[class@Object] pointers to operations, and for reference-counted immutable
strings.

Initial count == 1, so [method@Area.unref] after attaching somewhere.

::: seealso
    [method@Area.unref].</doc>
        <source-position filename="libvips/include/vips/type.h" line="108"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="233">the new [struct@Area].</doc>
          <type name="Area" c:type="VipsArea*"/>
        </return-value>
        <parameters>
          <parameter name="free_fn"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="217">@data will be freed with this function</doc>
            <type name="CallbackFn" c:type="VipsCallbackFn"/>
          </parameter>
          <parameter name="data"
                     transfer-ownership="full"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="218">data will be freed with this function</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_array" c:identifier="vips_area_new_array">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/type.c"
             line="291">An area which holds an array of elements of some [alias@GObject.Type].
To set values for the elements, get the pointer and write.

::: seealso
    [method@Area.unref].</doc>
        <source-position filename="libvips/include/vips/type.h" line="110"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="303">the new [struct@Area].</doc>
          <type name="Area" c:type="VipsArea*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="293">[alias@GObject.Type] of elements to store</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="sizeof_type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="294">`sizeof()` an element in the array</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="295">number of elements in the array</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_array_object"
                   c:identifier="vips_area_new_array_object">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/type.c"
             line="335">An area which holds an array of [class@GObject.Object] s. See
[ctor@Area.new_array]. When the area is freed, each [class@GObject.Object]
will be unreffed.

Add an extra `NULL` element at the end, handy for eg.
[func@Image.pipeline_array] etc.

::: seealso
    [method@Area.unref].</doc>
        <source-position filename="libvips/include/vips/type.h" line="112"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="349">the new [struct@Area].</doc>
          <type name="Area" c:type="VipsArea*"/>
        </return-value>
        <parameters>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="337">number of elements in the array</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy" c:identifier="vips_area_copy">
        <source-position filename="libvips/include/vips/type.h" line="101"/>
        <return-value transfer-ownership="full">
          <type name="Area" c:type="VipsArea*"/>
        </return-value>
        <parameters>
          <instance-parameter name="area" transfer-ownership="none">
            <type name="Area" c:type="VipsArea*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_data" c:identifier="vips_area_get_data">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/type.c"
             line="368">Return the data pointer plus optionally the length in bytes of an area,
the number of elements, the [alias@GObject.Type] of each element and the
`sizeof()` each element.</doc>
        <source-position filename="libvips/include/vips/type.h" line="114"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="380">The pointer held by @area.</doc>
          <type name="gpointer" c:type="void*"/>
        </return-value>
        <parameters>
          <instance-parameter name="area" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="370">[struct@Area] to fetch from</doc>
            <type name="Area" c:type="VipsArea*"/>
          </instance-parameter>
          <parameter name="length"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="371">optionally return length in bytes here</doc>
            <type name="gsize" c:type="size_t*"/>
          </parameter>
          <parameter name="n"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="372">optionally return number of elements here</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
          <parameter name="type"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="373">optionally return element type here</doc>
            <type name="GType" c:type="GType*"/>
          </parameter>
          <parameter name="sizeof_type"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="374">optionally return `sizeof()` element type here</doc>
            <type name="gsize" c:type="size_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="vips_area_unref">
        <source-position filename="libvips/include/vips/type.h" line="105"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="area" transfer-ownership="none">
            <type name="Area" c:type="VipsArea*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="free_cb" c:identifier="vips_area_free_cb">
        <source-position filename="libvips/include/vips/type.h" line="103"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter name="mem"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="area" transfer-ownership="none">
            <type name="Area" c:type="VipsArea*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="Argument" c:type="VipsArgument">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/object.c"
           line="154">libvips has a simple mechanism for automating at least some aspects of
[class@GObject.Object] properties. You add a set of macros to your
`_class_init()` which describe the arguments, and set the get and set
functions to the libvips ones.

See [extending](extending.html) for a complete example.</doc>
      <source-position filename="libvips/include/vips/object.h" line="262"/>
      <field name="pspec" writable="1">
        <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
      </field>
      <function name="get_id"
                c:identifier="vips_argument_get_id"
                introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="230">Allocate a new property id. See
[method@GObject.ObjectClass.install_property].</doc>
        <source-position filename="libvips/include/vips/object.h" line="312"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/object.c"
               line="236">a new property id &gt; 0</doc>
          <type name="gint" c:type="int"/>
        </return-value>
      </function>
      <function name="map" c:identifier="vips_argument_map">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="576">Loop over the [struct@Argument] of an object. Stop when @fn returns non-`NULL`
and return that value.</doc>
        <source-position filename="libvips/include/vips/object.h" line="325"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/object.c"
               line="586">`NULL` if @fn returns `NULL` for all arguments, otherwise the first
non-`NULL` value from @fn.</doc>
          <type name="gpointer" c:type="void*"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="578">object whose args should be enumerated</doc>
            <type name="Object" c:type="VipsObject*"/>
          </parameter>
          <parameter name="fn"
                     transfer-ownership="none"
                     scope="call"
                     closure="2">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="579">call this function for every argument</doc>
            <type name="ArgumentMapFn" c:type="VipsArgumentMapFn"/>
          </parameter>
          <parameter name="a"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="580">client data</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="b"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="581">client data</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="ArgumentClass" c:type="VipsArgumentClass">
      <source-position filename="libvips/include/vips/object.h" line="276"/>
      <field name="parent" writable="1">
        <type name="Argument" c:type="VipsArgument"/>
      </field>
      <field name="object_class" writable="1">
        <type name="ObjectClass" c:type="VipsObjectClass*"/>
      </field>
      <field name="flags" writable="1">
        <type name="ArgumentFlags" c:type="VipsArgumentFlags"/>
      </field>
      <field name="priority" writable="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="offset" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <method name="needsstring"
              c:identifier="vips_argument_class_needsstring">
        <source-position filename="libvips/include/vips/object.h" line="337"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="argument_class" transfer-ownership="none">
            <type name="ArgumentClass" c:type="VipsArgumentClass*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="map"
                c:identifier="vips_argument_class_map"
                introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="620">And loop over a class. Same as ^^, but with no VipsArgumentInstance.</doc>
        <source-position filename="libvips/include/vips/object.h" line="334"/>
        <return-value transfer-ownership="none" nullable="1">
          <type name="gpointer" c:type="void*"/>
        </return-value>
        <parameters>
          <parameter name="object_class" transfer-ownership="none">
            <type name="ObjectClass" c:type="VipsObjectClass*"/>
          </parameter>
          <parameter name="fn" transfer-ownership="none">
            <type name="ArgumentClassMapFn" c:type="VipsArgumentClassMapFn"/>
          </parameter>
          <parameter name="a"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="b"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <callback name="ArgumentClassMapFn" c:type="VipsArgumentClassMapFn">
      <source-position filename="libvips/include/vips/object.h" line="330"/>
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="object_class" transfer-ownership="none">
          <type name="ObjectClass" c:type="VipsObjectClass*"/>
        </parameter>
        <parameter name="pspec" transfer-ownership="none">
          <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
        </parameter>
        <parameter name="argument_class" transfer-ownership="none">
          <type name="ArgumentClass" c:type="VipsArgumentClass*"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <bitfield name="ArgumentFlags"
              glib:type-name="VipsArgumentFlags"
              glib:get-type="vips_argument_flags_get_type"
              c:type="VipsArgumentFlags">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/object.c"
           line="165">Flags we associate with each object argument.

Have separate input &amp; output flags. Both set is an error; neither set is OK.

Input gobjects are automatically reffed, output gobjects automatically ref
us. We also automatically watch for "destroy" and unlink.

[flags@Vips.ArgumentFlags.SET_ALWAYS] is handy for arguments which are set
from C. For example, [property@Image:width] is a property that gives
access to the Xsize member of struct _VipsImage. We default its
'assigned' to `TRUE` since the field is always set directly by C.

[flags@Vips.ArgumentFlags.DEPRECATED] arguments are not shown in help text,
are not looked for if required, are not checked for "have-been-set". You can
deprecate a required argument, but you must obviously add a new required
argument if you do.

Input args with [flags@Vips.ArgumentFlags.MODIFY] will be modified by the
operation. This is used for things like the in-place drawing operations.

[flags@Vips.ArgumentFlags.NON_HASHABLE] stops the argument being used in
hash and equality tests. It's useful for arguments like `revalidate` which
control the behaviour of the operator cache.</doc>
      <member name="none"
              value="0"
              c:identifier="VIPS_ARGUMENT_NONE"
              glib:nick="none"
              glib:name="VIPS_ARGUMENT_NONE">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="167">no flags</doc>
      </member>
      <member name="required"
              value="1"
              c:identifier="VIPS_ARGUMENT_REQUIRED"
              glib:nick="required"
              glib:name="VIPS_ARGUMENT_REQUIRED">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="168">must be set in the constructor</doc>
      </member>
      <member name="construct"
              value="2"
              c:identifier="VIPS_ARGUMENT_CONSTRUCT"
              glib:nick="construct"
              glib:name="VIPS_ARGUMENT_CONSTRUCT">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="169">can only be set in the constructor</doc>
      </member>
      <member name="set_once"
              value="4"
              c:identifier="VIPS_ARGUMENT_SET_ONCE"
              glib:nick="set-once"
              glib:name="VIPS_ARGUMENT_SET_ONCE">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="170">can only be set once</doc>
      </member>
      <member name="set_always"
              value="8"
              c:identifier="VIPS_ARGUMENT_SET_ALWAYS"
              glib:nick="set-always"
              glib:name="VIPS_ARGUMENT_SET_ALWAYS">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="171">don't do use-before-set checks</doc>
      </member>
      <member name="input"
              value="16"
              c:identifier="VIPS_ARGUMENT_INPUT"
              glib:nick="input"
              glib:name="VIPS_ARGUMENT_INPUT">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="172">is an input argument (one we depend on)</doc>
      </member>
      <member name="output"
              value="32"
              c:identifier="VIPS_ARGUMENT_OUTPUT"
              glib:nick="output"
              glib:name="VIPS_ARGUMENT_OUTPUT">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="173">is an output argument (depends on us)</doc>
      </member>
      <member name="deprecated"
              value="64"
              c:identifier="VIPS_ARGUMENT_DEPRECATED"
              glib:nick="deprecated"
              glib:name="VIPS_ARGUMENT_DEPRECATED">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="174">just there for back-compat, hide</doc>
      </member>
      <member name="modify"
              value="128"
              c:identifier="VIPS_ARGUMENT_MODIFY"
              glib:nick="modify"
              glib:name="VIPS_ARGUMENT_MODIFY">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="175">the input argument will be modified</doc>
      </member>
      <member name="non_hashable"
              value="256"
              c:identifier="VIPS_ARGUMENT_NON_HASHABLE"
              glib:nick="non-hashable"
              glib:name="VIPS_ARGUMENT_NON_HASHABLE">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="176">the argument is non-hashable</doc>
      </member>
    </bitfield>
    <record name="ArgumentInstance" c:type="VipsArgumentInstance">
      <source-position filename="libvips/include/vips/object.h" line="304"/>
      <field name="parent" writable="1">
        <type name="Argument" c:type="VipsArgument"/>
      </field>
      <field name="argument_class" writable="1">
        <type name="ArgumentClass" c:type="VipsArgumentClass*"/>
      </field>
      <field name="object" writable="1">
        <type name="Object" c:type="VipsObject*"/>
      </field>
      <field name="assigned" writable="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="close_id" writable="1">
        <type name="gulong" c:type="gulong"/>
      </field>
      <field name="invalidate_id" writable="1">
        <type name="gulong" c:type="gulong"/>
      </field>
    </record>
    <callback name="ArgumentMapFn" c:type="VipsArgumentMapFn">
      <source-position filename="libvips/include/vips/object.h" line="321"/>
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <type name="Object" c:type="VipsObject*"/>
        </parameter>
        <parameter name="pspec" transfer-ownership="none">
          <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
        </parameter>
        <parameter name="argument_class" transfer-ownership="none">
          <type name="ArgumentClass" c:type="VipsArgumentClass*"/>
        </parameter>
        <parameter name="argument_instance" transfer-ownership="none">
          <type name="ArgumentInstance" c:type="VipsArgumentInstance*"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="ArrayDouble"
            c:type="VipsArrayDouble"
            glib:type-name="VipsArrayDouble"
            glib:get-type="vips_array_double_get_type"
            c:symbol-prefix="array_double">
      <source-position filename="libvips/include/vips/type.h" line="209"/>
      <field name="area" writable="1">
        <type name="Area" c:type="VipsArea"/>
      </field>
      <constructor name="new" c:identifier="vips_array_double_new">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/type.c"
             line="1046">Allocate a new array of doubles and copy @array into it. Free with
[method@Area.unref].

::: seealso
    [struct@Area].</doc>
        <source-position filename="libvips/include/vips/type.h" line="212"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1057">A new [struct@ArrayDouble].</doc>
          <type name="ArrayDouble" c:type="VipsArrayDouble*"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="1048">array of double</doc>
            <array length="1" zero-terminated="0" c:type="const double*">
              <type name="gdouble" c:type="double"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="1049">number of doubles</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="newv"
                   c:identifier="vips_array_double_newv"
                   introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/type.c"
             line="1072">Allocate a new array of @n doubles and copy @... into it. Free with
[method@Area.unref].

::: seealso
    [ctor@ArrayDouble.new]</doc>
        <source-position filename="libvips/include/vips/type.h" line="214"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1083">A new [struct@ArrayDouble].</doc>
          <type name="ArrayDouble" c:type="VipsArrayDouble*"/>
        </return-value>
        <parameters>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="1074">number of doubles</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="1075">list of double arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get" c:identifier="vips_array_double_get">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/type.c"
             line="1104">Fetch a double array from a [struct@ArrayDouble]. Useful for language bindings.</doc>
        <source-position filename="libvips/include/vips/type.h" line="216"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1111">array of double</doc>
          <array length="0" zero-terminated="0" c:type="double*">
            <type name="gdouble" c:type="double"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="1106">the [struct@ArrayDouble] to fetch from</doc>
            <type name="ArrayDouble" c:type="VipsArrayDouble*"/>
          </instance-parameter>
          <parameter name="n"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="1107">length of array</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <record name="ArrayImage"
            c:type="VipsArrayImage"
            glib:type-name="VipsArrayImage"
            glib:get-type="vips_array_image_get_type"
            c:symbol-prefix="array_image">
      <source-position filename="libvips/include/vips/type.h" line="249"/>
      <field name="area" writable="1">
        <type name="Area" c:type="VipsArea"/>
      </field>
      <constructor name="empty" c:identifier="vips_array_image_empty">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/type.c"
             line="1428">Make an empty image array.
Handy with [method@ArrayImage.append] for bindings
which can't handle object array arguments.

::: seealso
    [method@ArrayImage.append].</doc>
        <source-position filename="libvips/include/vips/image.h" line="592"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1438">A new [struct@ArrayImage].</doc>
          <type name="ArrayImage" c:type="VipsArrayImage*"/>
        </return-value>
      </constructor>
      <constructor name="new" c:identifier="vips_array_image_new">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/type.c"
             line="1301">Allocate a new array of images and copy @array into it. Free with
[method@Area.unref].

The images will all be reffed by this function. They
will be automatically unreffed for you by
[method@Area.unref].

Add an extra `NULL` element at the end, handy for eg.
[func@Image.pipeline_array] etc.

::: seealso
    [struct@Area].</doc>
        <source-position filename="libvips/include/vips/image.h" line="585"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1319">A new [struct@ArrayImage].</doc>
          <type name="ArrayImage" c:type="VipsArrayImage*"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="1303">array of [class@Image]</doc>
            <array length="1" zero-terminated="0" c:type="VipsImage**">
              <type name="Image" c:type="VipsImage*"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="1304">number of images</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_string"
                   c:identifier="vips_array_image_new_from_string">
        <source-position filename="libvips/include/vips/image.h" line="589"/>
        <return-value transfer-ownership="full">
          <type name="ArrayImage" c:type="VipsArrayImage*"/>
        </return-value>
        <parameters>
          <parameter name="string" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <type name="Access" c:type="VipsAccess"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="newv"
                   c:identifier="vips_array_image_newv"
                   introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/type.c"
             line="1340">Allocate a new array of @n [class@Image] and copy @... into it. Free with
[method@Area.unref].

The images will all be reffed by this function. They
will be automatically unreffed for you by
[method@Area.unref].

Add an extra `NULL` element at the end, handy for eg.
[func@Image.pipeline_array] etc.

::: seealso
    [ctor@ArrayImage.new]</doc>
        <source-position filename="libvips/include/vips/image.h" line="587"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1358">A new [struct@ArrayImage].</doc>
          <type name="ArrayImage" c:type="VipsArrayImage*"/>
        </return-value>
        <parameters>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="1342">number of images</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="1343">list of [class@Image] arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </constructor>
      <method name="append" c:identifier="vips_array_image_append">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/type.c"
             line="1446">Make a new [struct@ArrayImage], one larger than @array, with @image appended
to the end.
Handy with [ctor@ArrayImage.empty] for bindings
which can't handle object array arguments.

::: seealso
    [ctor@ArrayImage.empty].</doc>
        <source-position filename="libvips/include/vips/image.h" line="594"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1459">A new [struct@ArrayImage].</doc>
          <type name="ArrayImage" c:type="VipsArrayImage*"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="1448">append to this</doc>
            <type name="ArrayImage" c:type="VipsArrayImage*"/>
          </instance-parameter>
          <parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="1449">add this</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get" c:identifier="vips_array_image_get">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/type.c"
             line="1487">Fetch an image array from a [struct@ArrayImage]. Useful for language bindings.</doc>
        <source-position filename="libvips/include/vips/image.h" line="597"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1494">array of [class@Image]</doc>
          <array length="0" zero-terminated="0" c:type="VipsImage**">
            <type name="Image" c:type="VipsImage*"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="1489">the [struct@ArrayImage] to fetch from</doc>
            <type name="ArrayImage" c:type="VipsArrayImage*"/>
          </instance-parameter>
          <parameter name="n"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="1490">length of array</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <record name="ArrayInt"
            c:type="VipsArrayInt"
            glib:type-name="VipsArrayInt"
            glib:get-type="vips_array_int_get_type"
            c:symbol-prefix="array_int">
      <source-position filename="libvips/include/vips/type.h" line="229"/>
      <field name="area" writable="1">
        <type name="Area" c:type="VipsArea"/>
      </field>
      <constructor name="new" c:identifier="vips_array_int_new">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/type.c"
             line="799">Allocate a new array of ints and copy @array into it. Free with
[method@Area.unref].

::: seealso
    [struct@Area].</doc>
        <source-position filename="libvips/include/vips/type.h" line="232"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="810">A new [struct@ArrayInt].</doc>
          <type name="ArrayInt" c:type="VipsArrayInt*"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="801">array of int</doc>
            <array length="1" zero-terminated="0" c:type="const int*">
              <type name="gint" c:type="int"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="802">number of ints</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="newv"
                   c:identifier="vips_array_int_newv"
                   introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/type.c"
             line="825">Allocate a new array of @n ints and copy @... into it. Free with
[method@Area.unref].

::: seealso
    [ctor@ArrayInt.new]</doc>
        <source-position filename="libvips/include/vips/type.h" line="234"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="836">A new [struct@ArrayInt].</doc>
          <type name="ArrayInt" c:type="VipsArrayInt*"/>
        </return-value>
        <parameters>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="827">number of ints</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="828">list of int arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get" c:identifier="vips_array_int_get">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/type.c"
             line="857">Fetch an int array from a [struct@ArrayInt]. Useful for language bindings.</doc>
        <source-position filename="libvips/include/vips/type.h" line="236"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="864">array of int</doc>
          <array length="0" zero-terminated="0" c:type="int*">
            <type name="gint" c:type="int"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="859">the [struct@ArrayInt] to fetch from</doc>
            <type name="ArrayInt" c:type="VipsArrayInt*"/>
          </instance-parameter>
          <parameter name="n"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="860">length of array</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <function-macro name="BUF_STATIC"
                    c:identifier="VIPS_BUF_STATIC"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/buf.c"
           line="72">Initialize a heap buffer. For example:

```c
char txt[256];
VipsBuf buf = VIPS_BUF_STATIC(txt);
```</doc>
      <source-position filename="libvips/include/vips/buf.h" line="54"/>
      <parameters>
        <parameter name="TEXT">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/buf.c"
               line="74">the storage area to use</doc>
        </parameter>
      </parameters>
    </function-macro>
    <constant name="B_X0" value="99.072000" c:type="VIPS_B_X0">
      <doc xml:space="preserve"
           filename="libvips/colour/colour.c"
           line="88">Areas under curves for illuminant B (4874K), 2 degree observer.</doc>
      <source-position filename="libvips/include/vips/colour.h" line="78"/>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="B_Y0" value="100.000000" c:type="VIPS_B_Y0">
      <source-position filename="libvips/include/vips/colour.h" line="79"/>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="B_Z0" value="85.223000" c:type="VIPS_B_Z0">
      <source-position filename="libvips/include/vips/colour.h" line="80"/>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <enumeration name="BandFormat"
                 glib:type-name="VipsBandFormat"
                 glib:get-type="vips_band_format_get_type"
                 c:type="VipsBandFormat">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/image.c"
           line="236">The format used for each band element.

Each corresponds to a native C type for the current machine. For example,
[enum@Vips.BandFormat.USHORT] is `unsigned short`.</doc>
      <member name="notset"
              value="-1"
              c:identifier="VIPS_FORMAT_NOTSET"
              glib:nick="notset"
              glib:name="VIPS_FORMAT_NOTSET">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="238">invalid setting</doc>
      </member>
      <member name="uchar"
              value="0"
              c:identifier="VIPS_FORMAT_UCHAR"
              glib:nick="uchar"
              glib:name="VIPS_FORMAT_UCHAR">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="239">unsigned char format</doc>
      </member>
      <member name="char"
              value="1"
              c:identifier="VIPS_FORMAT_CHAR"
              glib:nick="char"
              glib:name="VIPS_FORMAT_CHAR">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="240">char format</doc>
      </member>
      <member name="ushort"
              value="2"
              c:identifier="VIPS_FORMAT_USHORT"
              glib:nick="ushort"
              glib:name="VIPS_FORMAT_USHORT">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="241">unsigned short format</doc>
      </member>
      <member name="short"
              value="3"
              c:identifier="VIPS_FORMAT_SHORT"
              glib:nick="short"
              glib:name="VIPS_FORMAT_SHORT">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="242">short format</doc>
      </member>
      <member name="uint"
              value="4"
              c:identifier="VIPS_FORMAT_UINT"
              glib:nick="uint"
              glib:name="VIPS_FORMAT_UINT">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="243">unsigned int format</doc>
      </member>
      <member name="int"
              value="5"
              c:identifier="VIPS_FORMAT_INT"
              glib:nick="int"
              glib:name="VIPS_FORMAT_INT">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="244">int format</doc>
      </member>
      <member name="float"
              value="6"
              c:identifier="VIPS_FORMAT_FLOAT"
              glib:nick="float"
              glib:name="VIPS_FORMAT_FLOAT">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="245">float format</doc>
      </member>
      <member name="complex"
              value="7"
              c:identifier="VIPS_FORMAT_COMPLEX"
              glib:nick="complex"
              glib:name="VIPS_FORMAT_COMPLEX">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="246">complex (two floats) format</doc>
      </member>
      <member name="double"
              value="8"
              c:identifier="VIPS_FORMAT_DOUBLE"
              glib:nick="double"
              glib:name="VIPS_FORMAT_DOUBLE">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="247">double float format</doc>
      </member>
      <member name="dpcomplex"
              value="9"
              c:identifier="VIPS_FORMAT_DPCOMPLEX"
              glib:nick="dpcomplex"
              glib:name="VIPS_FORMAT_DPCOMPLEX">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="248">double complex (two double) format</doc>
      </member>
      <function name="is8bit" c:identifier="vips_band_format_is8bit">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="3776">Return `TRUE` if @format is uchar or schar.</doc>
        <source-position filename="libvips/include/vips/image.h" line="572"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="3778">format to test</doc>
            <type name="BandFormat" c:type="VipsBandFormat"/>
          </parameter>
        </parameters>
      </function>
      <function name="iscomplex" c:identifier="vips_band_format_iscomplex">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="3836">Return `TRUE` if @fmt is one of the complex types.</doc>
        <source-position filename="libvips/include/vips/image.h" line="576"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="3838">format to test</doc>
            <type name="BandFormat" c:type="VipsBandFormat"/>
          </parameter>
        </parameters>
      </function>
      <function name="isfloat" c:identifier="vips_band_format_isfloat">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="3806">Return `TRUE` if @format is one of the float types.</doc>
        <source-position filename="libvips/include/vips/image.h" line="574"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="3808">format to test</doc>
            <type name="BandFormat" c:type="VipsBandFormat"/>
          </parameter>
        </parameters>
      </function>
      <function name="isint" c:identifier="vips_band_format_isint">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="3716">Return `TRUE` if @format is one of the integer types.</doc>
        <source-position filename="libvips/include/vips/image.h" line="568"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="3718">format to test</doc>
            <type name="BandFormat" c:type="VipsBandFormat"/>
          </parameter>
        </parameters>
      </function>
      <function name="isuint" c:identifier="vips_band_format_isuint">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="3746">Return `TRUE` if @format is one of the unsigned integer types.</doc>
        <source-position filename="libvips/include/vips/image.h" line="570"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="3748">format to test</doc>
            <type name="BandFormat" c:type="VipsBandFormat"/>
          </parameter>
        </parameters>
      </function>
    </enumeration>
    <enumeration name="BlendMode"
                 glib:type-name="VipsBlendMode"
                 glib:get-type="vips_blend_mode_get_type"
                 c:type="VipsBlendMode">
      <doc xml:space="preserve"
           filename="libvips/conversion/conversion.c"
           line="125">The various Porter-Duff and PDF blend modes. See [func@Image.composite],
for example.

The Cairo docs have [a nice explanation of all the blend
modes](https://www.cairographics.org/operators).

The non-separable modes are not implemented.</doc>
      <member name="clear"
              value="0"
              c:identifier="VIPS_BLEND_MODE_CLEAR"
              glib:nick="clear"
              glib:name="VIPS_BLEND_MODE_CLEAR">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="127">where the second object is drawn, the first is removed</doc>
      </member>
      <member name="source"
              value="1"
              c:identifier="VIPS_BLEND_MODE_SOURCE"
              glib:nick="source"
              glib:name="VIPS_BLEND_MODE_SOURCE">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="128">the second object is drawn as if nothing were below</doc>
      </member>
      <member name="over"
              value="2"
              c:identifier="VIPS_BLEND_MODE_OVER"
              glib:nick="over"
              glib:name="VIPS_BLEND_MODE_OVER">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="129">the image shows what you would expect if you held two semi-transparent slides on top of each other</doc>
      </member>
      <member name="in"
              value="3"
              c:identifier="VIPS_BLEND_MODE_IN"
              glib:nick="in"
              glib:name="VIPS_BLEND_MODE_IN">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="130">the first object is removed completely, the second is only drawn where the first was</doc>
      </member>
      <member name="out"
              value="4"
              c:identifier="VIPS_BLEND_MODE_OUT"
              glib:nick="out"
              glib:name="VIPS_BLEND_MODE_OUT">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="131">the second is drawn only where the first isn't</doc>
      </member>
      <member name="atop"
              value="5"
              c:identifier="VIPS_BLEND_MODE_ATOP"
              glib:nick="atop"
              glib:name="VIPS_BLEND_MODE_ATOP">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="132">this leaves the first object mostly intact, but mixes both objects in the overlapping area</doc>
      </member>
      <member name="dest"
              value="6"
              c:identifier="VIPS_BLEND_MODE_DEST"
              glib:nick="dest"
              glib:name="VIPS_BLEND_MODE_DEST">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="133">leaves the first object untouched, the second is discarded completely</doc>
      </member>
      <member name="dest_over"
              value="7"
              c:identifier="VIPS_BLEND_MODE_DEST_OVER"
              glib:nick="dest-over"
              glib:name="VIPS_BLEND_MODE_DEST_OVER">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="134">like OVER, but swaps the arguments</doc>
      </member>
      <member name="dest_in"
              value="8"
              c:identifier="VIPS_BLEND_MODE_DEST_IN"
              glib:nick="dest-in"
              glib:name="VIPS_BLEND_MODE_DEST_IN">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="135">like IN, but swaps the arguments</doc>
      </member>
      <member name="dest_out"
              value="9"
              c:identifier="VIPS_BLEND_MODE_DEST_OUT"
              glib:nick="dest-out"
              glib:name="VIPS_BLEND_MODE_DEST_OUT">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="136">like OUT, but swaps the arguments</doc>
      </member>
      <member name="dest_atop"
              value="10"
              c:identifier="VIPS_BLEND_MODE_DEST_ATOP"
              glib:nick="dest-atop"
              glib:name="VIPS_BLEND_MODE_DEST_ATOP">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="137">like ATOP, but swaps the arguments</doc>
      </member>
      <member name="xor"
              value="11"
              c:identifier="VIPS_BLEND_MODE_XOR"
              glib:nick="xor"
              glib:name="VIPS_BLEND_MODE_XOR">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="138">something like a difference operator</doc>
      </member>
      <member name="add"
              value="12"
              c:identifier="VIPS_BLEND_MODE_ADD"
              glib:nick="add"
              glib:name="VIPS_BLEND_MODE_ADD">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="139">a bit like adding the two images</doc>
      </member>
      <member name="saturate"
              value="13"
              c:identifier="VIPS_BLEND_MODE_SATURATE"
              glib:nick="saturate"
              glib:name="VIPS_BLEND_MODE_SATURATE">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="140">a bit like the darker of the two</doc>
      </member>
      <member name="multiply"
              value="14"
              c:identifier="VIPS_BLEND_MODE_MULTIPLY"
              glib:nick="multiply"
              glib:name="VIPS_BLEND_MODE_MULTIPLY">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="141">at least as dark as the darker of the two inputs</doc>
      </member>
      <member name="screen"
              value="15"
              c:identifier="VIPS_BLEND_MODE_SCREEN"
              glib:nick="screen"
              glib:name="VIPS_BLEND_MODE_SCREEN">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="142">at least as light as the lighter of the inputs</doc>
      </member>
      <member name="overlay"
              value="16"
              c:identifier="VIPS_BLEND_MODE_OVERLAY"
              glib:nick="overlay"
              glib:name="VIPS_BLEND_MODE_OVERLAY">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="143">multiplies or screens colors, depending on the lightness</doc>
      </member>
      <member name="darken"
              value="17"
              c:identifier="VIPS_BLEND_MODE_DARKEN"
              glib:nick="darken"
              glib:name="VIPS_BLEND_MODE_DARKEN">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="144">the darker of each component</doc>
      </member>
      <member name="lighten"
              value="18"
              c:identifier="VIPS_BLEND_MODE_LIGHTEN"
              glib:nick="lighten"
              glib:name="VIPS_BLEND_MODE_LIGHTEN">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="145">the lighter of each component</doc>
      </member>
      <member name="colour_dodge"
              value="19"
              c:identifier="VIPS_BLEND_MODE_COLOUR_DODGE"
              glib:nick="colour-dodge"
              glib:name="VIPS_BLEND_MODE_COLOUR_DODGE">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="146">brighten first by a factor second</doc>
      </member>
      <member name="colour_burn"
              value="20"
              c:identifier="VIPS_BLEND_MODE_COLOUR_BURN"
              glib:nick="colour-burn"
              glib:name="VIPS_BLEND_MODE_COLOUR_BURN">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="147">darken first by a factor of second</doc>
      </member>
      <member name="hard_light"
              value="21"
              c:identifier="VIPS_BLEND_MODE_HARD_LIGHT"
              glib:nick="hard-light"
              glib:name="VIPS_BLEND_MODE_HARD_LIGHT">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="148">multiply or screen, depending on lightness</doc>
      </member>
      <member name="soft_light"
              value="22"
              c:identifier="VIPS_BLEND_MODE_SOFT_LIGHT"
              glib:nick="soft-light"
              glib:name="VIPS_BLEND_MODE_SOFT_LIGHT">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="149">darken or lighten, depending on lightness</doc>
      </member>
      <member name="difference"
              value="23"
              c:identifier="VIPS_BLEND_MODE_DIFFERENCE"
              glib:nick="difference"
              glib:name="VIPS_BLEND_MODE_DIFFERENCE">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="150">difference of the two</doc>
      </member>
      <member name="exclusion"
              value="24"
              c:identifier="VIPS_BLEND_MODE_EXCLUSION"
              glib:nick="exclusion"
              glib:name="VIPS_BLEND_MODE_EXCLUSION">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="151">somewhat like DIFFERENCE, but lower-contrast</doc>
      </member>
    </enumeration>
    <record name="Blob"
            c:type="VipsBlob"
            glib:type-name="VipsBlob"
            glib:get-type="vips_blob_get_type"
            c:symbol-prefix="blob">
      <source-position filename="libvips/include/vips/type.h" line="185"/>
      <field name="area" writable="1">
        <type name="Area" c:type="VipsArea"/>
      </field>
      <constructor name="new" c:identifier="vips_blob_new">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/type.c"
             line="619">Like [ctor@Area.new], but track a length as well. The returned [struct@Blob]
takes ownership of @data and will free it with @free_fn. Pass `NULL` for
@free_fn to not transfer ownership.

An area of mem with a free func and a length (some sort of binary object,
like an ICC profile).

::: seealso
    [method@Area.unref].</doc>
        <source-position filename="libvips/include/vips/type.h" line="188"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="635">the new [struct@Blob].</doc>
          <type name="Blob" c:type="VipsBlob*"/>
        </return-value>
        <parameters>
          <parameter name="free_fn"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="621">@data will be freed with this function</doc>
            <type name="CallbackFn" c:type="VipsCallbackFn"/>
          </parameter>
          <parameter name="data" transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="622">data to store</doc>
            <array length="2" zero-terminated="0" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="623">number of bytes in @data</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get" c:identifier="vips_blob_get">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/type.c"
             line="675">Get the data from a [struct@Blob].

::: seealso
    [ctor@Blob.new].</doc>
        <source-position filename="libvips/include/vips/type.h" line="193"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="685">the
data</doc>
          <array length="0" zero-terminated="0" c:type="void*">
            <type name="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="blob" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="677">[struct@Blob] to fetch from</doc>
            <type name="Blob" c:type="VipsBlob*"/>
          </instance-parameter>
          <parameter name="length"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="678">return number of bytes of data</doc>
            <type name="gsize" c:type="size_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set" c:identifier="vips_blob_set">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/type.c"
             line="695">Any old data is freed and new data attached.

It's sometimes useful to be able to create blobs as empty and then fill
them later.

::: seealso
    [ctor@Blob.new].</doc>
        <source-position filename="libvips/include/vips/type.h" line="195"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="blob" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="697">[struct@Blob] to set</doc>
            <type name="Blob" c:type="VipsBlob*"/>
          </instance-parameter>
          <parameter name="free_fn"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="698">@data will be freed with this function</doc>
            <type name="CallbackFn" c:type="VipsCallbackFn"/>
          </parameter>
          <parameter name="data" transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="699">data to store</doc>
            <array length="2" zero-terminated="0" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="700">number of bytes in @data</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
        </parameters>
      </method>
      <function name="copy" c:identifier="vips_blob_copy">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/type.c"
             line="648">Like [ctor@Blob.new], but take a copy of the data. Useful for bindings
which struggle with callbacks.

::: seealso
    [ctor@Blob.new].</doc>
        <source-position filename="libvips/include/vips/type.h" line="191"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="659">the new [struct@Blob].</doc>
          <type name="Blob" c:type="VipsBlob*"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="650">data to store</doc>
            <array length="1" zero-terminated="0" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="651">number of bytes in @data</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="Buf" c:type="VipsBuf">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/buf.c"
           line="48">A message buffer you can append stuff to safely and quickly. If the message
gets too long, you get "..." and truncation. Message buffers can be on the
stack or heap.

For example:

```c
char txt[256];
VipsBuf buf = VIPS_BUF_STATIC(txt);
int i;

vips_buf_appends(&amp;buf, "Numbers are: ");
for (i = 0; i &lt; array_length; i++) {
    if (i &gt; 0)
        vips_buf_appends(&amp;buf, ", ");
    vips_buf_appendg(&amp;buf, array[i]);
}
printf("%s", vips_buf_all(&amp;buf));
```</doc>
      <source-position filename="libvips/include/vips/buf.h" line="52"/>
      <field name="base" readable="0" private="1">
        <type name="utf8" c:type="char*"/>
      </field>
      <field name="mx" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="i" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="full" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="lasti" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="dynamic" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <method name="all" c:identifier="vips_buf_all">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/buf.c"
             line="707">Return the contents of the buffer as a C string.</doc>
        <source-position filename="libvips/include/vips/buf.h" line="99"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/buf.c"
               line="713">the `NULL`-terminated contents of the buffer. This is a pointer to
the memory managed by the buffer and must not be freed.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="709">the buffer</doc>
            <type name="Buf" c:type="VipsBuf*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="append_size" c:identifier="vips_buf_append_size">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/buf.c"
             line="656">Turn a number of bytes into a sensible string ... eg "12", "12KB", "12MB",
"12GB" etc.</doc>
        <source-position filename="libvips/include/vips/buf.h" line="89"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/buf.c"
               line="664">`FALSE` on overflow, `TRUE` otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="658">the buffer</doc>
            <type name="Buf" c:type="VipsBuf*"/>
          </instance-parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="659">the number of bytes</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="appendc" c:identifier="vips_buf_appendc">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/buf.c"
             line="311">Append a single character @ch to @buf.</doc>
        <source-position filename="libvips/include/vips/buf.h" line="85"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/buf.c"
               line="318">`FALSE` on overflow, `TRUE` otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="313">the buffer</doc>
            <type name="Buf" c:type="VipsBuf*"/>
          </instance-parameter>
          <parameter name="ch" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="314">the character to append to the buffer</doc>
            <type name="gchar" c:type="char"/>
          </parameter>
        </parameters>
      </method>
      <method name="appendd" c:identifier="vips_buf_appendd">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/buf.c"
             line="474">Append a number. If the number is -ve, add brackets. Needed for
building function arguments.</doc>
        <source-position filename="libvips/include/vips/buf.h" line="105"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/buf.c"
               line="482">`FALSE` on overflow, `TRUE` otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="476">the buffer</doc>
            <type name="Buf" c:type="VipsBuf*"/>
          </instance-parameter>
          <parameter name="d" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="477">value to format and append</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="appendf"
              c:identifier="vips_buf_appendf"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/buf.c"
             line="432">Format the string and append to @buf.</doc>
        <source-position filename="libvips/include/vips/buf.h" line="80"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/buf.c"
               line="440">`FALSE` on overflow, `TRUE` otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="434">the buffer</doc>
            <type name="Buf" c:type="VipsBuf*"/>
          </instance-parameter>
          <parameter name="fmt" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="435">`printf()`-style format string</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="436">arguments to format string</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="appendg" c:identifier="vips_buf_appendg">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/buf.c"
             line="455">Append a double, non-localised. Useful for config files etc.</doc>
        <source-position filename="libvips/include/vips/buf.h" line="103"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/buf.c"
               line="462">`FALSE` on overflow, `TRUE` otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="457">the buffer</doc>
            <type name="Buf" c:type="VipsBuf*"/>
          </instance-parameter>
          <parameter name="g" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="458">value to format and append</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="appendgv" c:identifier="vips_buf_appendgv">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/buf.c"
             line="493">Format and append a [struct@GObject.Value] as a printable thing.
We display text like "3144 bytes of binary data" for BLOBs like icc-profile-data.

Use [method@Image.get_as_string] to make a text representation of a field.
That will base64-encode blobs, for example.</doc>
        <source-position filename="libvips/include/vips/buf.h" line="87"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/buf.c"
               line="504">`FALSE` on overflow, `TRUE` otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="495">the buffer</doc>
            <type name="Buf" c:type="VipsBuf*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="496">[struct@GObject.Value] to format and append</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="appendns" c:identifier="vips_buf_appendns">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/buf.c"
             line="239">Append at most @sz chars from @str to @buf. @sz &lt; 0 means unlimited. This
is the low-level append operation: functions like [method@Buf.appendf] build
on top of this.</doc>
        <source-position filename="libvips/include/vips/buf.h" line="76"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/buf.c"
               line="249">`FALSE` on overflow, `TRUE` otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="241">the buffer</doc>
            <type name="Buf" c:type="VipsBuf*"/>
          </instance-parameter>
          <parameter name="str" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="242">the string to append to the buffer</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="sz" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="243">the size of the string to append</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="appends" c:identifier="vips_buf_appends">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/buf.c"
             line="296">Append the whole of @str to @buf.</doc>
        <source-position filename="libvips/include/vips/buf.h" line="78"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/buf.c"
               line="303">`FALSE` on overflow, `TRUE` otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="298">the buffer</doc>
            <type name="Buf" c:type="VipsBuf*"/>
          </instance-parameter>
          <parameter name="str" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="299">the string to append to the buffer</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="change" c:identifier="vips_buf_change">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/buf.c"
             line="331">Swap the rightmost occurrence of @o for @n.</doc>
        <source-position filename="libvips/include/vips/buf.h" line="93"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/buf.c"
               line="339">`FALSE` on overflow, `TRUE` otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="333">the buffer</doc>
            <type name="Buf" c:type="VipsBuf*"/>
          </instance-parameter>
          <parameter name="o" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="334">the string to search for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="335">the string to substitute</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" c:identifier="vips_buf_destroy">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/buf.c"
             line="116">Destroy a buffer. Only needed for heap buffers. Leaves the buffer in the
_init state.</doc>
        <source-position filename="libvips/include/vips/buf.h" line="64"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="118">the buffer</doc>
            <type name="Buf" c:type="VipsBuf*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="firstline" c:identifier="vips_buf_firstline">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/buf.c"
             line="724">Trim to just the first line (excluding "\n").</doc>
        <source-position filename="libvips/include/vips/buf.h" line="101"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/buf.c"
               line="730">the `NULL`-terminated contents of the buffer. This is a pointer to
the memory managed by the buffer and must not be freed.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="726">the buffer</doc>
            <type name="Buf" c:type="VipsBuf*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="vips_buf_init">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/buf.c"
             line="101">Initialize a buffer.</doc>
        <source-position filename="libvips/include/vips/buf.h" line="66"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="103">the buffer</doc>
            <type name="Buf" c:type="VipsBuf*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init_dynamic" c:identifier="vips_buf_init_dynamic">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/buf.c"
             line="215">Initialise and attach to a heap memory area.
The memory area needs to be at least 4 bytes long.

```c
VipsBuf buf;

vips_buf_init_dynamic(&amp;buf, 256);
```

Dynamic buffers must be freed with [method@Buf.destroy], but their size can
be set at runtime.</doc>
        <source-position filename="libvips/include/vips/buf.h" line="74"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="217">the buffer</doc>
            <type name="Buf" c:type="VipsBuf*"/>
          </instance-parameter>
          <parameter name="mx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="218">the size of the storage area</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_static" c:identifier="vips_buf_init_static">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/buf.c"
             line="155">Initialise and attach to a static memory area. [func@BUF_STATIC] is usually
more convenient.

For example:

```c
char txt[256];
VipsBuf buf;

vips_buf_init_static(&amp;buf, txt, 256);
```

Static buffers don't need to be freed when they go out of scope, but their
size must be set at compile-time.</doc>
        <source-position filename="libvips/include/vips/buf.h" line="72"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="157">the buffer</doc>
            <type name="Buf" c:type="VipsBuf*"/>
          </instance-parameter>
          <parameter name="base" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="158">the start of the memory area to use for storage</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="mx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="159">the size of the storage area</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_empty" c:identifier="vips_buf_is_empty">
        <source-position filename="libvips/include/vips/buf.h" line="95"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/buf.c"
               line="748">`TRUE` if the buffer is empty.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="746">the buffer</doc>
            <type name="Buf" c:type="VipsBuf*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_full" c:identifier="vips_buf_is_full">
        <source-position filename="libvips/include/vips/buf.h" line="97"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/buf.c"
               line="760">`TRUE` if the buffer is full.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="758">the buffer</doc>
            <type name="Buf" c:type="VipsBuf*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="len" c:identifier="vips_buf_len">
        <source-position filename="libvips/include/vips/buf.h" line="107"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/buf.c"
               line="772">the number of characters currently in the buffer.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="770">the buffer</doc>
            <type name="Buf" c:type="VipsBuf*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="removec" c:identifier="vips_buf_removec">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/buf.c"
             line="374">Remove the last character, if it's @ch.</doc>
        <source-position filename="libvips/include/vips/buf.h" line="91"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/buf.c"
               line="381">`TRUE` if a character was removed, `FALSE` otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="376">the buffer</doc>
            <type name="Buf" c:type="VipsBuf*"/>
          </instance-parameter>
          <parameter name="ch" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="377">the character to remove</doc>
            <type name="gchar" c:type="char"/>
          </parameter>
        </parameters>
      </method>
      <method name="rewind" c:identifier="vips_buf_rewind">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/buf.c"
             line="84">Reset the buffer to the empty string.</doc>
        <source-position filename="libvips/include/vips/buf.h" line="62"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="86">the buffer</doc>
            <type name="Buf" c:type="VipsBuf*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_dynamic" c:identifier="vips_buf_set_dynamic">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/buf.c"
             line="183">Attach the buffer to a heap memory area. The buffer needs to have been
initialised. The memory area needs to be at least 4 bytes long.</doc>
        <source-position filename="libvips/include/vips/buf.h" line="70"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="185">the buffer</doc>
            <type name="Buf" c:type="VipsBuf*"/>
          </instance-parameter>
          <parameter name="mx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="186">the size of the storage area</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_static" c:identifier="vips_buf_set_static">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/buf.c"
             line="133">Attach the buffer to a static memory area. The buffer needs to have been
initialised. The memory area needs to be at least 4 bytes long.</doc>
        <source-position filename="libvips/include/vips/buf.h" line="68"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="135">the buffer</doc>
            <type name="Buf" c:type="VipsBuf*"/>
          </instance-parameter>
          <parameter name="base" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="136">the start of the memory area to use for storage</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="mx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="137">the size of the storage area</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="vappendf"
              c:identifier="vips_buf_vappendf"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/buf.c"
             line="395">Append to @buf, args as [`vprintf()`](man:vprintf(3)).</doc>
        <source-position filename="libvips/include/vips/buf.h" line="83"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/buf.c"
               line="403">`FALSE` on overflow, `TRUE` otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="397">the buffer</doc>
            <type name="Buf" c:type="VipsBuf*"/>
          </instance-parameter>
          <parameter name="fmt" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="398">`printf()`-style format string</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="ap" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/buf.c"
                 line="399">arguments to format string</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <function-macro name="CEIL" c:identifier="VIPS_CEIL" introspectable="0">
      <source-position filename="libvips/include/vips/util.h" line="72"/>
      <parameters>
        <parameter name="V">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="CLIP" c:identifier="VIPS_CLIP" introspectable="0">
      <source-position filename="libvips/include/vips/util.h" line="59"/>
      <parameters>
        <parameter name="A">
        </parameter>
        <parameter name="V">
        </parameter>
        <parameter name="B">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="CLIP_CHAR"
                    c:identifier="VIPS_CLIP_CHAR"
                    introspectable="0">
      <source-position filename="libvips/include/vips/util.h" line="172"/>
      <parameters>
        <parameter name="V">
        </parameter>
        <parameter name="SEQ">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="CLIP_NONE"
                    c:identifier="VIPS_CLIP_NONE"
                    introspectable="0">
      <source-position filename="libvips/include/vips/util.h" line="224"/>
      <parameters>
        <parameter name="V">
        </parameter>
        <parameter name="SEQ">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="CLIP_SHORT"
                    c:identifier="VIPS_CLIP_SHORT"
                    introspectable="0">
      <source-position filename="libvips/include/vips/util.h" line="200"/>
      <parameters>
        <parameter name="V">
        </parameter>
        <parameter name="SEQ">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="CLIP_UCHAR"
                    c:identifier="VIPS_CLIP_UCHAR"
                    introspectable="0">
      <source-position filename="libvips/include/vips/util.h" line="158"/>
      <parameters>
        <parameter name="V">
        </parameter>
        <parameter name="SEQ">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="CLIP_UINT"
                    c:identifier="VIPS_CLIP_UINT"
                    introspectable="0">
      <source-position filename="libvips/include/vips/util.h" line="214"/>
      <parameters>
        <parameter name="V">
        </parameter>
        <parameter name="SEQ">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="CLIP_USHORT"
                    c:identifier="VIPS_CLIP_USHORT"
                    introspectable="0">
      <source-position filename="libvips/include/vips/util.h" line="186"/>
      <parameters>
        <parameter name="V">
        </parameter>
        <parameter name="SEQ">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="CONFIG"
              value="enable debug: false&#10;enable deprecated: true&#10;enable modules: true&#10;enable C++ binding: true&#10;enable RAD load/save: true&#10;enable Analyze7 load: true&#10;enable PPM load/save: true&#10;enable GIF load: true&#10;FFTs with fftw3: true&#10;SIMD support with libhwy: true&#10;ICC profile support with lcms2: true&#10;deflate compression with zlib: true&#10;text rendering with pangocairo: true&#10;font file support with fontconfig: true&#10;EXIF metadata support with libexif: true&#10;JPEG load/save with libjpeg: true&#10;UHDR load/save with libuhdr: true&#10;JXL load/save with libjxl: true (dynamic module: true)&#10;JPEG2000 load/save with libopenjp2: true&#10;PNG load/save with libpng: true&#10;image quantisation with imagequant: true&#10;TIFF load/save with libtiff-4: true&#10;image pyramid save with libarchive: true&#10;HEIC/AVIF load/save with libheif: true (dynamic module: true)&#10;WebP load/save with libwebp: true&#10;PDF load with poppler-glib: true (dynamic module: true)&#10;SVG load with librsvg-2.0: true&#10;EXR load with OpenEXR: true&#10;WSI load with openslide: true (dynamic module: true)&#10;Matlab load with matio: true&#10;NIfTI load/save with libnifti: false&#10;FITS load/save with cfitsio: true&#10;GIF save with cgif: true&#10;RAW load with libraw_r: true&#10;Magick load/save with MagickCore: true (dynamic module: true)"
              c:type="VIPS_CONFIG">
      <source-position filename="libvips/include/vips/version.h" line="19"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <function-macro name="CONNECTION"
                    c:identifier="VIPS_CONNECTION"
                    introspectable="0">
      <source-position filename="libvips/include/vips/connection.h" line="47"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="CONNECTION_CLASS"
                    c:identifier="VIPS_CONNECTION_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/connection.h" line="50"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="CONNECTION_GET_CLASS"
                    c:identifier="VIPS_CONNECTION_GET_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/connection.h" line="57"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="COUNT_PIXELS"
                    c:identifier="VIPS_COUNT_PIXELS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/region.h" line="193"/>
      <parameters>
        <parameter name="R">
        </parameter>
        <parameter name="N">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="C_X0" value="98.070000" c:type="VIPS_C_X0">
      <doc xml:space="preserve"
           filename="libvips/colour/colour.c"
           line="94">Areas under curves for illuminant C (6774K), 2 degree observer.</doc>
      <source-position filename="libvips/include/vips/colour.h" line="84"/>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="C_Y0" value="100.000000" c:type="VIPS_C_Y0">
      <source-position filename="libvips/include/vips/colour.h" line="85"/>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="C_Z0" value="118.230000" c:type="VIPS_C_Z0">
      <source-position filename="libvips/include/vips/colour.h" line="86"/>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <callback name="CallbackFn" c:type="VipsCallbackFn">
      <source-position filename="libvips/include/vips/basic.h" line="95"/>
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ClassMapFn" c:type="VipsClassMapFn">
      <source-position filename="libvips/include/vips/object.h" line="670"/>
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="cls" transfer-ownership="none">
          <type name="ObjectClass" c:type="VipsObjectClass*"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="Coding"
                 glib:type-name="VipsCoding"
                 glib:get-type="vips_coding_get_type"
                 c:type="VipsCoding">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/image.c"
           line="256">How pixels are coded.

Normally, pixels are uncoded and can be manipulated as you would expect.
However some file formats code pixels for compression, and sometimes it's
useful to be able to manipulate images in the coded format.

The gaps in the numbering are historical and must be maintained. Allocate
new numbers from the end.</doc>
      <member name="error"
              value="-1"
              c:identifier="VIPS_CODING_ERROR"
              glib:nick="error"
              glib:name="VIPS_CODING_ERROR">
      </member>
      <member name="none"
              value="0"
              c:identifier="VIPS_CODING_NONE"
              glib:nick="none"
              glib:name="VIPS_CODING_NONE">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="258">pixels are not coded</doc>
      </member>
      <member name="labq"
              value="2"
              c:identifier="VIPS_CODING_LABQ"
              glib:nick="labq"
              glib:name="VIPS_CODING_LABQ">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="259">pixels encode 3 float CIELAB values as 4 uchar</doc>
      </member>
      <member name="rad"
              value="6"
              c:identifier="VIPS_CODING_RAD"
              glib:nick="rad"
              glib:name="VIPS_CODING_RAD">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="260">pixels encode 3 float RGB as 4 uchar (Radiance coding)</doc>
      </member>
    </enumeration>
    <enumeration name="Combine"
                 glib:type-name="VipsCombine"
                 glib:get-type="vips_combine_get_type"
                 c:type="VipsCombine">
      <doc xml:space="preserve"
           filename="libvips/convolution/convolution.c"
           line="63">How to combine values. See [method@Image.compass], for example.</doc>
      <member name="max"
              value="0"
              c:identifier="VIPS_COMBINE_MAX"
              glib:nick="max"
              glib:name="VIPS_COMBINE_MAX">
        <doc xml:space="preserve"
             filename="libvips/convolution/convolution.c"
             line="65">take the maximum of the possible values</doc>
      </member>
      <member name="sum"
              value="1"
              c:identifier="VIPS_COMBINE_SUM"
              glib:nick="sum"
              glib:name="VIPS_COMBINE_SUM">
        <doc xml:space="preserve"
             filename="libvips/convolution/convolution.c"
             line="66">sum all the values</doc>
      </member>
      <member name="min"
              value="2"
              c:identifier="VIPS_COMBINE_MIN"
              glib:nick="min"
              glib:name="VIPS_COMBINE_MIN">
        <doc xml:space="preserve"
             filename="libvips/convolution/convolution.c"
             line="67">take the minimum value</doc>
      </member>
    </enumeration>
    <enumeration name="CombineMode"
                 glib:type-name="VipsCombineMode"
                 glib:get-type="vips_combine_mode_get_type"
                 c:type="VipsCombineMode">
      <doc xml:space="preserve"
           filename="libvips/draw/draw.c"
           line="48">See [method@Image.draw_image] and so on.

Operations like [method@Image.draw_image] need to be told how to combine images
from two sources.

::: seealso
    [method@Image.join].</doc>
      <member name="set"
              value="0"
              c:identifier="VIPS_COMBINE_MODE_SET"
              glib:nick="set"
              glib:name="VIPS_COMBINE_MODE_SET">
        <doc xml:space="preserve"
             filename="libvips/draw/draw.c"
             line="50">set pixels to the new value</doc>
      </member>
      <member name="add"
              value="1"
              c:identifier="VIPS_COMBINE_MODE_ADD"
              glib:nick="add"
              glib:name="VIPS_COMBINE_MODE_ADD">
        <doc xml:space="preserve"
             filename="libvips/draw/draw.c"
             line="51">add pixels</doc>
      </member>
    </enumeration>
    <enumeration name="CompassDirection"
                 glib:type-name="VipsCompassDirection"
                 glib:get-type="vips_compass_direction_get_type"
                 c:type="VipsCompassDirection">
      <doc xml:space="preserve"
           filename="libvips/conversion/conversion.c"
           line="214">A direction on a compass. Used for [method@Image.gravity], for example.</doc>
      <member name="centre"
              value="0"
              c:identifier="VIPS_COMPASS_DIRECTION_CENTRE"
              glib:nick="centre"
              glib:name="VIPS_COMPASS_DIRECTION_CENTRE">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="216">centre</doc>
      </member>
      <member name="north"
              value="1"
              c:identifier="VIPS_COMPASS_DIRECTION_NORTH"
              glib:nick="north"
              glib:name="VIPS_COMPASS_DIRECTION_NORTH">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="217">north</doc>
      </member>
      <member name="east"
              value="2"
              c:identifier="VIPS_COMPASS_DIRECTION_EAST"
              glib:nick="east"
              glib:name="VIPS_COMPASS_DIRECTION_EAST">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="218">east</doc>
      </member>
      <member name="south"
              value="3"
              c:identifier="VIPS_COMPASS_DIRECTION_SOUTH"
              glib:nick="south"
              glib:name="VIPS_COMPASS_DIRECTION_SOUTH">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="219">south</doc>
      </member>
      <member name="west"
              value="4"
              c:identifier="VIPS_COMPASS_DIRECTION_WEST"
              glib:nick="west"
              glib:name="VIPS_COMPASS_DIRECTION_WEST">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="220">west</doc>
      </member>
      <member name="north_east"
              value="5"
              c:identifier="VIPS_COMPASS_DIRECTION_NORTH_EAST"
              glib:nick="north-east"
              glib:name="VIPS_COMPASS_DIRECTION_NORTH_EAST">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="221">north-east</doc>
      </member>
      <member name="south_east"
              value="6"
              c:identifier="VIPS_COMPASS_DIRECTION_SOUTH_EAST"
              glib:nick="south-east"
              glib:name="VIPS_COMPASS_DIRECTION_SOUTH_EAST">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="222">south-east</doc>
      </member>
      <member name="south_west"
              value="7"
              c:identifier="VIPS_COMPASS_DIRECTION_SOUTH_WEST"
              glib:nick="south-west"
              glib:name="VIPS_COMPASS_DIRECTION_SOUTH_WEST">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="223">south-west</doc>
      </member>
      <member name="north_west"
              value="8"
              c:identifier="VIPS_COMPASS_DIRECTION_NORTH_WEST"
              glib:nick="north-west"
              glib:name="VIPS_COMPASS_DIRECTION_NORTH_WEST">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="224">north-west</doc>
      </member>
    </enumeration>
    <class name="Connection"
           c:symbol-prefix="connection"
           c:type="VipsConnection"
           parent="Object"
           abstract="1"
           glib:type-name="VipsConnection"
           glib:get-type="vips_connection_get_type"
           glib:type-struct="ConnectionClass">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/connection.c"
           line="58">An abstract base class representing a source or sink of bytes.

It can be connected to a network socket, for example, or perhaps
a Node.js stream, or to an area of memory. This allows it to support
operations like JPEG loading, see for example [ctor@Image.jpegload_source].

Subclass to add other input sources. Use [class@SourceCustom] and
[class@TargetCustom] to make a source or target with action signals.
These classes provide action signals such as:

- [signal@SourceCustom::read] for reading data from a custom source.
- [signal@SourceCustom::seek] for seeking within a data stream.
- [signal@TargetCustom::write] for writing data to a custom target.</doc>
      <source-position filename="libvips/include/vips/connection.h" line="89"/>
      <method name="filename" c:identifier="vips_connection_filename">
        <source-position filename="libvips/include/vips/connection.h"
                         line="95"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/connection.c"
               line="144">any filename associated with this connection, or `NULL`.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/connection.c"
                 line="142">connection to operate on</doc>
            <type name="Connection" c:type="VipsConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="nick" c:identifier="vips_connection_nick">
        <source-position filename="libvips/include/vips/connection.h"
                         line="97"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/connection.c"
               line="156">a string describing this connection which could be displayed to a
user.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/connection.c"
                 line="154">connection to operate on</doc>
            <type name="Connection" c:type="VipsConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="descriptor"
                writable="1"
                transfer-ownership="none"
                default-value="0">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="filename"
                writable="1"
                transfer-ownership="none"
                default-value="NULL">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent_object">
        <type name="Object" c:type="VipsObject"/>
      </field>
      <field name="descriptor" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="tracked_descriptor" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="close_descriptor" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="filename" readable="0" private="1">
        <type name="utf8" c:type="char*"/>
      </field>
    </class>
    <record name="ConnectionClass"
            c:type="VipsConnectionClass"
            glib:is-gtype-struct-for="Connection">
      <source-position filename="libvips/include/vips/connection.h" line="89"/>
      <field name="parent_class">
        <type name="ObjectClass" c:type="VipsObjectClass"/>
      </field>
    </record>
    <constant name="D3250_X0" value="105.659000" c:type="VIPS_D3250_X0">
      <doc xml:space="preserve"
           filename="libvips/colour/colour.c"
           line="106">Areas under curves for black body at 3250K, 2 degree observer.</doc>
      <source-position filename="libvips/include/vips/colour.h" line="92"/>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="D3250_Y0" value="100.000000" c:type="VIPS_D3250_Y0">
      <source-position filename="libvips/include/vips/colour.h" line="93"/>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="D3250_Z0" value="45.850100" c:type="VIPS_D3250_Z0">
      <source-position filename="libvips/include/vips/colour.h" line="94"/>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="D50_X0" value="96.425000" c:type="VIPS_D50_X0">
      <doc xml:space="preserve"
           filename="libvips/colour/colour.c"
           line="76">Areas under curves for D50, 2 degree observer.</doc>
      <source-position filename="libvips/include/vips/colour.h" line="66"/>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="D50_Y0" value="100.000000" c:type="VIPS_D50_Y0">
      <source-position filename="libvips/include/vips/colour.h" line="67"/>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="D50_Z0" value="82.468000" c:type="VIPS_D50_Z0">
      <source-position filename="libvips/include/vips/colour.h" line="68"/>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="D55_X0" value="95.683100" c:type="VIPS_D55_X0">
      <doc xml:space="preserve"
           filename="libvips/colour/colour.c"
           line="70">Areas under curves for D55, 2 degree observer.</doc>
      <source-position filename="libvips/include/vips/colour.h" line="62"/>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="D55_Y0" value="100.000000" c:type="VIPS_D55_Y0">
      <source-position filename="libvips/include/vips/colour.h" line="63"/>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="D55_Z0" value="92.087100" c:type="VIPS_D55_Z0">
      <source-position filename="libvips/include/vips/colour.h" line="64"/>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="D65_X0" value="95.047000" c:type="VIPS_D65_X0">
      <doc xml:space="preserve"
           filename="libvips/colour/colour.c"
           line="64">Areas under curves for D65, 2 degree observer.</doc>
      <source-position filename="libvips/include/vips/colour.h" line="58"/>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="D65_Y0" value="100.000000" c:type="VIPS_D65_Y0">
      <source-position filename="libvips/include/vips/colour.h" line="59"/>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="D65_Z0" value="108.882700" c:type="VIPS_D65_Z0">
      <source-position filename="libvips/include/vips/colour.h" line="60"/>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="D75_X0" value="94.968200" c:type="VIPS_D75_X0">
      <doc xml:space="preserve"
           filename="libvips/colour/colour.c"
           line="58">Areas under curves for D75, 2 degree observer.</doc>
      <source-position filename="libvips/include/vips/colour.h" line="52"/>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="D75_Y0" value="100.000000" c:type="VIPS_D75_Y0">
      <source-position filename="libvips/include/vips/colour.h" line="53"/>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="D75_Z0" value="122.571000" c:type="VIPS_D75_Z0">
      <source-position filename="libvips/include/vips/colour.h" line="54"/>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="D93_X0" value="89.740000" c:type="VIPS_D93_X0">
      <doc xml:space="preserve"
           filename="libvips/colour/colour.c"
           line="52">Areas under curves for D93, 2 degree observer.</doc>
      <source-position filename="libvips/include/vips/colour.h" line="48"/>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="D93_Y0" value="100.000000" c:type="VIPS_D93_Y0">
      <source-position filename="libvips/include/vips/colour.h" line="49"/>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="D93_Z0" value="130.770000" c:type="VIPS_D93_Z0">
      <source-position filename="libvips/include/vips/colour.h" line="50"/>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="DEFAULT_MAX_COORD"
              value="100000000"
              c:type="VIPS_DEFAULT_MAX_COORD">
      <source-position filename="libvips/include/vips/image.h" line="65"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="DEG" c:identifier="VIPS_DEG" introspectable="0">
      <source-position filename="libvips/include/vips/util.h" line="51"/>
      <parameters>
        <parameter name="A">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_FOR"
                    c:identifier="VIPS_DEPRECATED_ENUMERATOR_FOR"
                    introspectable="0">
      <source-position filename="libvips/include/vips/basic.h" line="75"/>
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_FOR"
                    c:identifier="VIPS_DEPRECATED_FOR"
                    introspectable="0">
      <source-position filename="libvips/include/vips/basic.h" line="53"/>
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_FOR"
                    c:identifier="VIPS_DEPRECATED_MACRO_FOR"
                    introspectable="0">
      <source-position filename="libvips/include/vips/basic.h" line="64"/>
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <record name="Dbuf" c:type="VipsDbuf">
      <source-position filename="libvips/include/vips/dbuf.h" line="62"/>
      <field name="data" readable="0" private="1">
        <type name="guint8" c:type="unsigned char*"/>
      </field>
      <field name="allocated_size" readable="0" private="1">
        <type name="gsize" c:type="size_t"/>
      </field>
      <field name="data_size" readable="0" private="1">
        <type name="gsize" c:type="size_t"/>
      </field>
      <field name="write_point" readable="0" private="1">
        <type name="gsize" c:type="size_t"/>
      </field>
      <method name="allocate" c:identifier="vips_dbuf_allocate">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/dbuf.c"
             line="92">Make sure @dbuf has at least @size bytes available after the write point.</doc>
        <source-position filename="libvips/include/vips/dbuf.h" line="69"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/dbuf.c"
               line="99">`FALSE` on out of memory, `TRUE` otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dbuf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/dbuf.c"
                 line="94">the buffer</doc>
            <type name="Dbuf" c:type="VipsDbuf*"/>
          </instance-parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/dbuf.c"
                 line="95">the size to allocate</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" c:identifier="vips_dbuf_destroy">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/dbuf.c"
             line="282">Destroy @dbuf. This frees any allocated memory. Useful for dbufs on the
stack.</doc>
        <source-position filename="libvips/include/vips/dbuf.h" line="85"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dbuf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/dbuf.c"
                 line="284">the buffer</doc>
            <type name="Dbuf" c:type="VipsDbuf*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_write" c:identifier="vips_dbuf_get_write">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/dbuf.c"
             line="130">Return a pointer to an area you can write to, return length of area in
@size. Use [method@Dbuf.allocate] before this call to set a minimum amount of
space to have available.

The write point moves to just beyond the returned block. Use
[method@Dbuf.seek] to move it back again.</doc>
        <source-position filename="libvips/include/vips/dbuf.h" line="73"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/dbuf.c"
               line="142">start of write area.</doc>
          <type name="guint8" c:type="unsigned char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="dbuf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/dbuf.c"
                 line="132">the buffer</doc>
            <type name="Dbuf" c:type="VipsDbuf*"/>
          </instance-parameter>
          <parameter name="size"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/dbuf.c"
                 line="133">optionally return length in bytes here</doc>
            <type name="gsize" c:type="size_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="vips_dbuf_init">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/dbuf.c"
             line="44">Initialize @dbuf. You can also just init to zero, eg.
`VipsDbuf buf = {0};`.

Destroy with [method@Dbuf.destroy].</doc>
        <source-position filename="libvips/include/vips/dbuf.h" line="65"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dbuf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/dbuf.c"
                 line="46">the buffer</doc>
            <type name="Dbuf" c:type="VipsDbuf*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="minimum_size" c:identifier="vips_dbuf_minimum_size">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/dbuf.c"
             line="62">Make sure @dbuf is at least @size bytes.</doc>
        <source-position filename="libvips/include/vips/dbuf.h" line="67"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/dbuf.c"
               line="69">`FALSE` on out of memory, `TRUE` otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dbuf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/dbuf.c"
                 line="64">the buffer</doc>
            <type name="Dbuf" c:type="VipsDbuf*"/>
          </instance-parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/dbuf.c"
                 line="65">the minimum size</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="read" c:identifier="vips_dbuf_read">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/dbuf.c"
             line="107">Up to @size bytes are read from the buffer and copied to @data. The number
of bytes transferred is returned.</doc>
        <source-position filename="libvips/include/vips/dbuf.h" line="71"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/dbuf.c"
               line="116">the number of bytes transferred.</doc>
          <type name="gsize" c:type="size_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="dbuf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/dbuf.c"
                 line="109">the buffer</doc>
            <type name="Dbuf" c:type="VipsDbuf*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/dbuf.c"
                 line="110">read to this area</doc>
            <type name="guint8" c:type="unsigned char*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/dbuf.c"
                 line="111">read up to this many bytes</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="reset" c:identifier="vips_dbuf_reset">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/dbuf.c"
             line="268">Reset the buffer to empty. No memory is freed, just the data size and
write point are reset.</doc>
        <source-position filename="libvips/include/vips/dbuf.h" line="83"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dbuf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/dbuf.c"
                 line="270">the buffer</doc>
            <type name="Dbuf" c:type="VipsDbuf*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="seek" c:identifier="vips_dbuf_seek">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/dbuf.c"
             line="298">Move the write point. @whence can be `SEEK_SET`, `SEEK_CUR`, `SEEK_END`, with
the usual meaning.</doc>
        <source-position filename="libvips/include/vips/dbuf.h" line="87"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dbuf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/dbuf.c"
                 line="300">the buffer</doc>
            <type name="Dbuf" c:type="VipsDbuf*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/dbuf.c"
                 line="301">how to move the write point</doc>
            <type name="off_t" c:type="off_t"/>
          </parameter>
          <parameter name="whence" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/dbuf.c"
                 line="302">from start, from end, from current</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="steal" c:identifier="vips_dbuf_steal">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/dbuf.c"
             line="396">Destroy a buffer, but rather than freeing memory, a pointer is returned.
This must be freed with [func@GLib.free].

A `\0` is appended, but not included in the character count. This is so the
pointer can be safely treated as a C string.</doc>
        <source-position filename="libvips/include/vips/dbuf.h" line="95"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/dbuf.c"
               line="407">The pointer held by @dbuf.</doc>
          <type name="guint8" c:type="unsigned char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="dbuf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/dbuf.c"
                 line="398">the buffer</doc>
            <type name="Dbuf" c:type="VipsDbuf*"/>
          </instance-parameter>
          <parameter name="size"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/dbuf.c"
                 line="399">optionally return length in bytes here</doc>
            <type name="gsize" c:type="size_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="string" c:identifier="vips_dbuf_string">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/dbuf.c"
             line="427">Return a pointer to @dbuf's internal data.

A `\0` is appended, but not included in the character count. This is so the
pointer can be safely treated as a C string.</doc>
        <source-position filename="libvips/include/vips/dbuf.h" line="93"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/dbuf.c"
               line="437">The pointer held by @dbuf.</doc>
          <type name="guint8" c:type="unsigned char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="dbuf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/dbuf.c"
                 line="429">the buffer</doc>
            <type name="Dbuf" c:type="VipsDbuf*"/>
          </instance-parameter>
          <parameter name="size"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/dbuf.c"
                 line="430">optionally return length in bytes here</doc>
            <type name="gsize" c:type="size_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="tell" c:identifier="vips_dbuf_tell">
        <source-position filename="libvips/include/vips/dbuf.h" line="91"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/dbuf.c"
               line="366">the current write point</doc>
          <type name="off_t" c:type="off_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="dbuf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/dbuf.c"
                 line="364">the buffer</doc>
            <type name="Dbuf" c:type="VipsDbuf*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="truncate" c:identifier="vips_dbuf_truncate">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/dbuf.c"
             line="350">Truncate the data so that it ends at the write point. No memory is freed.</doc>
        <source-position filename="libvips/include/vips/dbuf.h" line="89"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dbuf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/dbuf.c"
                 line="352">the buffer</doc>
            <type name="Dbuf" c:type="VipsDbuf*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="write" c:identifier="vips_dbuf_write">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/dbuf.c"
             line="160">Append @size bytes from @data. @dbuf expands if necessary.</doc>
        <source-position filename="libvips/include/vips/dbuf.h" line="75"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/dbuf.c"
               line="168">`FALSE` on out of memory, `TRUE` otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dbuf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/dbuf.c"
                 line="162">the buffer</doc>
            <type name="Dbuf" c:type="VipsDbuf*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/dbuf.c"
                 line="163">the data to write to the buffer</doc>
            <type name="guint8" c:type="const unsigned char*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/dbuf.c"
                 line="164">the size of the len to write</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="write_amp" c:identifier="vips_dbuf_write_amp">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/dbuf.c"
             line="211">Write @str to @dbuf, but escape stuff that xml hates in text. Our
argument string is utf-8.

XML rules:

- We must escape &amp;&lt;&gt;
- Don't escape \n, \t, \r
- Do escape the other ASCII codes.</doc>
        <source-position filename="libvips/include/vips/dbuf.h" line="81"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/dbuf.c"
               line="225">`FALSE` on out of memory, `TRUE` otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dbuf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/dbuf.c"
                 line="213">the buffer</doc>
            <type name="Dbuf" c:type="VipsDbuf*"/>
          </instance-parameter>
          <parameter name="str" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/dbuf.c"
                 line="214">string to write</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="writef" c:identifier="vips_dbuf_writef" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/dbuf.c"
             line="183">Format the string and write to @dbuf.</doc>
        <source-position filename="libvips/include/vips/dbuf.h" line="78"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/dbuf.c"
               line="191">`FALSE` on out of memory, `TRUE` otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dbuf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/dbuf.c"
                 line="185">the buffer</doc>
            <type name="Dbuf" c:type="VipsDbuf*"/>
          </instance-parameter>
          <parameter name="fmt" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/dbuf.c"
                 line="186">`printf()`-style format string</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/dbuf.c"
                 line="187">arguments to format string</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="DemandStyle"
                 glib:type-name="VipsDemandStyle"
                 glib:get-type="vips_demand_style_get_type"
                 c:type="VipsDemandStyle">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/image.c"
           line="163">See [method@Image.pipelinev]. Operations can hint
the kind of demand geometry they prefer
to the VIPS image IO system.

These demand styles are given below in order of increasing
specialisation.  When demanding output from a pipeline,
[method@Image.generate]
will use the most general style requested by the operations
in the pipeline.

[enum@Vips.DemandStyle.SMALLTILE] -- This is the most general demand format.
Output is demanded in small (around 100x100 pel) sections. This style works
reasonably efficiently, even for bizarre operations like 45 degree rotate.

[enum@Vips.DemandStyle.FATSTRIP] -- This operation would like to output strips
the width of the image and as high as possible. This option is suitable
for area operations which do not violently transform coordinates, such
as [method@Image.conv].

[enum@Vips.DemandStyle.THINSTRIP] -- This operation would like to output strips
the width of the image and a few pels high. This option is suitable for
point-to-point operations, such as those in the arithmetic package.

[enum@Vips.DemandStyle.ANY] -- This image is not being demand-read from a disc
file (even indirectly) so any demand style is OK. It's used for things like
[ctor@Image.black] where the pixels are calculated.

::: seealso
    [method@Image.pipelinev].</doc>
      <member name="error"
              value="-1"
              c:identifier="VIPS_DEMAND_STYLE_ERROR"
              glib:nick="error"
              glib:name="VIPS_DEMAND_STYLE_ERROR">
      </member>
      <member name="smalltile"
              value="0"
              c:identifier="VIPS_DEMAND_STYLE_SMALLTILE"
              glib:nick="smalltile"
              glib:name="VIPS_DEMAND_STYLE_SMALLTILE">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="165">demand in small (typically 128x128 pixel) tiles</doc>
      </member>
      <member name="fatstrip"
              value="1"
              c:identifier="VIPS_DEMAND_STYLE_FATSTRIP"
              glib:nick="fatstrip"
              glib:name="VIPS_DEMAND_STYLE_FATSTRIP">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="166">demand in fat (typically 16 pixel high) strips</doc>
      </member>
      <member name="thinstrip"
              value="2"
              c:identifier="VIPS_DEMAND_STYLE_THINSTRIP"
              glib:nick="thinstrip"
              glib:name="VIPS_DEMAND_STYLE_THINSTRIP">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="167">demand in thin (typically 1 pixel high) strips</doc>
      </member>
      <member name="any"
              value="3"
              c:identifier="VIPS_DEMAND_STYLE_ANY"
              glib:nick="any"
              glib:name="VIPS_DEMAND_STYLE_ANY">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="168">demand geometry does not matter</doc>
      </member>
    </enumeration>
    <enumeration name="Direction"
                 glib:type-name="VipsDirection"
                 glib:get-type="vips_direction_get_type"
                 c:type="VipsDirection">
      <doc xml:space="preserve"
           filename="libvips/conversion/conversion.c"
           line="283">See [method@Image.flip], [method@Image.join] and so on.

Operations like [method@Image.flip] need to be told whether to flip left-right or
top-bottom.

::: seealso
    [method@Image.flip], [method@Image.join].</doc>
      <member name="horizontal"
              value="0"
              c:identifier="VIPS_DIRECTION_HORIZONTAL"
              glib:nick="horizontal"
              glib:name="VIPS_DIRECTION_HORIZONTAL">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="285">left-right</doc>
      </member>
      <member name="vertical"
              value="1"
              c:identifier="VIPS_DIRECTION_VERTICAL"
              glib:nick="vertical"
              glib:name="VIPS_DIRECTION_VERTICAL">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="286">top-bottom</doc>
      </member>
    </enumeration>
    <constant name="ENABLE_DEPRECATED"
              value="1"
              c:type="VIPS_ENABLE_DEPRECATED">
      <source-position filename="libvips/include/vips/version.h" line="24"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="E_X0" value="100.000000" c:type="VIPS_E_X0">
      <doc xml:space="preserve"
           filename="libvips/colour/colour.c"
           line="100">Areas under curves for equal energy illuminant E.</doc>
      <source-position filename="libvips/include/vips/colour.h" line="88"/>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="E_Y0" value="100.000000" c:type="VIPS_E_Y0">
      <source-position filename="libvips/include/vips/colour.h" line="89"/>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="E_Z0" value="100.000000" c:type="VIPS_E_Z0">
      <source-position filename="libvips/include/vips/colour.h" line="90"/>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <enumeration name="Extend"
                 glib:type-name="VipsExtend"
                 glib:get-type="vips_extend_get_type"
                 c:type="VipsExtend">
      <doc xml:space="preserve"
           filename="libvips/conversion/conversion.c"
           line="248">See [method@Image.embed], [method@Image.conv], [method@Image.affine] and so on.

When the edges of an image are extended, you can specify
how you want the extension done.

[enum@Vips.Extend.BLACK] -- new pixels are black, ie. all bits are zero.

[enum@Vips.Extend.COPY] -- each new pixel takes the value of the nearest edge
pixel

[enum@Vips.Extend.REPEAT] -- the image is tiled to fill the new area

[enum@Vips.Extend.MIRROR] -- the image is reflected and tiled to reduce hash
edges

[enum@Vips.Extend.WHITE] -- new pixels are white, ie. all bits are set

[enum@Vips.Extend.BACKGROUND] -- colour set from the @background property

We have to specify the exact value of each enum member since we have to
keep these frozen for back compat with vips7.

::: seealso
    [method@Image.embed].</doc>
      <member name="black"
              value="0"
              c:identifier="VIPS_EXTEND_BLACK"
              glib:nick="black"
              glib:name="VIPS_EXTEND_BLACK">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="250">extend with black (all 0) pixels</doc>
      </member>
      <member name="copy"
              value="1"
              c:identifier="VIPS_EXTEND_COPY"
              glib:nick="copy"
              glib:name="VIPS_EXTEND_COPY">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="251">copy the image edges</doc>
      </member>
      <member name="repeat"
              value="2"
              c:identifier="VIPS_EXTEND_REPEAT"
              glib:nick="repeat"
              glib:name="VIPS_EXTEND_REPEAT">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="252">repeat the whole image</doc>
      </member>
      <member name="mirror"
              value="3"
              c:identifier="VIPS_EXTEND_MIRROR"
              glib:nick="mirror"
              glib:name="VIPS_EXTEND_MIRROR">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="253">mirror the whole image</doc>
      </member>
      <member name="white"
              value="4"
              c:identifier="VIPS_EXTEND_WHITE"
              glib:nick="white"
              glib:name="VIPS_EXTEND_WHITE">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="254">extend with white (all bits set) pixels</doc>
      </member>
      <member name="background"
              value="5"
              c:identifier="VIPS_EXTEND_BACKGROUND"
              glib:nick="background"
              glib:name="VIPS_EXTEND_BACKGROUND">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="255">extend with colour from the @background property</doc>
      </member>
    </enumeration>
    <function-macro name="FABS" c:identifier="VIPS_FABS" introspectable="0">
      <source-position filename="libvips/include/vips/util.h" line="65"/>
      <parameters>
        <parameter name="V">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="FCLIP" c:identifier="VIPS_FCLIP" introspectable="0">
      <source-position filename="libvips/include/vips/util.h" line="60"/>
      <parameters>
        <parameter name="A">
        </parameter>
        <parameter name="V">
        </parameter>
        <parameter name="B">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="FLOOR" c:identifier="VIPS_FLOOR" introspectable="0">
      <source-position filename="libvips/include/vips/util.h" line="71"/>
      <parameters>
        <parameter name="V">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="FMAX" c:identifier="VIPS_FMAX" introspectable="0">
      <source-position filename="libvips/include/vips/util.h" line="56"/>
      <parameters>
        <parameter name="A">
        </parameter>
        <parameter name="B">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="FMIN" c:identifier="VIPS_FMIN" introspectable="0">
      <source-position filename="libvips/include/vips/util.h" line="57"/>
      <parameters>
        <parameter name="A">
        </parameter>
        <parameter name="B">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="FOREIGN"
                    c:identifier="VIPS_FOREIGN"
                    introspectable="0">
      <source-position filename="libvips/include/vips/foreign.h" line="45"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="FOREIGN_CLASS"
                    c:identifier="VIPS_FOREIGN_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/foreign.h" line="48"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="FOREIGN_GET_CLASS"
                    c:identifier="VIPS_FOREIGN_GET_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/foreign.h" line="55"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="FOREIGN_LOAD"
                    c:identifier="VIPS_FOREIGN_LOAD"
                    introspectable="0">
      <source-position filename="libvips/include/vips/foreign.h" line="130"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="FOREIGN_LOAD_CLASS"
                    c:identifier="VIPS_FOREIGN_LOAD_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/foreign.h" line="133"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="FOREIGN_LOAD_GET_CLASS"
                    c:identifier="VIPS_FOREIGN_LOAD_GET_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/foreign.h" line="140"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="FOREIGN_SAVE"
                    c:identifier="VIPS_FOREIGN_SAVE"
                    introspectable="0">
      <source-position filename="libvips/include/vips/foreign.h" line="296"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="FOREIGN_SAVE_CLASS"
                    c:identifier="VIPS_FOREIGN_SAVE_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/foreign.h" line="299"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="FOREIGN_SAVE_GET_CLASS"
                    c:identifier="VIPS_FOREIGN_SAVE_GET_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/foreign.h" line="306"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="FREE" c:identifier="VIPS_FREE" introspectable="0">
      <source-position filename="libvips/include/vips/memory.h" line="50"/>
      <parameters>
        <parameter name="S">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="FREEF" c:identifier="VIPS_FREEF" introspectable="0">
      <source-position filename="libvips/include/vips/memory.h" line="40"/>
      <parameters>
        <parameter name="F">
        </parameter>
        <parameter name="S">
        </parameter>
      </parameters>
    </function-macro>
    <enumeration name="FailOn"
                 glib:type-name="VipsFailOn"
                 glib:get-type="vips_fail_on_get_type"
                 c:type="VipsFailOn">
      <doc xml:space="preserve"
           filename="libvips/include/vips/foreign.h"
           line="108">How sensitive loaders are to errors, from never stop (very insensitive), to
stop on the smallest warning (very sensitive).

Each one implies the ones before it, so [enum@Vips.FailOn.ERROR] implies
[enum@Vips.FailOn.TRUNCATED].</doc>
      <member name="none"
              value="0"
              c:identifier="VIPS_FAIL_ON_NONE"
              glib:nick="none"
              glib:name="VIPS_FAIL_ON_NONE">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="110">never stop</doc>
      </member>
      <member name="truncated"
              value="1"
              c:identifier="VIPS_FAIL_ON_TRUNCATED"
              glib:nick="truncated"
              glib:name="VIPS_FAIL_ON_TRUNCATED">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="111">stop on image truncated, nothing else</doc>
      </member>
      <member name="error"
              value="2"
              c:identifier="VIPS_FAIL_ON_ERROR"
              glib:nick="error"
              glib:name="VIPS_FAIL_ON_ERROR">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="112">stop on serious error or truncation</doc>
      </member>
      <member name="warning"
              value="3"
              c:identifier="VIPS_FAIL_ON_WARNING"
              glib:nick="warning"
              glib:name="VIPS_FAIL_ON_WARNING">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="113">stop on anything, even warnings</doc>
      </member>
    </enumeration>
    <class name="Foreign"
           c:symbol-prefix="foreign"
           c:type="VipsForeign"
           parent="Operation"
           abstract="1"
           glib:type-name="VipsForeign"
           glib:get-type="vips_foreign_get_type"
           glib:type-struct="ForeignClass">
      <doc xml:space="preserve"
           filename="libvips/foreign/foreign.c"
           line="76">An abstract base class to load and save images in a variety of formats.

## Load and save

You can load and save from and to files, memory areas, and the libvips IO
abstractions, [class@Source] and [class@Target].

Use [func@Foreign.find_load] [func@Foreign.find_load_buffer] and
[func@Foreign.find_load_source] to find a loader for an object. Use
[func@Foreign.find_save], [func@Foreign.find_save_buffer] and
[func@Foreign.find_save_target] to find a saver for a format. You can then
run these operations using [func@call] and friends to perform the load or
save.

[method@Image.write_to_file] and [ctor@Image.new_from_file] and friends use
these functions to automate file load and save.

You can also invoke the operations directly, for example:

```c
vips_tiffsave(my_image, "frank.anything",
    "compression", VIPS_FOREIGN_TIFF_COMPRESSION_JPEG,
    NULL);
```

## Image metadata

All loaders attach all image metadata as libvips properties on load.

You can change metadata with [method@Image.set_int] and friends.

During save, you can use `keep` to specify which metadata to retain,
defaults to all, see [flags@ForeignKeep]. Setting `profile` will
automatically keep the ICC profile.

## Many page images

By default, libvips will only load the first page of many page or animated
images. Use `page` and `n` to set the start page and the number of pages to
load. Set `n` to -1 to load all pages.

Many page images are loaded as a tall, thin strip of pages.

Use [method@Image.get_page_height] and [method@Image.get_n_pages] to find
the page height and number of pages of a loaded image.

Use `page_height` to set the page height for image save.

## Alpha save

Not all image formats support alpha. If you try to save an image with an
alpha channel to a format that does not support it, the alpha will be
automatically flattened out. Use `background` (default 0) to set the colour
that alpha should be flattened against.

## Adding new formats

To add support for a new file format to vips, simply define a new subclass
of [class@ForeignLoad] or [class@ForeignSave].

If you define a new operation which is a subclass of [class@Foreign],
support for it automatically appears in all libvips user-interfaces. It
will also be transparently supported by [ctor@Image.new_from_file] and
friends.</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="83"/>
      <function name="find_load" c:identifier="vips_foreign_find_load">
        <doc xml:space="preserve"
             filename="libvips/foreign/foreign.c"
             line="593">Searches for an operation you could use to load @filename. Any trailing
options on @filename are stripped and ignored.

::: seealso
    [func@Foreign.find_load_buffer], [ctor@Image.new_from_file].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="275"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="603">the name of an operation on success, `NULL` on error</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/foreign.c"
                 line="595">file to find a loader for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="find_load_buffer"
                c:identifier="vips_foreign_find_load_buffer">
        <doc xml:space="preserve"
             filename="libvips/foreign/foreign.c"
             line="693">Searches for an operation you could use to load a memory buffer. To see the
range of buffer loaders supported by your vips, try something like:

	vips -l | grep load_buffer

::: seealso
    [ctor@Image.new_from_buffer].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="277"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="707">the name of an operation on success, `NULL` on
error.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/foreign.c"
                 line="695">start of
memory buffer</doc>
            <array length="1" zero-terminated="0" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/foreign.c"
                 line="697">number of bytes in @data</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
        </parameters>
      </function>
      <function name="find_load_source"
                c:identifier="vips_foreign_find_load_source">
        <doc xml:space="preserve"
             filename="libvips/foreign/foreign.c"
             line="757">Searches for an operation you could use to load a source. To see the
range of source loaders supported by your vips, try something like:

	vips -l | grep load_source

::: seealso
    [ctor@Image.new_from_source].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="279"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="769">the name of an operation on success, `NULL` on
error.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/foreign.c"
                 line="759">source to load from</doc>
            <type name="Source" c:type="VipsSource*"/>
          </parameter>
        </parameters>
      </function>
      <function name="find_save" c:identifier="vips_foreign_find_save">
        <doc xml:space="preserve"
             filename="libvips/foreign/foreign.c"
             line="1972">Searches for an operation you could use to write to @filename.
Any trailing options on @filename are stripped and ignored.

::: seealso
    [func@Foreign.find_save_buffer], [method@Image.write_to_file].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="461"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="1982">the name of an operation on success, `NULL` on error</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/foreign.c"
                 line="1974">name to find a saver for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="find_save_buffer"
                c:identifier="vips_foreign_find_save_buffer">
        <doc xml:space="preserve"
             filename="libvips/foreign/foreign.c"
             line="2187">Searches for an operation you could use to write to a buffer in @suffix
format.

::: seealso
    [method@Image.write_to_buffer].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="465"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2197">the name of an operation on success, `NULL` on error</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <parameter name="suffix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/foreign.c"
                 line="2189">name to find a saver for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="find_save_target"
                c:identifier="vips_foreign_find_save_target">
        <doc xml:space="preserve"
             filename="libvips/foreign/foreign.c"
             line="2128">Searches for an operation you could use to write to a target in @suffix
format.

::: seealso
    [method@Image.write_to_buffer].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="467"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2138">the name of an operation on success, `NULL` on error</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <parameter name="suffix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/foreign.c"
                 line="2130">format to find a saver for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_suffixes" c:identifier="vips_foreign_get_suffixes">
        <doc xml:space="preserve"
             filename="libvips/foreign/foreign.c"
             line="2040">Get a `NULL`-terminated array listing all the supported suffixes.

This is not the same as all the supported file types, since libvips
detects image format for load by testing the first few bytes.

Use [func@Foreign.find_load] to detect type for a specific file.

Free the return result with [func@GLib.strfreev].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="463"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2052">all supported file extensions, as a
`NULL`-terminated array.</doc>
          <array zero-terminated="0" c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </function>
      <function name="is_a" c:identifier="vips_foreign_is_a">
        <doc xml:space="preserve"
             filename="libvips/foreign/foreign.c"
             line="789">Return `TRUE` if @filename can be loaded by @loader. @loader is something
like "tiffload" or "VipsForeignLoadTiff".</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="284"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="797">`TRUE` if @filename can be loaded by @loader.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="loader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/foreign.c"
                 line="791">name of loader to use for test</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/foreign.c"
                 line="792">file to test</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="is_a_buffer" c:identifier="vips_foreign_is_a_buffer">
        <doc xml:space="preserve"
             filename="libvips/foreign/foreign.c"
             line="815">Return `TRUE` if @data can be loaded by @loader. @loader is something
like "tiffload_buffer" or "VipsForeignLoadTiffBuffer".</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="286"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="824">`TRUE` if @data can be loaded by @loader.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="loader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/foreign.c"
                 line="817">name of loader to use for test</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/foreign.c"
                 line="818">pointer to the buffer to test</doc>
            <array length="2" zero-terminated="0" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/foreign.c"
                 line="819">size of the buffer to test</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
        </parameters>
      </function>
      <function name="is_a_source" c:identifier="vips_foreign_is_a_source">
        <doc xml:space="preserve"
             filename="libvips/foreign/foreign.c"
             line="842">Return `TRUE` if @source can be loaded by @loader. @loader is something
like "tiffload_source" or "VipsForeignLoadTiffSource".</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="289"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="850">`TRUE` if @data can be loaded by @source.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="loader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/foreign.c"
                 line="844">name of loader to use for test</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/foreign.c"
                 line="845">source to test</doc>
            <type name="Source" c:type="VipsSource*"/>
          </parameter>
        </parameters>
      </function>
      <function name="map" c:identifier="vips_foreign_map">
        <doc xml:space="preserve"
             filename="libvips/foreign/foreign.c"
             line="457">Apply a function to every [class@Foreign] that VIPS knows about. Foreigns
are presented to the function in priority order.

Like all VIPS map functions, if @fn returns `NULL`, iteration continues. If
it returns non-`NULL`, iteration terminates and that value is returned. The
map function returns `NULL` if all calls return `NULL`.

::: seealso
    [func@slist_map2].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="92"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="474">the result of iteration</doc>
          <type name="gpointer" c:type="void*"/>
        </return-value>
        <parameters>
          <parameter name="base" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/foreign.c"
                 line="459">base class to search below (eg. "VipsForeignLoad")</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="fn" transfer-ownership="none" scope="call">
            <doc xml:space="preserve"
                 filename="libvips/foreign/foreign.c"
                 line="460">function to apply to each [class@Foreign]</doc>
            <type name="SListMap2Fn" c:type="VipsSListMap2Fn"/>
          </parameter>
          <parameter name="a"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/foreign/foreign.c"
                 line="461">user data</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="b"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/foreign/foreign.c"
                 line="462">user data</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </function>
      <field name="parent_object">
        <type name="Operation" c:type="VipsOperation"/>
      </field>
    </class>
    <record name="ForeignClass"
            c:type="VipsForeignClass"
            glib:is-gtype-struct-for="Foreign">
      <source-position filename="libvips/include/vips/foreign.h" line="83"/>
      <field name="parent_class">
        <type name="OperationClass" c:type="VipsOperationClass"/>
      </field>
      <field name="priority">
        <type name="gint" c:type="int"/>
      </field>
      <field name="suffs">
        <type name="utf8" c:type="const char**"/>
      </field>
    </record>
    <bitfield name="ForeignCoding"
              glib:type-name="VipsForeignCoding"
              glib:get-type="vips_foreign_coding_get_type"
              c:type="VipsForeignCoding">
      <doc xml:space="preserve"
           filename="libvips/include/vips/foreign.h"
           line="336">The set of coding types supported by a saver.

::: seealso
    [enum@Coding].</doc>
      <member name="none"
              value="1"
              c:identifier="VIPS_FOREIGN_CODING_NONE"
              glib:nick="none"
              glib:name="VIPS_FOREIGN_CODING_NONE">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="338">saver supports [enum@Vips.Coding.NONE]</doc>
      </member>
      <member name="labq"
              value="2"
              c:identifier="VIPS_FOREIGN_CODING_LABQ"
              glib:nick="labq"
              glib:name="VIPS_FOREIGN_CODING_LABQ">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="339">saver supports [enum@Vips.Coding.LABQ]</doc>
      </member>
      <member name="rad"
              value="4"
              c:identifier="VIPS_FOREIGN_CODING_RAD"
              glib:nick="rad"
              glib:name="VIPS_FOREIGN_CODING_RAD">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="340">saver supports [enum@Vips.Coding.RAD]</doc>
      </member>
      <member name="all"
              value="7"
              c:identifier="VIPS_FOREIGN_CODING_ALL"
              glib:nick="all"
              glib:name="VIPS_FOREIGN_CODING_ALL">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="341">saver supports all coding types</doc>
      </member>
    </bitfield>
    <enumeration name="ForeignDzContainer"
                 glib:type-name="VipsForeignDzContainer"
                 glib:get-type="vips_foreign_dz_container_get_type"
                 c:type="VipsForeignDzContainer">
      <doc xml:space="preserve"
           filename="libvips/include/vips/foreign.h"
           line="1038">What container format to use.</doc>
      <member name="fs"
              value="0"
              c:identifier="VIPS_FOREIGN_DZ_CONTAINER_FS"
              glib:nick="fs"
              glib:name="VIPS_FOREIGN_DZ_CONTAINER_FS">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="1040">write tiles to the filesystem</doc>
      </member>
      <member name="zip"
              value="1"
              c:identifier="VIPS_FOREIGN_DZ_CONTAINER_ZIP"
              glib:nick="zip"
              glib:name="VIPS_FOREIGN_DZ_CONTAINER_ZIP">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="1041">write tiles to a zip file</doc>
      </member>
      <member name="szi"
              value="2"
              c:identifier="VIPS_FOREIGN_DZ_CONTAINER_SZI"
              glib:nick="szi"
              glib:name="VIPS_FOREIGN_DZ_CONTAINER_SZI">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="1042">write to a szi file</doc>
      </member>
    </enumeration>
    <enumeration name="ForeignDzDepth"
                 glib:type-name="VipsForeignDzDepth"
                 glib:get-type="vips_foreign_dz_depth_get_type"
                 c:type="VipsForeignDzDepth">
      <doc xml:space="preserve"
           filename="libvips/include/vips/foreign.h"
           line="1023">How many pyramid layers to create.</doc>
      <member name="onepixel"
              value="0"
              c:identifier="VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL"
              glib:nick="onepixel"
              glib:name="VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="1025">create layers down to 1x1 pixel</doc>
      </member>
      <member name="onetile"
              value="1"
              c:identifier="VIPS_FOREIGN_DZ_DEPTH_ONETILE"
              glib:nick="onetile"
              glib:name="VIPS_FOREIGN_DZ_DEPTH_ONETILE">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="1026">create layers down to 1x1 tile</doc>
      </member>
      <member name="one"
              value="2"
              c:identifier="VIPS_FOREIGN_DZ_DEPTH_ONE"
              glib:nick="one"
              glib:name="VIPS_FOREIGN_DZ_DEPTH_ONE">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="1027">only create a single layer</doc>
      </member>
    </enumeration>
    <enumeration name="ForeignDzLayout"
                 glib:type-name="VipsForeignDzLayout"
                 glib:get-type="vips_foreign_dz_layout_get_type"
                 c:type="VipsForeignDzLayout">
      <doc xml:space="preserve"
           filename="libvips/include/vips/foreign.h"
           line="1004">What directory layout and metadata standard to use.</doc>
      <member name="dz"
              value="0"
              c:identifier="VIPS_FOREIGN_DZ_LAYOUT_DZ"
              glib:nick="dz"
              glib:name="VIPS_FOREIGN_DZ_LAYOUT_DZ">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="1006">use DeepZoom directory layout</doc>
      </member>
      <member name="zoomify"
              value="1"
              c:identifier="VIPS_FOREIGN_DZ_LAYOUT_ZOOMIFY"
              glib:nick="zoomify"
              glib:name="VIPS_FOREIGN_DZ_LAYOUT_ZOOMIFY">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="1007">use Zoomify directory layout</doc>
      </member>
      <member name="google"
              value="2"
              c:identifier="VIPS_FOREIGN_DZ_LAYOUT_GOOGLE"
              glib:nick="google"
              glib:name="VIPS_FOREIGN_DZ_LAYOUT_GOOGLE">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="1008">use Google maps directory layout</doc>
      </member>
      <member name="iiif"
              value="3"
              c:identifier="VIPS_FOREIGN_DZ_LAYOUT_IIIF"
              glib:nick="iiif"
              glib:name="VIPS_FOREIGN_DZ_LAYOUT_IIIF">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="1009">use IIIF v2 directory layout</doc>
      </member>
      <member name="iiif3"
              value="4"
              c:identifier="VIPS_FOREIGN_DZ_LAYOUT_IIIF3"
              glib:nick="iiif3"
              glib:name="VIPS_FOREIGN_DZ_LAYOUT_IIIF3">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="1010">use IIIF v3 directory layout</doc>
      </member>
    </enumeration>
    <bitfield name="ForeignFlags"
              glib:type-name="VipsForeignFlags"
              glib:get-type="vips_foreign_flags_get_type"
              c:type="VipsForeignFlags">
      <doc xml:space="preserve"
           filename="libvips/foreign/foreign.c"
           line="351">Some hints about the image loader.

[flags@Vips.ForeignFlags.PARTIAL] means that the image can be read directly
from the file without needing to be unpacked to a temporary image first.

[flags@Vips.ForeignFlags.SEQUENTIAL] means that the loader supports lazy
reading, but only top-to-bottom (sequential) access. Formats like PNG can
read sets of scanlines, for example, but only in order.

If neither PARTIAL or SEQUENTIAL is set, the loader only supports whole
image read. Setting both PARTIAL and SEQUENTIAL is an error.

[flags@Vips.ForeignFlags.BIGENDIAN] means that image pixels are
most-significant byte first. Depending on the native byte order of the
host machine, you may need to swap bytes. See [method@Image.copy].</doc>
      <member name="none"
              value="0"
              c:identifier="VIPS_FOREIGN_NONE"
              glib:nick="none"
              glib:name="VIPS_FOREIGN_NONE">
        <doc xml:space="preserve"
             filename="libvips/foreign/foreign.c"
             line="353">no flags set</doc>
      </member>
      <member name="partial"
              value="1"
              c:identifier="VIPS_FOREIGN_PARTIAL"
              glib:nick="partial"
              glib:name="VIPS_FOREIGN_PARTIAL">
        <doc xml:space="preserve"
             filename="libvips/foreign/foreign.c"
             line="354">the image may be read lazilly</doc>
      </member>
      <member name="bigendian"
              value="2"
              c:identifier="VIPS_FOREIGN_BIGENDIAN"
              glib:nick="bigendian"
              glib:name="VIPS_FOREIGN_BIGENDIAN">
        <doc xml:space="preserve"
             filename="libvips/foreign/foreign.c"
             line="355">image pixels are most-significant byte first</doc>
      </member>
      <member name="sequential"
              value="4"
              c:identifier="VIPS_FOREIGN_SEQUENTIAL"
              glib:nick="sequential"
              glib:name="VIPS_FOREIGN_SEQUENTIAL">
        <doc xml:space="preserve"
             filename="libvips/foreign/foreign.c"
             line="356">top-to-bottom lazy reading</doc>
      </member>
      <member name="all"
              value="7"
              c:identifier="VIPS_FOREIGN_ALL"
              glib:nick="all"
              glib:name="VIPS_FOREIGN_ALL">
      </member>
    </bitfield>
    <enumeration name="ForeignHeifCompression"
                 glib:type-name="VipsForeignHeifCompression"
                 glib:get-type="vips_foreign_heif_compression_get_type"
                 c:type="VipsForeignHeifCompression">
      <doc xml:space="preserve"
           filename="libvips/include/vips/foreign.h"
           line="1063">The compression format to use inside a HEIF container.

This is assumed to use the same numbering as `heif_compression_format`.</doc>
      <member name="hevc"
              value="1"
              c:identifier="VIPS_FOREIGN_HEIF_COMPRESSION_HEVC"
              glib:nick="hevc"
              glib:name="VIPS_FOREIGN_HEIF_COMPRESSION_HEVC">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="1065">x265</doc>
      </member>
      <member name="avc"
              value="2"
              c:identifier="VIPS_FOREIGN_HEIF_COMPRESSION_AVC"
              glib:nick="avc"
              glib:name="VIPS_FOREIGN_HEIF_COMPRESSION_AVC">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="1066">x264</doc>
      </member>
      <member name="jpeg"
              value="3"
              c:identifier="VIPS_FOREIGN_HEIF_COMPRESSION_JPEG"
              glib:nick="jpeg"
              glib:name="VIPS_FOREIGN_HEIF_COMPRESSION_JPEG">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="1067">jpeg</doc>
      </member>
      <member name="av1"
              value="4"
              c:identifier="VIPS_FOREIGN_HEIF_COMPRESSION_AV1"
              glib:nick="av1"
              glib:name="VIPS_FOREIGN_HEIF_COMPRESSION_AV1">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="1068">aom</doc>
      </member>
    </enumeration>
    <enumeration name="ForeignHeifEncoder"
                 glib:type-name="VipsForeignHeifEncoder"
                 glib:get-type="vips_foreign_heif_encoder_get_type"
                 c:type="VipsForeignHeifEncoder">
      <doc xml:space="preserve"
           filename="libvips/include/vips/foreign.h"
           line="1082">The selected encoder to use.
If libheif hasn't been compiled with the selected encoder,
we will fallback to the default encoder for the compression format.</doc>
      <member name="auto"
              value="0"
              c:identifier="VIPS_FOREIGN_HEIF_ENCODER_AUTO"
              glib:nick="auto"
              glib:name="VIPS_FOREIGN_HEIF_ENCODER_AUTO">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="1084">auto</doc>
      </member>
      <member name="aom"
              value="1"
              c:identifier="VIPS_FOREIGN_HEIF_ENCODER_AOM"
              glib:nick="aom"
              glib:name="VIPS_FOREIGN_HEIF_ENCODER_AOM">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="1085">aom</doc>
      </member>
      <member name="rav1e"
              value="2"
              c:identifier="VIPS_FOREIGN_HEIF_ENCODER_RAV1E"
              glib:nick="rav1e"
              glib:name="VIPS_FOREIGN_HEIF_ENCODER_RAV1E">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="1086">RAV1E</doc>
      </member>
      <member name="svt"
              value="3"
              c:identifier="VIPS_FOREIGN_HEIF_ENCODER_SVT"
              glib:nick="svt"
              glib:name="VIPS_FOREIGN_HEIF_ENCODER_SVT">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="1087">SVT-AV1</doc>
      </member>
      <member name="x265"
              value="4"
              c:identifier="VIPS_FOREIGN_HEIF_ENCODER_X265"
              glib:nick="x265"
              glib:name="VIPS_FOREIGN_HEIF_ENCODER_X265">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="1088">x265</doc>
      </member>
    </enumeration>
    <enumeration name="ForeignJpegSubsample"
                 glib:type-name="VipsForeignJpegSubsample"
                 glib:get-type="vips_foreign_jpeg_subsample_get_type"
                 c:type="VipsForeignJpegSubsample">
      <member name="auto"
              value="0"
              c:identifier="VIPS_FOREIGN_JPEG_SUBSAMPLE_AUTO"
              glib:nick="auto"
              glib:name="VIPS_FOREIGN_JPEG_SUBSAMPLE_AUTO">
      </member>
      <member name="on"
              value="1"
              c:identifier="VIPS_FOREIGN_JPEG_SUBSAMPLE_ON"
              glib:nick="on"
              glib:name="VIPS_FOREIGN_JPEG_SUBSAMPLE_ON">
      </member>
      <member name="off"
              value="2"
              c:identifier="VIPS_FOREIGN_JPEG_SUBSAMPLE_OFF"
              glib:nick="off"
              glib:name="VIPS_FOREIGN_JPEG_SUBSAMPLE_OFF">
      </member>
    </enumeration>
    <bitfield name="ForeignKeep"
              glib:type-name="VipsForeignKeep"
              glib:get-type="vips_foreign_keep_get_type"
              c:type="VipsForeignKeep">
      <doc xml:space="preserve"
           filename="libvips/include/vips/foreign.h"
           line="358">Which metadata to retain.</doc>
      <member name="none"
              value="0"
              c:identifier="VIPS_FOREIGN_KEEP_NONE"
              glib:nick="none"
              glib:name="VIPS_FOREIGN_KEEP_NONE">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="360">don't attach metadata</doc>
      </member>
      <member name="exif"
              value="1"
              c:identifier="VIPS_FOREIGN_KEEP_EXIF"
              glib:nick="exif"
              glib:name="VIPS_FOREIGN_KEEP_EXIF">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="361">keep Exif metadata</doc>
      </member>
      <member name="xmp"
              value="2"
              c:identifier="VIPS_FOREIGN_KEEP_XMP"
              glib:nick="xmp"
              glib:name="VIPS_FOREIGN_KEEP_XMP">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="362">keep XMP metadata</doc>
      </member>
      <member name="iptc"
              value="4"
              c:identifier="VIPS_FOREIGN_KEEP_IPTC"
              glib:nick="iptc"
              glib:name="VIPS_FOREIGN_KEEP_IPTC">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="363">keep IPTC metadata</doc>
      </member>
      <member name="icc"
              value="8"
              c:identifier="VIPS_FOREIGN_KEEP_ICC"
              glib:nick="icc"
              glib:name="VIPS_FOREIGN_KEEP_ICC">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="364">keep ICC metadata</doc>
      </member>
      <member name="other"
              value="16"
              c:identifier="VIPS_FOREIGN_KEEP_OTHER"
              glib:nick="other"
              glib:name="VIPS_FOREIGN_KEEP_OTHER">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="365">keep other metadata (e.g. PNG comments)</doc>
      </member>
      <member name="gainmap"
              value="32"
              c:identifier="VIPS_FOREIGN_KEEP_GAINMAP"
              glib:nick="gainmap"
              glib:name="VIPS_FOREIGN_KEEP_GAINMAP">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="366">keep the gainmap metadata</doc>
      </member>
      <member name="all"
              value="63"
              c:identifier="VIPS_FOREIGN_KEEP_ALL"
              glib:nick="all"
              glib:name="VIPS_FOREIGN_KEEP_ALL">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="367">keep all metadata</doc>
      </member>
    </bitfield>
    <class name="ForeignLoad"
           c:symbol-prefix="foreign_load"
           c:type="VipsForeignLoad"
           parent="Foreign"
           abstract="1"
           glib:type-name="VipsForeignLoad"
           glib:get-type="vips_foreign_load_get_type"
           glib:type-struct="ForeignLoadClass">
      <doc xml:space="preserve"
           filename="libvips/foreign/foreign.c"
           line="145">An abstract base class to load images in a variety of formats.

## Writing a new loader

Add a new loader to libvips by subclassing [class@ForeignLoad]. Subclasses
need to implement at least [vfunc@ForeignLoad.header].

[vfunc@ForeignLoad.header] must set at least the header fields of `out`.
[vfunc@ForeignLoad.load], if defined, must load the pixels to `real`.

The suffix list is used to select a format to save a file in, and to pick a
loader if you don't define [func@Foreign.is_a].

You should also define [property@Object:nickname] and
[property@Object:description] in [class@Object].

As a complete example, here's code for a PNG loader, minus the actual
calls to libpng.

```c
typedef struct _VipsForeignLoadPng {
    VipsForeignLoad parent_object;

    char *filename;
} VipsForeignLoadPng;

typedef VipsForeignLoadClass VipsForeignLoadPngClass;

G_DEFINE_TYPE(VipsForeignLoadPng, vips_foreign_load_png,
    VIPS_TYPE_FOREIGN_LOAD);

static VipsForeignFlags
vips_foreign_load_png_get_flags_filename(const char *filename)
{
    VipsForeignFlags flags;

    flags = 0;
    if (vips__png_isinterlaced(filename))
         flags = VIPS_FOREIGN_PARTIAL;
    else
         flags = VIPS_FOREIGN_SEQUENTIAL;

    return flags;
}

static VipsForeignFlags
vips_foreign_load_png_get_flags(VipsForeignLoad *load)
{
  VipsForeignLoadPng *png = (VipsForeignLoadPng *) load;

  return vips_foreign_load_png_get_flags_filename(png-&gt;filename);
}

static int
vips_foreign_load_png_header(VipsForeignLoad *load)
{
    VipsForeignLoadPng *png = (VipsForeignLoadPng *) load;

    if (vips__png_header(png-&gt;filename, load-&gt;out))
        return -1;

    return 0;
}

static int
vips_foreign_load_png_load(VipsForeignLoad *load)
{
    VipsForeignLoadPng *png = (VipsForeignLoadPng *) load;

    if (vips__png_read(png-&gt;filename, load-&gt;real))
        return -1;

    return 0;
}

static void
vips_foreign_load_png_class_init(VipsForeignLoadPngClass *class)
{
    GObjectClass *gobject_class = G_OBJECT_CLASS(class);
    VipsObjectClass *object_class = (VipsObjectClass *) class;
    VipsForeignClass *foreign_class = (VipsForeignClass *) class;
    VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;

    gobject_class-&gt;set_property = vips_object_set_property;
    gobject_class-&gt;get_property = vips_object_get_property;

    object_class-&gt;nickname = "pngload";
    object_class-&gt;description = _("load png from file");

    foreign_class-&gt;suffs = vips__png_suffs;

    load_class-&gt;is_a = vips__png_ispng;
    load_class-&gt;get_flags_filename =
        vips_foreign_load_png_get_flags_filename;
    load_class-&gt;get_flags = vips_foreign_load_png_get_flags;
    load_class-&gt;header = vips_foreign_load_png_header;
    load_class-&gt;load = vips_foreign_load_png_load;

    VIPS_ARG_STRING(class, "filename", 1,
        _("Filename"),
        _("Filename to load from"),
        VIPS_ARGUMENT_REQUIRED_INPUT,
        G_STRUCT_OFFSET(VipsForeignLoadPng, filename),
        NULL);
}

static void
vips_foreign_load_png_init(VipsForeignLoadPng *png)
{
}
```</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="269"/>
      <virtual-method name="get_flags">
        <source-position filename="libvips/include/vips/foreign.h" line="243"/>
        <return-value transfer-ownership="none">
          <type name="ForeignFlags" c:type="VipsForeignFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="load" transfer-ownership="none">
            <type name="ForeignLoad" c:type="VipsForeignLoad*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="header">
        <source-position filename="libvips/include/vips/foreign.h" line="257"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="load" transfer-ownership="none">
            <type name="ForeignLoad" c:type="VipsForeignLoad*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="load">
        <source-position filename="libvips/include/vips/foreign.h" line="268"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="load" transfer-ownership="none">
            <type name="ForeignLoad" c:type="VipsForeignLoad*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <property name="access"
                writable="1"
                transfer-ownership="none"
                default-value="VIPS_ACCESS_RANDOM">
        <type name="Access"/>
      </property>
      <property name="disc"
                writable="1"
                transfer-ownership="none"
                default-value="TRUE">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="fail"
                writable="1"
                transfer-ownership="none"
                default-value="FALSE">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="fail-on"
                writable="1"
                transfer-ownership="none"
                default-value="VIPS_FAIL_ON_NONE">
        <type name="FailOn"/>
      </property>
      <property name="flags"
                writable="1"
                transfer-ownership="none"
                default-value="VIPS_FOREIGN_NONE">
        <type name="ForeignFlags"/>
      </property>
      <property name="memory"
                writable="1"
                transfer-ownership="none"
                default-value="FALSE">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="out" writable="1" transfer-ownership="none">
        <type name="Image"/>
      </property>
      <property name="revalidate"
                writable="1"
                transfer-ownership="none"
                default-value="FALSE">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="sequential"
                writable="1"
                transfer-ownership="none"
                default-value="FALSE">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent_object">
        <type name="Foreign" c:type="VipsForeign"/>
      </field>
      <field name="memory" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="access" readable="0" private="1">
        <type name="Access" c:type="VipsAccess"/>
      </field>
      <field name="flags" readable="0" private="1">
        <type name="ForeignFlags" c:type="VipsForeignFlags"/>
      </field>
      <field name="fail_on" readable="0" private="1">
        <type name="FailOn" c:type="VipsFailOn"/>
      </field>
      <field name="fail" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="sequential" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="out">
        <type name="Image" c:type="VipsImage*"/>
      </field>
      <field name="real">
        <type name="Image" c:type="VipsImage*"/>
      </field>
      <field name="nocache">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="disc">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="error">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="revalidate">
        <type name="gboolean" c:type="gboolean"/>
      </field>
    </class>
    <record name="ForeignLoadClass"
            c:type="VipsForeignLoadClass"
            glib:is-gtype-struct-for="ForeignLoad">
      <source-position filename="libvips/include/vips/foreign.h" line="269"/>
      <field name="parent_class">
        <type name="ForeignClass" c:type="VipsForeignClass"/>
      </field>
      <field name="is_a">
        <callback name="is_a">
          <source-position filename="libvips/include/vips/foreign.h"
                           line="212"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="filename" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="is_a_buffer">
        <callback name="is_a_buffer">
          <source-position filename="libvips/include/vips/foreign.h"
                           line="219"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="data" transfer-ownership="none">
              <type name="gpointer" c:type="void*"/>
            </parameter>
            <parameter name="size" transfer-ownership="none">
              <type name="gsize" c:type="size_t"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="is_a_source">
        <callback name="is_a_source">
          <source-position filename="libvips/include/vips/foreign.h"
                           line="226"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="source" transfer-ownership="none">
              <type name="Source" c:type="VipsSource*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_flags_filename">
        <callback name="get_flags_filename">
          <source-position filename="libvips/include/vips/foreign.h"
                           line="237"/>
          <return-value transfer-ownership="none">
            <type name="ForeignFlags" c:type="VipsForeignFlags"/>
          </return-value>
          <parameters>
            <parameter name="filename" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_flags">
        <callback name="get_flags">
          <source-position filename="libvips/include/vips/foreign.h"
                           line="243"/>
          <return-value transfer-ownership="none">
            <type name="ForeignFlags" c:type="VipsForeignFlags"/>
          </return-value>
          <parameters>
            <parameter name="load" transfer-ownership="none">
              <type name="ForeignLoad" c:type="VipsForeignLoad*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="header">
        <callback name="header">
          <source-position filename="libvips/include/vips/foreign.h"
                           line="257"/>
          <return-value transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </return-value>
          <parameters>
            <parameter name="load" transfer-ownership="none">
              <type name="ForeignLoad" c:type="VipsForeignLoad*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="load">
        <callback name="load">
          <source-position filename="libvips/include/vips/foreign.h"
                           line="268"/>
          <return-value transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </return-value>
          <parameters>
            <parameter name="load" transfer-ownership="none">
              <type name="ForeignLoad" c:type="VipsForeignLoad*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <enumeration name="ForeignPdfPageBox"
                 glib:type-name="VipsForeignPdfPageBox"
                 glib:get-type="vips_foreign_pdf_page_box_get_type"
                 c:type="VipsForeignPdfPageBox">
      <doc xml:space="preserve"
           filename="libvips/include/vips/foreign.h"
           line="841">Each page of a PDF document can contain multiple page boxes,
also known as boundary boxes or print marks.

Each page box defines a region of the complete page that
should be rendered. The default region is the crop box.</doc>
      <member name="media"
              value="0"
              c:identifier="VIPS_FOREIGN_PDF_PAGE_BOX_MEDIA"
              glib:nick="media"
              glib:name="VIPS_FOREIGN_PDF_PAGE_BOX_MEDIA">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="843">media box</doc>
      </member>
      <member name="crop"
              value="1"
              c:identifier="VIPS_FOREIGN_PDF_PAGE_BOX_CROP"
              glib:nick="crop"
              glib:name="VIPS_FOREIGN_PDF_PAGE_BOX_CROP">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="844">crop box</doc>
      </member>
      <member name="trim"
              value="2"
              c:identifier="VIPS_FOREIGN_PDF_PAGE_BOX_TRIM"
              glib:nick="trim"
              glib:name="VIPS_FOREIGN_PDF_PAGE_BOX_TRIM">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="845">trim box</doc>
      </member>
      <member name="bleed"
              value="3"
              c:identifier="VIPS_FOREIGN_PDF_PAGE_BOX_BLEED"
              glib:nick="bleed"
              glib:name="VIPS_FOREIGN_PDF_PAGE_BOX_BLEED">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="846">bleed box</doc>
      </member>
      <member name="art"
              value="4"
              c:identifier="VIPS_FOREIGN_PDF_PAGE_BOX_ART"
              glib:nick="art"
              glib:name="VIPS_FOREIGN_PDF_PAGE_BOX_ART">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="847">art box</doc>
      </member>
    </enumeration>
    <bitfield name="ForeignPngFilter"
              glib:type-name="VipsForeignPngFilter"
              glib:get-type="vips_foreign_png_filter_get_type"
              c:type="VipsForeignPngFilter">
      <doc xml:space="preserve"
           filename="libvips/include/vips/foreign.h"
           line="731">http://www.w3.org/TR/PNG-Filters.html
The values mirror those of png.h in libpng.</doc>
      <member name="none"
              value="8"
              c:identifier="VIPS_FOREIGN_PNG_FILTER_NONE"
              glib:nick="none"
              glib:name="VIPS_FOREIGN_PNG_FILTER_NONE">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="733">no filtering</doc>
      </member>
      <member name="sub"
              value="16"
              c:identifier="VIPS_FOREIGN_PNG_FILTER_SUB"
              glib:nick="sub"
              glib:name="VIPS_FOREIGN_PNG_FILTER_SUB">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="734">difference to the left</doc>
      </member>
      <member name="up"
              value="32"
              c:identifier="VIPS_FOREIGN_PNG_FILTER_UP"
              glib:nick="up"
              glib:name="VIPS_FOREIGN_PNG_FILTER_UP">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="735">difference up</doc>
      </member>
      <member name="avg"
              value="64"
              c:identifier="VIPS_FOREIGN_PNG_FILTER_AVG"
              glib:nick="avg"
              glib:name="VIPS_FOREIGN_PNG_FILTER_AVG">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="736">average of left and up</doc>
      </member>
      <member name="paeth"
              value="128"
              c:identifier="VIPS_FOREIGN_PNG_FILTER_PAETH"
              glib:nick="paeth"
              glib:name="VIPS_FOREIGN_PNG_FILTER_PAETH">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="737">pick best neighbor predictor automatically</doc>
      </member>
      <member name="all"
              value="248"
              c:identifier="VIPS_FOREIGN_PNG_FILTER_ALL"
              glib:nick="all"
              glib:name="VIPS_FOREIGN_PNG_FILTER_ALL">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="738">adaptive</doc>
      </member>
    </bitfield>
    <enumeration name="ForeignPpmFormat"
                 glib:type-name="VipsForeignPpmFormat"
                 glib:get-type="vips_foreign_ppm_format_get_type"
                 c:type="VipsForeignPpmFormat">
      <doc xml:space="preserve"
           filename="libvips/include/vips/foreign.h"
           line="771">The netpbm file format to save as.

[enum@Vips.ForeignPpmFormat.PBM] images are single bit.

[enum@Vips.ForeignPpmFormat.PGM] images are 8, 16, or 32-bits, one band.

[enum@Vips.ForeignPpmFormat.PPM] images are 8, 16, or 32-bits, three bands.

[enum@Vips.ForeignPpmFormat.PFM] images are 32-bit float pixels.

[enum@Vips.ForeignPpmFormat.PNM] images are anymap images -- the image format
is used to pick the saver.</doc>
      <member name="pbm"
              value="0"
              c:identifier="VIPS_FOREIGN_PPM_FORMAT_PBM"
              glib:nick="pbm"
              glib:name="VIPS_FOREIGN_PPM_FORMAT_PBM">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="773">portable bitmap</doc>
      </member>
      <member name="pgm"
              value="1"
              c:identifier="VIPS_FOREIGN_PPM_FORMAT_PGM"
              glib:nick="pgm"
              glib:name="VIPS_FOREIGN_PPM_FORMAT_PGM">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="774">portable greymap</doc>
      </member>
      <member name="ppm"
              value="2"
              c:identifier="VIPS_FOREIGN_PPM_FORMAT_PPM"
              glib:nick="ppm"
              glib:name="VIPS_FOREIGN_PPM_FORMAT_PPM">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="775">portable pixmap</doc>
      </member>
      <member name="pfm"
              value="3"
              c:identifier="VIPS_FOREIGN_PPM_FORMAT_PFM"
              glib:nick="pfm"
              glib:name="VIPS_FOREIGN_PPM_FORMAT_PFM">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="776">portable float map</doc>
      </member>
      <member name="pnm"
              value="4"
              c:identifier="VIPS_FOREIGN_PPM_FORMAT_PNM"
              glib:nick="pnm"
              glib:name="VIPS_FOREIGN_PPM_FORMAT_PNM">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="777">portable anymap</doc>
      </member>
    </enumeration>
    <class name="ForeignSave"
           c:symbol-prefix="foreign_save"
           c:type="VipsForeignSave"
           parent="Foreign"
           abstract="1"
           glib:type-name="VipsForeignSave"
           glib:get-type="vips_foreign_save_get_type"
           glib:type-struct="ForeignSaveClass">
      <doc xml:space="preserve"
           filename="libvips/foreign/foreign.c"
           line="261">An abstract base class to save images in a variety of formats.

## Writing a new saver

Call your saver in the class' [vfunc@Object.build] method after chaining up.
The prepared image should be ready for you to save in `ready`.

As a complete example, here's the code for the CSV saver, minus the calls
to the actual save routines.

```c
typedef struct _VipsForeignSaveCsv {
    VipsForeignSave parent_object;

    char *filename;
    const char *separator;
} VipsForeignSaveCsv;

typedef VipsForeignSaveClass VipsForeignSaveCsvClass;

G_DEFINE_TYPE(VipsForeignSaveCsv, vips_foreign_save_csv,
  VIPS_TYPE_FOREIGN_SAVE);

static int
vips_foreign_save_csv_build(VipsObject *object)
{
    VipsForeignSave *save = (VipsForeignSave *) object;
    VipsForeignSaveCsv *csv = (VipsForeignSaveCsv *) object;

    if (VIPS_OBJECT_CLASS(vips_foreign_save_csv_parent_class)
            -&gt;build(object))
        return -1;

    if (vips__csv_write(save-&gt;ready, csv-&gt;filename, csv-&gt;separator))
  	  return -1;

    return 0;
}

static void
vips_foreign_save_csv_class_init(VipsForeignSaveCsvClass *class)
{
    GObjectClass *gobject_class = G_OBJECT_CLASS(class);
    VipsObjectClass *object_class = (VipsObjectClass *) class;
    VipsForeignClass *foreign_class = (VipsForeignClass *) class;
    VipsForeignSaveClass *save_class = (VipsForeignSaveClass *) class;

    gobject_class-&gt;set_property = vips_object_set_property;
    gobject_class-&gt;get_property = vips_object_get_property;

    object_class-&gt;nickname = "csvsave";
    object_class-&gt;description = _("save image to csv file");
    object_class-&gt;build = vips_foreign_save_csv_build;

    foreign_class-&gt;suffs = vips__foreign_csv_suffs;

    save_class-&gt;saveable = VIPS_FOREIGN_SAVEABLE_MONO;
    // no need to define -&gt;format_table, we don't want the input
    // cast for us

    VIPS_ARG_STRING(class, "filename", 1,
        _("Filename"),
        _("Filename to save to"),
        VIPS_ARGUMENT_REQUIRED_INPUT,
        G_STRUCT_OFFSET(VipsForeignSaveCsv, filename),
        NULL);

    VIPS_ARG_STRING(class, "separator", 13,
        _("Separator"),
        _("Separator characters"),
        VIPS_ARGUMENT_OPTIONAL_INPUT,
        G_STRUCT_OFFSET(VipsForeignSaveCsv, separator),
        "\t");
}

static void
vips_foreign_save_csv_init(VipsForeignSaveCsv *csv)
{
    csv-&gt;separator = g_strdup("\t");
}
```</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="455"/>
      <property name="background" writable="1" transfer-ownership="none">
        <type name="ArrayDouble"/>
      </property>
      <property name="in" writable="1" transfer-ownership="none">
        <type name="Image"/>
      </property>
      <property name="keep"
                writable="1"
                transfer-ownership="none"
                default-value="VIPS_FOREIGN_KEEP_EXIF | VIPS_FOREIGN_KEEP_XMP | VIPS_FOREIGN_KEEP_IPTC | VIPS_FOREIGN_KEEP_ICC | VIPS_FOREIGN_KEEP_OTHER | VIPS_FOREIGN_KEEP_GAINMAP">
        <type name="ForeignKeep"/>
      </property>
      <property name="page-height"
                writable="1"
                transfer-ownership="none"
                default-value="0">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="profile"
                writable="1"
                transfer-ownership="none"
                default-value="NULL">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="strip"
                writable="1"
                transfer-ownership="none"
                default-value="FALSE">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent_object">
        <type name="Foreign" c:type="VipsForeign"/>
      </field>
      <field name="strip">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="keep">
        <type name="ForeignKeep" c:type="VipsForeignKeep"/>
      </field>
      <field name="profile">
        <type name="utf8" c:type="char*"/>
      </field>
      <field name="background">
        <type name="ArrayDouble" c:type="VipsArrayDouble*"/>
      </field>
      <field name="page_height">
        <type name="gint" c:type="int"/>
      </field>
      <field name="in">
        <type name="Image" c:type="VipsImage*"/>
      </field>
      <field name="ready">
        <type name="Image" c:type="VipsImage*"/>
      </field>
    </class>
    <record name="ForeignSaveClass"
            c:type="VipsForeignSaveClass"
            glib:is-gtype-struct-for="ForeignSave">
      <source-position filename="libvips/include/vips/foreign.h" line="455"/>
      <field name="parent_class">
        <type name="ForeignClass" c:type="VipsForeignClass"/>
      </field>
      <field name="saveable">
        <type name="ForeignSaveable" c:type="VipsForeignSaveable"/>
      </field>
      <field name="format_table">
        <type name="BandFormat" c:type="VipsBandFormat*"/>
      </field>
      <field name="coding">
        <type name="ForeignCoding" c:type="VipsForeignCoding"/>
      </field>
    </record>
    <bitfield name="ForeignSaveable"
              glib:type-name="VipsForeignSaveable"
              glib:get-type="vips_foreign_saveable_get_type"
              c:type="VipsForeignSaveable">
      <doc xml:space="preserve"
           filename="libvips/include/vips/foreign.h"
           line="310">The set of image types supported by a saver.

::: seealso
    [class@ForeignSave].</doc>
      <member name="any"
              value="0"
              c:identifier="VIPS_FOREIGN_SAVEABLE_ANY"
              glib:nick="any"
              glib:name="VIPS_FOREIGN_SAVEABLE_ANY">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="312">saver supports everything (eg. TIFF)</doc>
      </member>
      <member name="mono"
              value="1"
              c:identifier="VIPS_FOREIGN_SAVEABLE_MONO"
              glib:nick="mono"
              glib:name="VIPS_FOREIGN_SAVEABLE_MONO">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="313">1 band</doc>
      </member>
      <member name="rgb"
              value="2"
              c:identifier="VIPS_FOREIGN_SAVEABLE_RGB"
              glib:nick="rgb"
              glib:name="VIPS_FOREIGN_SAVEABLE_RGB">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="314">3 bands</doc>
      </member>
      <member name="cmyk"
              value="4"
              c:identifier="VIPS_FOREIGN_SAVEABLE_CMYK"
              glib:nick="cmyk"
              glib:name="VIPS_FOREIGN_SAVEABLE_CMYK">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="315">4 bands</doc>
      </member>
      <member name="alpha"
              value="8"
              c:identifier="VIPS_FOREIGN_SAVEABLE_ALPHA"
              glib:nick="alpha"
              glib:name="VIPS_FOREIGN_SAVEABLE_ALPHA">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="316">an extra band</doc>
      </member>
      <member name="all"
              value="15"
              c:identifier="VIPS_FOREIGN_SAVEABLE_ALL"
              glib:nick="all"
              glib:name="VIPS_FOREIGN_SAVEABLE_ALL">
      </member>
    </bitfield>
    <enumeration name="ForeignSubsample"
                 glib:type-name="VipsForeignSubsample"
                 glib:get-type="vips_foreign_subsample_get_type"
                 c:type="VipsForeignSubsample">
      <doc xml:space="preserve"
           filename="libvips/include/vips/foreign.h"
           line="489">Set subsampling mode.</doc>
      <member name="auto"
              value="0"
              c:identifier="VIPS_FOREIGN_SUBSAMPLE_AUTO"
              glib:nick="auto"
              glib:name="VIPS_FOREIGN_SUBSAMPLE_AUTO">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="491">prevent subsampling when quality &gt;= 90</doc>
      </member>
      <member name="on"
              value="1"
              c:identifier="VIPS_FOREIGN_SUBSAMPLE_ON"
              glib:nick="on"
              glib:name="VIPS_FOREIGN_SUBSAMPLE_ON">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="492">always perform subsampling</doc>
      </member>
      <member name="off"
              value="2"
              c:identifier="VIPS_FOREIGN_SUBSAMPLE_OFF"
              glib:nick="off"
              glib:name="VIPS_FOREIGN_SUBSAMPLE_OFF">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="493">never perform subsampling</doc>
      </member>
    </enumeration>
    <enumeration name="ForeignTiffCompression"
                 glib:type-name="VipsForeignTiffCompression"
                 glib:get-type="vips_foreign_tiff_compression_get_type"
                 c:type="VipsForeignTiffCompression">
      <doc xml:space="preserve"
           filename="libvips/include/vips/foreign.h"
           line="571">The compression types supported by the tiff writer.

Use @Q to set the jpeg compression level, default 75.

Use @predictor to set the lzw or deflate prediction, default horizontal.

Use @lossless to set WEBP lossless compression.

Use @level to set webp and zstd compression level.</doc>
      <member name="none"
              value="0"
              c:identifier="VIPS_FOREIGN_TIFF_COMPRESSION_NONE"
              glib:nick="none"
              glib:name="VIPS_FOREIGN_TIFF_COMPRESSION_NONE">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="573">no compression</doc>
      </member>
      <member name="jpeg"
              value="1"
              c:identifier="VIPS_FOREIGN_TIFF_COMPRESSION_JPEG"
              glib:nick="jpeg"
              glib:name="VIPS_FOREIGN_TIFF_COMPRESSION_JPEG">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="574">jpeg compression</doc>
      </member>
      <member name="deflate"
              value="2"
              c:identifier="VIPS_FOREIGN_TIFF_COMPRESSION_DEFLATE"
              glib:nick="deflate"
              glib:name="VIPS_FOREIGN_TIFF_COMPRESSION_DEFLATE">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="575">deflate (zip) compression</doc>
      </member>
      <member name="packbits"
              value="3"
              c:identifier="VIPS_FOREIGN_TIFF_COMPRESSION_PACKBITS"
              glib:nick="packbits"
              glib:name="VIPS_FOREIGN_TIFF_COMPRESSION_PACKBITS">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="576">packbits compression</doc>
      </member>
      <member name="ccittfax4"
              value="4"
              c:identifier="VIPS_FOREIGN_TIFF_COMPRESSION_CCITTFAX4"
              glib:nick="ccittfax4"
              glib:name="VIPS_FOREIGN_TIFF_COMPRESSION_CCITTFAX4">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="577">fax4 compression</doc>
      </member>
      <member name="lzw"
              value="5"
              c:identifier="VIPS_FOREIGN_TIFF_COMPRESSION_LZW"
              glib:nick="lzw"
              glib:name="VIPS_FOREIGN_TIFF_COMPRESSION_LZW">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="578">LZW compression</doc>
      </member>
      <member name="webp"
              value="6"
              c:identifier="VIPS_FOREIGN_TIFF_COMPRESSION_WEBP"
              glib:nick="webp"
              glib:name="VIPS_FOREIGN_TIFF_COMPRESSION_WEBP">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="579">WEBP compression</doc>
      </member>
      <member name="zstd"
              value="7"
              c:identifier="VIPS_FOREIGN_TIFF_COMPRESSION_ZSTD"
              glib:nick="zstd"
              glib:name="VIPS_FOREIGN_TIFF_COMPRESSION_ZSTD">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="580">ZSTD compression</doc>
      </member>
      <member name="jp2k"
              value="8"
              c:identifier="VIPS_FOREIGN_TIFF_COMPRESSION_JP2K"
              glib:nick="jp2k"
              glib:name="VIPS_FOREIGN_TIFF_COMPRESSION_JP2K">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="581">JP2K compression</doc>
      </member>
    </enumeration>
    <enumeration name="ForeignTiffPredictor"
                 glib:type-name="VipsForeignTiffPredictor"
                 glib:get-type="vips_foreign_tiff_predictor_get_type"
                 c:type="VipsForeignTiffPredictor">
      <doc xml:space="preserve"
           filename="libvips/include/vips/foreign.h"
           line="606">The predictor can help deflate and lzw compression. The values are fixed by
the tiff library.</doc>
      <member name="none"
              value="1"
              c:identifier="VIPS_FOREIGN_TIFF_PREDICTOR_NONE"
              glib:nick="none"
              glib:name="VIPS_FOREIGN_TIFF_PREDICTOR_NONE">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="608">no prediction</doc>
      </member>
      <member name="horizontal"
              value="2"
              c:identifier="VIPS_FOREIGN_TIFF_PREDICTOR_HORIZONTAL"
              glib:nick="horizontal"
              glib:name="VIPS_FOREIGN_TIFF_PREDICTOR_HORIZONTAL">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="609">horizontal differencing</doc>
      </member>
      <member name="float"
              value="3"
              c:identifier="VIPS_FOREIGN_TIFF_PREDICTOR_FLOAT"
              glib:nick="float"
              glib:name="VIPS_FOREIGN_TIFF_PREDICTOR_FLOAT">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="610">float predictor</doc>
      </member>
    </enumeration>
    <enumeration name="ForeignTiffResunit"
                 glib:type-name="VipsForeignTiffResunit"
                 glib:get-type="vips_foreign_tiff_resunit_get_type"
                 c:type="VipsForeignTiffResunit">
      <doc xml:space="preserve"
           filename="libvips/include/vips/foreign.h"
           line="622">Use inches or centimeters as the resolution unit for a tiff file.</doc>
      <member name="cm"
              value="0"
              c:identifier="VIPS_FOREIGN_TIFF_RESUNIT_CM"
              glib:nick="cm"
              glib:name="VIPS_FOREIGN_TIFF_RESUNIT_CM">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="624">use centimeters</doc>
      </member>
      <member name="inch"
              value="1"
              c:identifier="VIPS_FOREIGN_TIFF_RESUNIT_INCH"
              glib:nick="inch"
              glib:name="VIPS_FOREIGN_TIFF_RESUNIT_INCH">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="625">use inches</doc>
      </member>
    </enumeration>
    <enumeration name="ForeignWebpPreset"
                 glib:type-name="VipsForeignWebpPreset"
                 glib:get-type="vips_foreign_webp_preset_get_type"
                 c:type="VipsForeignWebpPreset">
      <doc xml:space="preserve"
           filename="libvips/include/vips/foreign.h"
           line="527">Tune lossy encoder settings for different image types.</doc>
      <member name="default"
              value="0"
              c:identifier="VIPS_FOREIGN_WEBP_PRESET_DEFAULT"
              glib:nick="default"
              glib:name="VIPS_FOREIGN_WEBP_PRESET_DEFAULT">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="529">default preset</doc>
      </member>
      <member name="picture"
              value="1"
              c:identifier="VIPS_FOREIGN_WEBP_PRESET_PICTURE"
              glib:nick="picture"
              glib:name="VIPS_FOREIGN_WEBP_PRESET_PICTURE">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="530">digital picture, like portrait, inner shot</doc>
      </member>
      <member name="photo"
              value="2"
              c:identifier="VIPS_FOREIGN_WEBP_PRESET_PHOTO"
              glib:nick="photo"
              glib:name="VIPS_FOREIGN_WEBP_PRESET_PHOTO">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="531">outdoor photograph, with natural lighting</doc>
      </member>
      <member name="drawing"
              value="3"
              c:identifier="VIPS_FOREIGN_WEBP_PRESET_DRAWING"
              glib:nick="drawing"
              glib:name="VIPS_FOREIGN_WEBP_PRESET_DRAWING">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="532">hand or line drawing, with high-contrast details</doc>
      </member>
      <member name="icon"
              value="4"
              c:identifier="VIPS_FOREIGN_WEBP_PRESET_ICON"
              glib:nick="icon"
              glib:name="VIPS_FOREIGN_WEBP_PRESET_ICON">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="533">small-sized colorful images</doc>
      </member>
      <member name="text"
              value="5"
              c:identifier="VIPS_FOREIGN_WEBP_PRESET_TEXT"
              glib:nick="text"
              glib:name="VIPS_FOREIGN_WEBP_PRESET_TEXT">
        <doc xml:space="preserve"
             filename="libvips/include/vips/foreign.h"
             line="534">text-like</doc>
      </member>
    </enumeration>
    <function-macro name="GATE_FREE"
                    c:identifier="VIPS_GATE_FREE"
                    introspectable="0">
      <source-position filename="libvips/include/vips/gate.h" line="64"/>
      <parameters>
        <parameter name="SIZE">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GATE_MALLOC"
                    c:identifier="VIPS_GATE_MALLOC"
                    introspectable="0">
      <source-position filename="libvips/include/vips/gate.h" line="56"/>
      <parameters>
        <parameter name="SIZE">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GATE_START"
                    c:identifier="VIPS_GATE_START"
                    introspectable="0">
      <source-position filename="libvips/include/vips/gate.h" line="40"/>
      <parameters>
        <parameter name="NAME">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GATE_STOP"
                    c:identifier="VIPS_GATE_STOP"
                    introspectable="0">
      <source-position filename="libvips/include/vips/gate.h" line="48"/>
      <parameters>
        <parameter name="NAME">
        </parameter>
      </parameters>
    </function-macro>
    <class name="GInputStream"
           c:symbol-prefix="g_input_stream"
           c:type="VipsGInputStream"
           parent="Gio.InputStream"
           glib:type-name="VipsGInputStream"
           glib:get-type="vips_g_input_stream_get_type"
           glib:type-struct="GInputStreamClass">
      <source-position filename="libvips/include/vips/connection.h"
                       line="322"/>
      <implements name="Gio.Seekable"/>
      <constructor name="new_from_source"
                   c:identifier="vips_g_input_stream_new_from_source">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/ginputsource.c"
             line="286">Create a new [class@Gio.InputStream] wrapping a [class@Source]. This is
useful for loaders like SVG and PDF which support [class@Gio.InputStream]
methods.

::: seealso
    [ctor@SourceGInputStream.new]</doc>
        <source-position filename="libvips/include/vips/connection.h"
                         line="327"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/ginputsource.c"
               line="297">a new [class@Gio.InputStream]</doc>
          <type name="Gio.InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/ginputsource.c"
                 line="288">vips source to wrap</doc>
            <type name="Source" c:type="VipsSource*"/>
          </parameter>
        </parameters>
      </constructor>
      <property name="input"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Source"/>
      </property>
      <field name="parent_instance">
        <type name="Gio.InputStream" c:type="GInputStream"/>
      </field>
      <field name="source" readable="0" private="1">
        <type name="Source" c:type="VipsSource*"/>
      </field>
    </class>
    <record name="GInputStreamClass"
            c:type="VipsGInputStreamClass"
            glib:is-gtype-struct-for="GInputStream">
      <source-position filename="libvips/include/vips/connection.h"
                       line="322"/>
      <field name="parent_class">
        <type name="Gio.InputStreamClass" c:type="GInputStreamClass"/>
      </field>
    </record>
    <function-macro name="G_INPUT_STREAM"
                    c:identifier="VIPS_G_INPUT_STREAM"
                    introspectable="0">
      <source-position filename="libvips/include/vips/connection.h"
                       line="294"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="G_INPUT_STREAM_CLASS"
                    c:identifier="VIPS_G_INPUT_STREAM_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/connection.h"
                       line="297"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="G_INPUT_STREAM_GET_CLASS"
                    c:identifier="VIPS_G_INPUT_STREAM_GET_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/connection.h"
                       line="304"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <callback name="GenerateFn" c:type="VipsGenerateFn">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/generate.c"
           line="595">Fill @out-&gt;valid with pixels. @seq contains per-thread state, such as the
input regions. Set @stop to `TRUE` to stop processing.

::: seealso
    [method@Image.generate], [func@stop_many].</doc>
      <source-position filename="libvips/include/vips/image.h" line="152"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/generate.c"
             line="609">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/generate.c"
               line="597">[class@Region] to fill</doc>
          <type name="Region" c:type="VipsRegion*"/>
        </parameter>
        <parameter name="seq"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/generate.c"
               line="598">sequence value</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/generate.c"
               line="599">user data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/generate.c"
               line="600">user data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="stop" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/generate.c"
               line="601">set this to stop processing</doc>
          <type name="gboolean" c:type="gboolean*"/>
        </parameter>
      </parameters>
    </callback>
    <function-macro name="IMAGE" c:identifier="VIPS_IMAGE" introspectable="0">
      <source-position filename="libvips/include/vips/image.h" line="173"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IMAGE_ADDR"
                    c:identifier="VIPS_IMAGE_ADDR"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/image.c"
           line="320">This macro returns a pointer to a pixel in an image, cast to a [alias@Pel] \*.
It only works for images which are fully available in memory, so memory
buffers and small mapped images only.

If `VIPS_DEBUG` is defined, you get a version that checks bounds for you.

::: seealso
    [method@Image.wio_input], [method@Image.inplace], [func@REGION_ADDR].</doc>
      <source-position filename="libvips/include/vips/image.h" line="398"/>
      <parameters>
        <parameter name="I">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="322">a [class@Image]</doc>
        </parameter>
        <parameter name="X">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="323">x coordinate</doc>
        </parameter>
        <parameter name="Y">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="324">y coordinate</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IMAGE_CLASS"
                    c:identifier="VIPS_IMAGE_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/image.h" line="176"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IMAGE_GET_CLASS"
                    c:identifier="VIPS_IMAGE_GET_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/image.h" line="183"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IMAGE_N_ELEMENTS"
                    c:identifier="VIPS_IMAGE_N_ELEMENTS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/image.h" line="390"/>
      <parameters>
        <parameter name="I">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="308">a [class@Image]</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IMAGE_N_PELS"
                    c:identifier="VIPS_IMAGE_N_PELS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/image.h" line="392"/>
      <parameters>
        <parameter name="I">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="315">a [class@Image]</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IMAGE_SIZEOF_ELEMENT"
                    c:identifier="VIPS_IMAGE_SIZEOF_ELEMENT"
                    introspectable="0">
      <source-position filename="libvips/include/vips/image.h" line="382"/>
      <parameters>
        <parameter name="I">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="287">a [class@Image]</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IMAGE_SIZEOF_IMAGE"
                    c:identifier="VIPS_IMAGE_SIZEOF_IMAGE"
                    introspectable="0">
      <source-position filename="libvips/include/vips/image.h" line="388"/>
      <parameters>
        <parameter name="I">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IMAGE_SIZEOF_LINE"
                    c:identifier="VIPS_IMAGE_SIZEOF_LINE"
                    introspectable="0">
      <source-position filename="libvips/include/vips/image.h" line="386"/>
      <parameters>
        <parameter name="I">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="301">a [class@Image]</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IMAGE_SIZEOF_PEL"
                    c:identifier="VIPS_IMAGE_SIZEOF_PEL"
                    introspectable="0">
      <source-position filename="libvips/include/vips/image.h" line="384"/>
      <parameters>
        <parameter name="I">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="294">a [class@Image]</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="INIT" c:identifier="VIPS_INIT" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/init.c"
           line="210">[func@INIT] starts up the world of VIPS. You should call this on
program startup before using any other VIPS operations. If you do not call
[func@INIT], VIPS will call it for you when you use your first VIPS
operation, but it may not be able to get hold of @ARGV0 and VIPS may
therefore be unable to find its data files. It is much better to call
this macro yourself.

@ARGV0 is used to help discover message catalogues if libvips has been
relocated. If you don't need a relocatable package, you can just pass `""`
and it'll be fine.

Additionally, [func@INIT] can be run from any thread, but it must not be
called from more than one thread at the same time. This is much easier to
guarantee if you call it yourself.

[func@INIT] is a macro, since it tries to check ABI compatibility
between the caller and the library. You can also call [func@init], the
non-macro version, if macros are not available to you.

You may call [func@INIT] many times and [func@shutdown] many times, but you
must not call [func@INIT] after [func@shutdown]. In other words, you cannot
stop and restart vips.

Use the environment variable `VIPS_MIN_STACK_SIZE` to set the minimum stack
size. For example, `2m` for a minimum of two megabytes of stack. This can
be important for systems like musl where the default stack is very small.

[func@INIT] does approximately the following:

- checks that the libvips your program is expecting is
  binary-compatible with the vips library you're running against

- sets a minimum stack size, see above

- initialises any libraries that VIPS is using, including GObject
  and the threading system, if necessary

- guesses where the VIPS data files are and sets up
  internationalisation -- see [func@guess_prefix]

- creates the main vips types, including [class@Image] and friends

- loads any plugins from $libdir/vips-x.y/, where x and y are the
  major and minor version numbers for this VIPS.

Example:

```c
int main(int argc, char **argv)
{
    if (VIPS_INIT(argv[0]))
        vips_error_exit("unable to start VIPS");

    vips_shutdown();

    return 0;
}
```

::: seealso
    [func@shutdown], [func@add_option_entries], [func@version],
    [func@guess_prefix], [func@guess_libdir].</doc>
      <source-position filename="libvips/include/vips/vips.h" line="153"/>
      <parameters>
        <parameter name="ARGV0">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/init.c"
               line="212">name of application</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="INTERPOLATE"
                    c:identifier="VIPS_INTERPOLATE"
                    introspectable="0">
      <source-position filename="libvips/include/vips/interpolate.h"
                       line="46"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="INTERPOLATE_CLASS"
                    c:identifier="VIPS_INTERPOLATE_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/interpolate.h"
                       line="49"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="INTERPOLATE_GET_CLASS"
                    c:identifier="VIPS_INTERPOLATE_GET_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/interpolate.h"
                       line="56"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="INTERPOLATE_SCALE"
              value="1"
              c:type="VIPS_INTERPOLATE_SCALE">
      <doc xml:space="preserve"
           filename="libvips/resample/interpolate.c"
           line="301">[const@INTERPOLATE_SHIFT] as a multiplicative constant.</doc>
      <source-position filename="libvips/include/vips/interpolate.h"
                       line="118"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="INTERPOLATE_SHIFT"
              value="12"
              c:type="VIPS_INTERPOLATE_SHIFT">
      <doc xml:space="preserve"
           filename="libvips/resample/interpolate.c"
           line="294">Many of the vips interpolators use fixed-point arithmetic for value
calculation. This is how many bits of precision they use.</doc>
      <source-position filename="libvips/include/vips/interpolate.h"
                       line="117"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="ISNAN" c:identifier="VIPS_ISNAN" introspectable="0">
      <source-position filename="libvips/include/vips/util.h" line="70"/>
      <parameters>
        <parameter name="V">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_CONNECTION"
                    c:identifier="VIPS_IS_CONNECTION"
                    introspectable="0">
      <source-position filename="libvips/include/vips/connection.h" line="53"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_CONNECTION_CLASS"
                    c:identifier="VIPS_IS_CONNECTION_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/connection.h" line="55"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_FOREIGN"
                    c:identifier="VIPS_IS_FOREIGN"
                    introspectable="0">
      <source-position filename="libvips/include/vips/foreign.h" line="51"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_FOREIGN_CLASS"
                    c:identifier="VIPS_IS_FOREIGN_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/foreign.h" line="53"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_FOREIGN_LOAD"
                    c:identifier="VIPS_IS_FOREIGN_LOAD"
                    introspectable="0">
      <source-position filename="libvips/include/vips/foreign.h" line="136"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_FOREIGN_LOAD_CLASS"
                    c:identifier="VIPS_IS_FOREIGN_LOAD_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/foreign.h" line="138"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_FOREIGN_SAVE"
                    c:identifier="VIPS_IS_FOREIGN_SAVE"
                    introspectable="0">
      <source-position filename="libvips/include/vips/foreign.h" line="302"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_FOREIGN_SAVE_CLASS"
                    c:identifier="VIPS_IS_FOREIGN_SAVE_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/foreign.h" line="304"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_G_INPUT_STREAM"
                    c:identifier="VIPS_IS_G_INPUT_STREAM"
                    introspectable="0">
      <source-position filename="libvips/include/vips/connection.h"
                       line="300"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_G_INPUT_STREAM_CLASS"
                    c:identifier="VIPS_IS_G_INPUT_STREAM_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/connection.h"
                       line="302"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_IMAGE"
                    c:identifier="VIPS_IS_IMAGE"
                    introspectable="0">
      <source-position filename="libvips/include/vips/image.h" line="179"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_IMAGE_CLASS"
                    c:identifier="VIPS_IS_IMAGE_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/image.h" line="181"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_INTERPOLATE"
                    c:identifier="VIPS_IS_INTERPOLATE"
                    introspectable="0">
      <source-position filename="libvips/include/vips/interpolate.h"
                       line="52"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_INTERPOLATE_CLASS"
                    c:identifier="VIPS_IS_INTERPOLATE_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/interpolate.h"
                       line="54"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_OBJECT"
                    c:identifier="VIPS_IS_OBJECT"
                    introspectable="0">
      <source-position filename="libvips/include/vips/object.h" line="421"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_OBJECT_CLASS"
                    c:identifier="VIPS_IS_OBJECT_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/object.h" line="423"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_OPERATION"
                    c:identifier="VIPS_IS_OPERATION"
                    introspectable="0">
      <source-position filename="libvips/include/vips/operation.h" line="63"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_OPERATION_CLASS"
                    c:identifier="VIPS_IS_OPERATION_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/operation.h" line="65"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_REGION"
                    c:identifier="VIPS_IS_REGION"
                    introspectable="0">
      <source-position filename="libvips/include/vips/region.h" line="57"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_REGION_CLASS"
                    c:identifier="VIPS_IS_REGION_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/region.h" line="59"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_SBUF"
                    c:identifier="VIPS_IS_SBUF"
                    introspectable="0">
      <source-position filename="libvips/include/vips/sbuf.h" line="51"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_SBUF_CLASS"
                    c:identifier="VIPS_IS_SBUF_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/sbuf.h" line="53"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_SOURCE"
                    c:identifier="VIPS_IS_SOURCE"
                    introspectable="0">
      <source-position filename="libvips/include/vips/connection.h"
                       line="109"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_SOURCE_CLASS"
                    c:identifier="VIPS_IS_SOURCE_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/connection.h"
                       line="111"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_SOURCE_CUSTOM"
                    c:identifier="VIPS_IS_SOURCE_CUSTOM"
                    introspectable="0">
      <source-position filename="libvips/include/vips/connection.h"
                       line="259"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_SOURCE_CUSTOM_CLASS"
                    c:identifier="VIPS_IS_SOURCE_CUSTOM_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/connection.h"
                       line="261"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_SOURCE_G_INPUT_STREAM"
                    c:identifier="VIPS_IS_SOURCE_G_INPUT_STREAM"
                    introspectable="0">
      <source-position filename="libvips/include/vips/connection.h"
                       line="340"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_SOURCE_G_INPUT_STREAM_CLASS"
                    c:identifier="VIPS_IS_SOURCE_G_INPUT_STREAM_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/connection.h"
                       line="342"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_TARGET"
                    c:identifier="VIPS_IS_TARGET"
                    introspectable="0">
      <source-position filename="libvips/include/vips/connection.h"
                       line="379"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_TARGET_CLASS"
                    c:identifier="VIPS_IS_TARGET_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/connection.h"
                       line="381"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_TARGET_CUSTOM"
                    c:identifier="VIPS_IS_TARGET_CUSTOM"
                    introspectable="0">
      <source-position filename="libvips/include/vips/connection.h"
                       line="520"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_TARGET_CUSTOM_CLASS"
                    c:identifier="VIPS_IS_TARGET_CUSTOM_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/connection.h"
                       line="522"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_THREAD_STATE"
                    c:identifier="VIPS_IS_THREAD_STATE"
                    introspectable="0">
      <source-position filename="libvips/include/vips/threadpool.h" line="61"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_THREAD_STATE_CLASS"
                    c:identifier="VIPS_IS_THREAD_STATE_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/threadpool.h" line="63"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <class name="Image"
           c:symbol-prefix="image"
           c:type="VipsImage"
           parent="Object"
           glib:type-name="VipsImage"
           glib:get-type="vips_image_get_type"
           glib:type-struct="ImageClass">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/image.c"
           line="74">The [class@Image] class and associated types and macros.

Images can be created from formatted files on disc, from C-style arrays on
disc, from formatted areas of memory, or from C-style arrays in memory. See
[ctor@Image.new_from_file] and friends.
Creating an image is fast. libvips reads just enough of
the image to be able to get the various properties, such as width in
pixels. It delays reading any pixels until they are really needed.

Once you have an image, you can get properties from it in the usual way.
You can use projection functions, like [method@Image.get_width] or
[method@GObject.Object.get], to get [class@GObject.Object] properties.

`.v` images are three-dimensional arrays, the dimensions being width,
height and bands. Each dimension can be up to 2 ** 31 pixels (or band
elements). An image has a format, meaning the machine number type used
to represent each value. libvips supports 10 formats, from 8-bit unsigned
integer up to 128-bit double complex, see [method@Image.get_format].

In libvips, images are uninterpreted arrays, meaning that from the point
of view of most operations, they are just large collections of numbers.
There's no difference between an RGBA (RGB with alpha) image and a CMYK
image, for example, they are both just four-band images. It's up to the
user of the library to pass the right sort of image to each operation.

To take an example, libvips has [method@Image.Lab2XYZ], an operation to
transform an image from CIE LAB colour space to CIE XYZ space. It assumes
the first three bands represent pixels in LAB colour space and returns an
image where the first three bands are transformed to XYZ and any
remaining bands are just copied. Pass it an RGB image by mistake and
you'll just get nonsense.

libvips has a feature to help (a little) with this: it sets a
[enum@Interpretation] hint for each image (see
[method@Image.get_interpretation]); a hint which says how pixels should
be interpreted. For example, [method@Image.Lab2XYZ] will set the
interpretation of the output image to [enum@Vips.Interpretation.XYZ].
A few utility operations will also use interpretation as a guide. For
example, you can give [method@Image.colourspace] an input image and a
desired colourspace and it will use the input's interpretation hint to
apply the best sequence of colourspace transforms to get to the desired
space.

Use things like [method@Image.invert] to manipulate your images. When you
are done, you can write images to disc files (with
[method@Image.write_to_file]), to formatted memory buffers (with
[method@Image.write_to_buffer]) and to C-style memory arrays (with
[method@Image.write_to_memory]).

You can also write images to other images. Create, for example, a temporary
disc image with [ctor@Image.new_temp_file], then write your image to that
with [method@Image.write]. You can create several other types of image and
write to them, see [ctor@Image.new_memory], for example.

See [class@Operation] for an introduction to running operations on images,
see [Image headers](libvips-header.html) for getting and setting image
metadata. See [class@Object] for a discussion of the lower levels.</doc>
      <source-position filename="libvips/include/vips/image.h" line="371"/>
      <constructor name="memory" c:identifier="vips_image_memory">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="1768">A renamed [ctor@Image.new_memory] ... Some gobject binding systems do not
like more than one `_new()` method.

::: seealso
    [ctor@Image.new_memory].</doc>
        <source-position filename="libvips/include/vips/image.h" line="472"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="1777">the new [class@Image], or `NULL` on error.</doc>
          <type name="Image" c:type="VipsImage*"/>
        </return-value>
      </constructor>
      <constructor name="new" c:identifier="vips_image_new">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="1689">[ctor@Image.new] creates a new, empty [class@Image].
If you write to one of these images, vips will just attach some callbacks,
no pixels will be generated.

Write pixels to an image with [method@Image.generate] or
[method@Image.write_line]. Write a whole image to another image with
[method@Image.write].</doc>
        <source-position filename="libvips/include/vips/image.h" line="468"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="1700">the new [class@Image], or `NULL` on error.</doc>
          <type name="Image" c:type="VipsImage*"/>
        </return-value>
      </constructor>
      <constructor name="new_from_buffer"
                   c:identifier="vips_image_new_from_buffer"
                   introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="2114">Loads an image from the formatted area of memory @buf, @len using the
loader recommended by [func@Foreign.find_load_buffer].
To load an unformatted area of memory, use
[ctor@Image.new_from_memory].

VIPS does not take
responsibility for the area of memory, it's up to you to make sure it's
freed when the image is closed. See for example [signal@Object::close].

Load options may be given in @option_string as `[name=value,...]` or given as
a `NULL`-terminated list of name-value pairs at the end of the arguments.
Options given in the function call override options given in the filename.

::: seealso
    [method@Image.write_to_buffer].</doc>
        <source-position filename="libvips/include/vips/image.h" line="488"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="2137">the new [class@Image], or `NULL` on error.</doc>
          <type name="Image" c:type="VipsImage*"/>
        </return-value>
        <parameters>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2116">image data</doc>
            <array length="1" zero-terminated="0" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2117">length of memory buffer</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
          <parameter name="option_string" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2118">set of extra options as a string</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2119">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_file"
                   c:identifier="vips_image_new_from_file"
                   introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="1835">[ctor@Image.new_from_file] opens @name for reading. It can load files
in many image formats, including VIPS, TIFF, PNG, JPEG, FITS, Matlab,
OpenEXR, CSV, WebP, Radiance, RAW, PPM and others.

Load options may be appended to @filename as `[name=value,...]` or given as
a `NULL`-terminated list of name-value pairs at the end of the arguments.
Options given in the function call override options given in the filename.
Many loaders add extra options, see [ctor@Image.jpegload], for example.

[ctor@Image.new_from_file] always returns immediately with the header
fields filled in. No pixels are actually read until you first access them.

@access lets you set a [enum@Access] hint giving the expected access pattern
for this file.
[enum@Vips.Access.RANDOM] means you can fetch pixels randomly from the image.
This is the default mode. [enum@Vips.Access.SEQUENTIAL] means you will
read the whole image exactly once, top-to-bottom. In this mode, libvips
can avoid converting the whole image in one go, for a large memory saving.
You are allowed to make small non-local references, so area operations like
convolution will work.

In [enum@Vips.Access.RANDOM] mode, small images are decompressed to memory
and then processed from there. Large images are decompressed to temporary
random-access files on disc and then processed from there.

Set @memory to `TRUE` to force loading via memory. The default is to load
large random access images via temporary disc files. See
[ctor@Image.new_temp_file] for an
explanation of how VIPS selects a location for the temporary file.

The disc threshold can be set with the `--vips-disc-threshold`
command-line argument, or the `VIPS_DISC_THRESHOLD` environment variable.
The value is a simple integer, but can take a unit postfix of "k",
"m" or "g" to indicate kilobytes, megabytes or gigabytes.
The default threshold is 100 MB.

For example:

```c
VipsImage *image = vips_image_new_from_file("fred.tif",
    "page", 12,
    NULL);
```

Will open "fred.tif", reading page 12.

```c
VipsImage *image = vips_image_new_from_file("fred.jpg[shrink=2]", NULL);
```

Will open `fred.jpg`, downsampling by a factor of two.

Use [func@Foreign.find_load] or [func@Foreign.is_a] to see what format a
file is in and therefore what options are available. If you need more
control over the loading process, you can call loaders directly, see
[ctor@Image.jpegload], for example.

::: tip "Optional arguments"
    * @access: [enum@Access], hint expected access pattern
    * @memory: `gboolean`, force load via memory

::: seealso
    [func@Foreign.find_load], [func@Foreign.is_a],
    [method@Image.write_to_file].</doc>
        <source-position filename="libvips/include/vips/image.h" line="474"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="1905">the new [class@Image], or `NULL` on error.</doc>
          <type name="Image" c:type="VipsImage*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="1837">file to open</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="1838">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_file_RW"
                   c:identifier="vips_image_new_from_file_RW">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="1935">Opens the named file for simultaneous reading and writing. This will only
work for VIPS files in a format native to your machine. It is only for
paintbox-type applications.

::: seealso
    [method@Image.draw_circle].</doc>
        <source-position filename="libvips/include/vips/image.h" line="477"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="1946">the new [class@Image], or `NULL` on error.</doc>
          <type name="Image" c:type="VipsImage*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="1937">filename to open</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_file_raw"
                   c:identifier="vips_image_new_from_file_raw">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="1954">This function maps the named file and returns a [class@Image] you can use to
read it.

It returns an 8-bit image with @bands bands. If the image is not 8-bit, use
[method@Image.copy] to transform the descriptor after loading it.

::: seealso
    [method@Image.copy], [ctor@Image.rawload], [ctor@Image.new_from_file].</doc>
        <source-position filename="libvips/include/vips/image.h" line="479"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="1971">the new [class@Image], or `NULL` on error.</doc>
          <type name="Image" c:type="VipsImage*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="1956">filename to open</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="xsize" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="1957">image width</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="ysize" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="1958">image height</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="bands" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="1959">image bands (or bytes per pixel)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="1960">bytes to skip at start of file</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_image"
                   c:identifier="vips_image_new_from_image">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="2398">Creates a new image with width, height, format, interpretation, resolution
and offset taken from @image, but with number of bands taken from @n and the
value of each band element set from @c.

::: seealso
    [ctor@Image.new_from_image1]</doc>
        <source-position filename="libvips/include/vips/image.h" line="505"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="2411">the new [class@Image], or `NULL` on error.</doc>
          <type name="Image" c:type="VipsImage*"/>
        </return-value>
        <parameters>
          <parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2400">image to copy</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2401">array of constants</doc>
            <array length="2" zero-terminated="0" c:type="const double*">
              <type name="gdouble" c:type="double"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2402">number of constants</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_image1"
                   c:identifier="vips_image_new_from_image1">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="2454">Creates a new image with width, height, format, interpretation, resolution
and offset taken from @image, but with one band and each pixel having the
value @c.

::: seealso
    [ctor@Image.new_from_image]</doc>
        <source-position filename="libvips/include/vips/image.h" line="508"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="2466">the new [class@Image], or `NULL` on error.</doc>
          <type name="Image" c:type="VipsImage*"/>
        </return-value>
        <parameters>
          <parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2456">image to copy</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2457">constants</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_memory"
                   c:identifier="vips_image_new_from_memory">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="1998">This function wraps a [class@Image] around a memory area. The memory area
must be a simple array, for example RGBRGBRGB, left-to-right,
top-to-bottom. Use [ctor@Image.new_from_buffer] to load an area of memory
containing an image in a format.

VIPS does not take
responsibility for the area of memory, it's up to you to make sure it's
freed when the image is closed. See for example [signal@Object::close].

Because VIPS is "borrowing" @data from the caller, this function is
extremely dangerous. Unless you are very careful, you will get crashes or
memory corruption. Use [ctor@Image.new_from_memory_copy] instead if you are
at all unsure.

Use [method@Image.copy] to set other image properties.

::: seealso
    [ctor@Image.new], [method@Image.write_to_memory],
    [ctor@Image.new_from_memory_copy].</doc>
        <source-position filename="libvips/include/vips/image.h" line="482"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="2027">the new [class@Image], or `NULL` on error.</doc>
          <type name="Image" c:type="VipsImage*"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2000">start of memory area</doc>
            <array length="1" zero-terminated="0" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2001">length of memory area</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2002">image width</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2003">image height</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="bands" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2004">image bands (or bytes per pixel)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2005">image format</doc>
            <type name="BandFormat" c:type="VipsBandFormat"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_memory_copy"
                   c:identifier="vips_image_new_from_memory_copy">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="2072">Like [ctor@Image.new_from_memory], but VIPS will make a copy of the memory
area. This means more memory use and an extra copy operation, but is much
simpler and safer.

::: seealso
    [ctor@Image.new_from_memory].</doc>
        <source-position filename="libvips/include/vips/image.h" line="485"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="2088">the new [class@Image], or `NULL` on error.</doc>
          <type name="Image" c:type="VipsImage*"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2074">start of memory area</doc>
            <array length="1" zero-terminated="0" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2075">length of memory area</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2076">image width</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2077">image height</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="bands" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2078">image bands (or bytes per pixel)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2079">image format</doc>
            <type name="BandFormat" c:type="VipsBandFormat"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_source"
                   c:identifier="vips_image_new_from_source"
                   introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="2171">Loads an image from the formatted source @input,
loader recommended by [func@Foreign.find_load_source].

Load options may be given in @option_string as `[name=value,...]` or given as
a `NULL`-terminated list of name-value pairs at the end of the arguments.
Options given in the function call override options given in the string.

::: seealso
    [method@Image.write_to_target].</doc>
        <source-position filename="libvips/include/vips/image.h" line="492"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="2187">the new [class@Image], or `NULL` on error.</doc>
          <type name="Image" c:type="VipsImage*"/>
        </return-value>
        <parameters>
          <parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2173">source to fetch image from</doc>
            <type name="Source" c:type="VipsSource*"/>
          </parameter>
          <parameter name="option_string" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2174">set of extra options as a string</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2175">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_matrix" c:identifier="vips_image_new_matrix">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="2258">This convenience function makes an image which is a matrix: a one-band
[enum@Vips.BandFormat.DOUBLE] image held in memory.

Use [func@IMAGE_ADDR], or [func@MATRIX] to address pixels in the image.

Use [method@Image.set_double] to set "scale" and "offset", if required.

::: seealso
    [ctor@Image.new_matrixv]</doc>
        <source-position filename="libvips/include/vips/image.h" line="495"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="2273">the new [class@Image], or `NULL` on error.</doc>
          <type name="Image" c:type="VipsImage*"/>
        </return-value>
        <parameters>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2260">image width</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2261">image height</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_matrix_from_array"
                   c:identifier="vips_image_new_matrix_from_array">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="2340">A binding-friendly version of [ctor@Image.new_matrixv].</doc>
        <source-position filename="libvips/include/vips/image.h" line="499"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="2349">the new [class@Image], or `NULL` on error.</doc>
          <type name="Image" c:type="VipsImage*"/>
        </return-value>
        <parameters>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2342">image width</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2343">image height</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2344">array of elements</doc>
            <array length="3" zero-terminated="0" c:type="const double*">
              <type name="gdouble" c:type="double"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2345">number of elements</doc>
            <type name="gsize" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_matrixv"
                   c:identifier="vips_image_new_matrixv"
                   introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="2305">As [ctor@Image.new_matrix], but initialise the matrix from the argument
list. After @height should be @width * @height double constants which are
used to set the matrix elements.

::: seealso
    [ctor@Image.new_matrix]</doc>
        <source-position filename="libvips/include/vips/image.h" line="497"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="2318">the new [class@Image], or `NULL` on error.</doc>
          <type name="Image" c:type="VipsImage*"/>
        </return-value>
        <parameters>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2307">image width</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2308">image height</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2309">matrix coefficients</doc>
            <varargs/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_memory"
                   c:identifier="vips_image_new_memory"
                   introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="1748">[ctor@Image.new_memory] creates a new [class@Image] which, when written to,
will create a memory image.

::: seealso
    [ctor@Image.new].</doc>
        <source-position filename="libvips/include/vips/image.h" line="470"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="1757">the new [class@Image], or `NULL` on error.</doc>
          <type name="Image" c:type="VipsImage*"/>
        </return-value>
      </constructor>
      <constructor name="new_temp_file"
                   c:identifier="vips_image_new_temp_file">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="2543">Make a [class@Image] which, when written to, will create a temporary file on
disc. The file will be automatically deleted when the image is destroyed.
@format is something like "&amp;percnt;s.v" for a vips file.

The file is created in the temporary directory. This is set with the
environment variable TMPDIR. If this is not set, then on Unix systems, vips
will default to /tmp. On Windows, vips uses `GetTempPath()` to find the
temporary directory.

::: seealso
    [ctor@Image.new].</doc>
        <source-position filename="libvips/include/vips/image.h" line="516"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="2559">the new [class@Image], or `NULL` on error.</doc>
          <type name="Image" c:type="VipsImage*"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2545">format of file</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="get_format_max" c:identifier="vips_image_get_format_max">
        <source-position filename="libvips/include/vips/header.h" line="214"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="438">the maximum numeric value possible for this format.</doc>
          <type name="gdouble" c:type="double"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="436">the format</doc>
            <type name="BandFormat" c:type="VipsBandFormat"/>
          </parameter>
        </parameters>
      </function>
      <function name="matrix_from_array"
                c:identifier="vips_image_matrix_from_array"
                introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="2378">A renamed [ctor@Image.new_matrix_from_array]. Some gobject bindings do not
like more than one _new method.</doc>
        <source-position filename="libvips/include/vips/image.h" line="502"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="2388">the new [class@Image], or `NULL` on error.</doc>
          <type name="Image" c:type="VipsImage*"/>
        </return-value>
        <parameters>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2380">image width</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2381">image height</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2382">array of elements</doc>
            <array length="3" zero-terminated="0" c:type="const double*">
              <type name="gdouble" c:type="double"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2383">number of elements</doc>
            <type name="gsize" c:type="int"/>
          </parameter>
        </parameters>
      </function>
      <function name="pipeline_array" c:identifier="vips_image_pipeline_array">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/generate.c"
             line="331">Add an image to a pipeline. @image depends on all of the images in @in,
@image prefers to supply pixels according to @hint.

Operations can set demand hints, that is, hints to the VIPS IO system about
the type of region geometry they work best with. For example,
operations which transform coordinates will usually work best with
[enum@Vips.DemandStyle.SMALLTILE], operations which work on local windows of
pixels will like [enum@Vips.DemandStyle.FATSTRIP].

Header fields in @image are set from the fields in @in, with lower-numbered
images in @in taking priority.
For example, if @in[0] and @in[1] both have an item
called "icc-profile", it's the profile attached to @in[0] that will end up
on @image.
Image history is completely copied from all @in. @image will have the history
of all the input images.
The array of input images can be empty, meaning @image is at the start of a
pipeline.

VIPS uses the list of input images to build the tree of operations it needs
for the cache invalidation system.

::: seealso
    [method@Image.pipelinev], [method@Image.generate].</doc>
        <source-position filename="libvips/include/vips/generate.h" line="82"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/generate.c"
               line="362">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter name="image"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/generate.c"
                 line="333">output image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="hint" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/generate.c"
                 line="334">demand hint for @image</doc>
            <type name="DemandStyle" c:type="VipsDemandStyle"/>
          </parameter>
          <parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/generate.c"
                 line="335">`NULL`-terminated array of input images</doc>
            <array c:type="VipsImage**">
              <type name="Image" c:type="VipsImage*"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="eval">
        <source-position filename="libvips/include/vips/image.h" line="343"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="progress" transfer-ownership="none">
            <type name="Progress" c:type="VipsProgress*"/>
          </parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="invalidate">
        <source-position filename="libvips/include/vips/image.h" line="359"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="minimise">
        <source-position filename="libvips/include/vips/image.h" line="369"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="posteval">
        <source-position filename="libvips/include/vips/image.h" line="347"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="progress" transfer-ownership="none">
            <type name="Progress" c:type="VipsProgress*"/>
          </parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="preeval">
        <source-position filename="libvips/include/vips/image.h" line="339"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="progress" transfer-ownership="none">
            <type name="Progress" c:type="VipsProgress*"/>
          </parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="written">
        <source-position filename="libvips/include/vips/image.h" line="354"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <type name="gint" c:type="int*"/>
          </parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="CMC2LCh" c:identifier="vips_CMC2LCh" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/colour/UCS2LCh.c"
             line="287">Turn LCh to CMC.

::: seealso
    [method@Image.LCh2CMC].</doc>
        <source-position filename="libvips/include/vips/colour.h" line="184"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/UCS2LCh.c"
               line="298">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/UCS2LCh.c"
                 line="289">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/colour/UCS2LCh.c"
                 line="290">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/UCS2LCh.c"
                 line="291">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="CMYK2XYZ" c:identifier="vips_CMYK2XYZ" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/colour/CMYK2XYZ.c"
             line="205">Turn CMYK to XYZ. If the image has an embedded ICC profile this will be
used for the conversion. If there is no embedded profile, a generic
fallback profile will be used.

Conversion is to D65 XYZ with relative intent. If you need more control
over the process, use [method@Image.icc_import] instead.</doc>
        <source-position filename="libvips/include/vips/colour.h" line="200"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/CMYK2XYZ.c"
               line="218">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/CMYK2XYZ.c"
                 line="207">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/colour/CMYK2XYZ.c"
                 line="208">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/CMYK2XYZ.c"
                 line="209">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="HSV2sRGB" c:identifier="vips_HSV2sRGB" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/colour/HSV2sRGB.c"
             line="133">Convert HSV to sRGB.

HSV is a crude polar coordinate system for RGB images. It is provided for
compatibility with other image processing systems. See [method@Image.Lab2LCh] for a
much better colour space.

::: seealso
    [method@Image.sRGB2HSV].</doc>
        <source-position filename="libvips/include/vips/colour.h" line="174"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/HSV2sRGB.c"
               line="148">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/HSV2sRGB.c"
                 line="135">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/colour/HSV2sRGB.c"
                 line="136">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/HSV2sRGB.c"
                 line="137">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="LCh2CMC" c:identifier="vips_LCh2CMC" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/colour/LCh2UCS.c"
             line="219">Turn LCh to CMC.

The CMC colourspace is described in "Uniform Colour Space Based on the
CMC(l:c) Colour-difference Formula", M R Luo and B Rigg, Journal of the
Society of Dyers and Colourists, vol 102, 1986. Distances in this
colourspace approximate, within 10% or so, differences in the CMC(l:c)
colour difference formula.

This operation generates CMC(1:1). For CMC(2:1), halve Lucs and double
Cucs.

::: seealso
    [method@Image.CMC2LCh].</doc>
        <source-position filename="libvips/include/vips/colour.h" line="181"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/LCh2UCS.c"
               line="239">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/LCh2UCS.c"
                 line="221">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/colour/LCh2UCS.c"
                 line="222">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/LCh2UCS.c"
                 line="223">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="LCh2Lab" c:identifier="vips_LCh2Lab" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/colour/LCh2Lab.c"
             line="124">Turn LCh to Lab.</doc>
        <source-position filename="libvips/include/vips/colour.h" line="146"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/LCh2Lab.c"
               line="132">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/LCh2Lab.c"
                 line="126">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/colour/LCh2Lab.c"
                 line="127">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/LCh2Lab.c"
                 line="128">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="Lab2LCh" c:identifier="vips_Lab2LCh" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/colour/Lab2LCh.c"
             line="145">Turn Lab to LCh.</doc>
        <source-position filename="libvips/include/vips/colour.h" line="149"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/Lab2LCh.c"
               line="153">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/Lab2LCh.c"
                 line="147">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/colour/Lab2LCh.c"
                 line="148">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/Lab2LCh.c"
                 line="149">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="Lab2LabQ" c:identifier="vips_Lab2LabQ" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/colour/Lab2LabQ.c"
             line="158">Convert a Lab three-band float image to LabQ ([enum@Vips.Coding.LABQ]).

::: seealso
    [method@Image.LabQ2Lab].</doc>
        <source-position filename="libvips/include/vips/colour.h" line="143"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/Lab2LabQ.c"
               line="169">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/Lab2LabQ.c"
                 line="160">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/colour/Lab2LabQ.c"
                 line="161">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/Lab2LabQ.c"
                 line="162">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="Lab2LabS" c:identifier="vips_Lab2LabS" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/colour/Lab2LabS.c"
             line="102">Turn Lab to LabS, signed 16-bit int fixed point.

::: seealso
    [method@Image.LabQ2Lab].</doc>
        <source-position filename="libvips/include/vips/colour.h" line="196"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/Lab2LabS.c"
               line="113">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/Lab2LabS.c"
                 line="104">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/colour/Lab2LabS.c"
                 line="105">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/Lab2LabS.c"
                 line="106">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="Lab2XYZ" c:identifier="vips_Lab2XYZ" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/colour/Lab2XYZ.c"
             line="202">Turn Lab to XYZ. The colour temperature defaults to D65, but can be
specified with @temp.

::: tip "Optional arguments"
    * @temp: [struct@ArrayDouble], colour temperature</doc>
        <source-position filename="libvips/include/vips/colour.h" line="152"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/Lab2XYZ.c"
               line="214">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/Lab2XYZ.c"
                 line="204">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/colour/Lab2XYZ.c"
                 line="205">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/Lab2XYZ.c"
                 line="206">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="LabQ2Lab" c:identifier="vips_LabQ2Lab" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/colour/LabQ2Lab.c"
             line="144">Unpack a LabQ ([enum@Vips.Coding.LABQ]) image to a three-band float image.

::: seealso
    [method@Image.LabQ2Lab], [method@Image.LabQ2LabS], [method@Image.rad2float].</doc>
        <source-position filename="libvips/include/vips/colour.h" line="140"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/LabQ2Lab.c"
               line="155">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/LabQ2Lab.c"
                 line="146">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/colour/LabQ2Lab.c"
                 line="147">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/LabQ2Lab.c"
                 line="148">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="LabQ2LabS"
              c:identifier="vips_LabQ2LabS"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/colour/LabQ2LabS.c"
             line="123">Unpack a LabQ ([enum@Vips.Coding.LABQ]) image to a three-band short image.

::: seealso
    [method@Image.LabS2LabQ], [method@Image.LabQ2LabS], [method@Image.rad2float].</doc>
        <source-position filename="libvips/include/vips/colour.h" line="137"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/LabQ2LabS.c"
               line="134">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/LabQ2LabS.c"
                 line="125">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/colour/LabQ2LabS.c"
                 line="126">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/LabQ2LabS.c"
                 line="127">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="LabQ2sRGB"
              c:identifier="vips_LabQ2sRGB"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/colour/LabQ2sRGB.c"
             line="571">Unpack a LabQ ([enum@Vips.Coding.LABQ]) image to a three-band short image.

::: seealso
    [method@Image.LabS2LabQ], [method@Image.LabQ2sRGB], [method@Image.rad2float].</doc>
        <source-position filename="libvips/include/vips/colour.h" line="125"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/LabQ2sRGB.c"
               line="582">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/LabQ2sRGB.c"
                 line="573">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/colour/LabQ2sRGB.c"
                 line="574">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/LabQ2sRGB.c"
                 line="575">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="LabS2Lab" c:identifier="vips_LabS2Lab" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/colour/LabS2Lab.c"
             line="98">Convert a LabS three-band signed short image to a three-band float image.

::: seealso
    [method@Image.LabS2Lab].</doc>
        <source-position filename="libvips/include/vips/colour.h" line="193"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/LabS2Lab.c"
               line="109">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/LabS2Lab.c"
                 line="100">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/colour/LabS2Lab.c"
                 line="101">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/LabS2Lab.c"
                 line="102">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="LabS2LabQ"
              c:identifier="vips_LabS2LabQ"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/colour/LabS2LabQ.c"
             line="148">Convert a LabS three-band signed short image to LabQ

::: seealso
    [method@Image.LabQ2LabS].</doc>
        <source-position filename="libvips/include/vips/colour.h" line="134"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/LabS2LabQ.c"
               line="159">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/LabS2LabQ.c"
                 line="150">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/colour/LabS2LabQ.c"
                 line="151">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/LabS2LabQ.c"
                 line="152">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="Oklab2Oklch"
              c:identifier="vips_Oklab2Oklch"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/colour/Oklab2Oklch.c"
             line="90">Turn Oklab to Oklch.</doc>
        <source-position filename="libvips/include/vips/colour.h" line="216"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/Oklab2Oklch.c"
               line="98">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/Oklab2Oklch.c"
                 line="92">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/colour/Oklab2Oklch.c"
                 line="93">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/Oklab2Oklch.c"
                 line="94">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="Oklab2XYZ"
              c:identifier="vips_Oklab2XYZ"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/colour/Oklab2XYZ.c"
             line="110">Transform Oklab to XYZ using D65 illuminant.</doc>
        <source-position filename="libvips/include/vips/colour.h" line="207"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/Oklab2XYZ.c"
               line="118">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/Oklab2XYZ.c"
                 line="112">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/colour/Oklab2XYZ.c"
                 line="113">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/Oklab2XYZ.c"
                 line="114">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="Oklch2Oklab"
              c:identifier="vips_Oklch2Oklab"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/colour/Oklch2Oklab.c"
             line="95">Turn Oklch to Oklab.</doc>
        <source-position filename="libvips/include/vips/colour.h" line="213"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/Oklch2Oklab.c"
               line="103">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/Oklch2Oklab.c"
                 line="97">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/colour/Oklch2Oklab.c"
                 line="98">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/Oklch2Oklab.c"
                 line="99">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="XYZ2CMYK" c:identifier="vips_XYZ2CMYK" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/colour/XYZ2CMYK.c"
             line="216">Turn XYZ to CMYK.

Conversion is from D65 XYZ with relative intent. If you need more control
over the process, use [method@Image.icc_export] instead.</doc>
        <source-position filename="libvips/include/vips/colour.h" line="203"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/XYZ2CMYK.c"
               line="227">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/XYZ2CMYK.c"
                 line="218">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/colour/XYZ2CMYK.c"
                 line="219">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/XYZ2CMYK.c"
                 line="220">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="XYZ2Lab" c:identifier="vips_XYZ2Lab" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/colour/XYZ2Lab.c"
             line="256">Turn XYZ to Lab, optionally specifying the colour temperature. @temp
defaults to D65.

::: tip "Optional arguments"
    * @temp: [struct@ArrayDouble], colour temperature</doc>
        <source-position filename="libvips/include/vips/colour.h" line="155"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/XYZ2Lab.c"
               line="268">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/XYZ2Lab.c"
                 line="258">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/colour/XYZ2Lab.c"
                 line="259">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/XYZ2Lab.c"
                 line="260">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="XYZ2Oklab"
              c:identifier="vips_XYZ2Oklab"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/colour/XYZ2Oklab.c"
             line="103">Transform XYZ to Oklab assuming D65 illuminant.</doc>
        <source-position filename="libvips/include/vips/colour.h" line="210"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/XYZ2Oklab.c"
               line="111">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/XYZ2Oklab.c"
                 line="105">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/colour/XYZ2Oklab.c"
                 line="106">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/XYZ2Oklab.c"
                 line="107">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="XYZ2Yxy" c:identifier="vips_XYZ2Yxy" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/colour/XYZ2Yxy.c"
             line="111">Turn XYZ to Yxy.</doc>
        <source-position filename="libvips/include/vips/colour.h" line="187"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/XYZ2Yxy.c"
               line="119">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/XYZ2Yxy.c"
                 line="113">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/colour/XYZ2Yxy.c"
                 line="114">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/XYZ2Yxy.c"
                 line="115">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="XYZ2scRGB"
              c:identifier="vips_XYZ2scRGB"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/colour/XYZ2scRGB.c"
             line="116">Turn XYZ to scRGB.</doc>
        <source-position filename="libvips/include/vips/colour.h" line="159"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/XYZ2scRGB.c"
               line="124">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/XYZ2scRGB.c"
                 line="118">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/colour/XYZ2scRGB.c"
                 line="119">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/XYZ2scRGB.c"
                 line="120">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="Yxy2XYZ" c:identifier="vips_Yxy2XYZ" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/colour/Yxy2XYZ.c"
             line="116">Turn XYZ to Yxy.</doc>
        <source-position filename="libvips/include/vips/colour.h" line="190"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/Yxy2XYZ.c"
               line="124">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/Yxy2XYZ.c"
                 line="118">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/colour/Yxy2XYZ.c"
                 line="119">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/Yxy2XYZ.c"
                 line="120">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="abs" c:identifier="vips_abs" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/abs.c"
             line="213">This operation finds the absolute value of an image. It does a copy for
unsigned integer types, negate for negative values in
signed integer types, [`fabs()`](man:fabs(3)) for
float types, and calculates modulus for complex
types.

::: seealso
    [method@Image.sign].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="231"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/abs.c"
               line="228">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/abs.c"
                 line="215">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/abs.c"
                 line="216">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/abs.c"
                 line="217">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="acos" c:identifier="vips_acos" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/math.c"
             line="403">Perform [enum@Vips.OperationMath.ACOS] on an image. See [method@Image.math].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="275"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/math.c"
               line="411">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="405">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="406">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="407">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="acosh" c:identifier="vips_acosh" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/math.c"
             line="541">Perform [enum@Vips.OperationMath.ACOSH] on an image. See [method@Image.math].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="305"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/math.c"
               line="549">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="543">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="544">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="545">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="add" c:identifier="vips_add" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/add.c"
             line="190">This operation calculates @in1 + @in2 and writes the result to @out.

If the images differ in size, the smaller image is enlarged to match the
larger by adding zero pixels along the bottom and right.

If the number of bands differs, one of the images
must have one band. In this case, an n-band image is formed from the
one-band image by joining n copies of the one-band image together, and then
the two n-band images are operated upon.

The two input images are cast up to the smallest common format (see table
Smallest common format in
[arithmetic](libvips-arithmetic.html)), then the
following table is used to determine the output type:

## [method@Image.add] type promotion

| input type     | output type    |
|----------------|----------------|
| uchar          | ushort         |
| char           | short          |
| ushort         | uint           |
| short          | int            |
| uint           | uint           |
| int            | int            |
| float          | float          |
| double         | double         |
| complex        | complex        |
| double complex | double complex |

In other words, the output type is just large enough to hold the whole
range of possible values.

::: seealso
    [method@Image.subtract], [method@Image.linear].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="195"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/add.c"
               line="233">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/add.c"
                 line="192">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/add.c"
                 line="193">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/add.c"
                 line="194">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/add.c"
                 line="195">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="addalpha" c:identifier="vips_addalpha" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/addalpha.c"
             line="101">Append an alpha channel.

::: seealso
    [method@Image.hasalpha].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="327"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/addalpha.c"
               line="112">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/addalpha.c"
                 line="103">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/addalpha.c"
                 line="104">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/addalpha.c"
                 line="105">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="affine" c:identifier="vips_affine" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/resample/affine.c"
             line="720">This operator performs an affine transform on an image using @interpolate.

The transform is:

```
X = @a * (x + @idx) + @b * (y + @idy) + @odx
Y = @c * (x + @idx) + @d * (y + @idy) + @doy
```

where:

```
x and y are the coordinates in input image.
X and Y are the coordinates in output image.
(0,0) is the upper left corner.
```

The section of the output space defined by @oarea is written to
@out. @oarea is a four-element int array of left, top, width, height.
By default @oarea is just large enough to cover the whole of the
transformed input image.

By default, new pixels are filled with @background. This defaults to
zero (black). You can set other extend types with @extend.
[enum@Vips.Extend.COPY] is better for image upsizing.

@interpolate defaults to bilinear.

@idx, @idy, @odx, @ody default to zero.

Image are normally treated as unpremultiplied, so this operation can be
used directly on PNG images. If your images have been through
[method@Image.premultiply], set @premultiplied.

This operation does not change xres or yres. The image resolution needs to
be updated by the application.

::: tip "Optional arguments"
    * @interpolate: [class@Interpolate], interpolate pixels with this
    * @oarea: [struct@ArrayInt], output rectangle
    * @idx: `gdouble`, input horizontal offset
    * @idy: `gdouble`, input vertical offset
    * @odx: `gdouble`, output horizontal offset
    * @ody: `gdouble`, output vertical offset
    * @extend: [enum@Extend], how to generate new pixels
    * @background: [struct@ArrayDouble] colour for new pixels
    * @premultiplied: `gboolean`, images are already premultiplied

::: seealso
    [method@Image.shrink], [method@Image.resize], [class@Interpolate].</doc>
        <source-position filename="libvips/include/vips/resample.h"
                         line="105"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/resample/affine.c"
               line="781">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/affine.c"
                 line="722">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/resample/affine.c"
                 line="723">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/affine.c"
                 line="724">transformation matrix coefficient</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/affine.c"
                 line="725">transformation matrix coefficient</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/affine.c"
                 line="726">transformation matrix coefficient</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="d" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/affine.c"
                 line="727">transformation matrix coefficient</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/affine.c"
                 line="728">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="andimage" c:identifier="vips_andimage" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/boolean.c"
             line="342">Perform [enum@Vips.OperationBoolean.AND] on a pair of images. See
[method@Image.boolean].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="426"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/boolean.c"
               line="352">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="344">left-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="345">right-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="346">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="347">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="andimage_const"
              c:identifier="vips_andimage_const"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/boolean.c"
             line="647">Perform [enum@Vips.OperationBoolean.AND] on an image and an array of constants.
See [method@Image.boolean_const].

::: seealso
    [method@Image.boolean], [method@Image.boolean_const1].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="446"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/boolean.c"
               line="661">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="649">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="650">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="651">array of constants</doc>
            <array length="2" zero-terminated="0" c:type="const double*">
              <type name="gdouble" c:type="double"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="652">number of constants in @c</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="653">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="andimage_const1"
              c:identifier="vips_andimage_const1"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/boolean.c"
             line="827">Perform [enum@Vips.OperationBoolean.AND] on an image and a constant.
See [method@Image.boolean_const1].

::: seealso
    [method@Image.boolean], [method@Image.boolean_const].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="470"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/boolean.c"
               line="840">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="829">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="830">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="831">constant</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="832">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="asin" c:identifier="vips_asin" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/math.c"
             line="380">Perform [enum@Vips.OperationMath.ASIN] on an image. See [method@Image.math].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="272"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/math.c"
               line="388">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="382">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="383">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="384">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="asinh" c:identifier="vips_asinh" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/math.c"
             line="518">Perform [enum@Vips.OperationMath.ASINH] on an image. See [method@Image.math].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="302"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/math.c"
               line="526">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="520">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="521">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="522">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="atan" c:identifier="vips_atan" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/math.c"
             line="426">Perform [enum@Vips.OperationMath.ATAN] on an image. See [method@Image.math].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="278"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/math.c"
               line="434">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="428">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="429">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="430">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="atan2" c:identifier="vips_atan2" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/math2.c"
             line="358">Perform [enum@Vips.OperationMath2.ATAN2] on a pair of images. See
[method@Image.math2].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="496"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/math2.c"
               line="368">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="360">left-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="361">right-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="362">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="363">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="atan2_const"
              c:identifier="vips_atan2_const"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/math2.c"
             line="603">Perform [enum@Vips.OperationMath2.ATAN2] on an image and a constant. See
[method@Image.math2_const].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="511"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/math2.c"
               line="614">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="605">left-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="606">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="607">array of constants</doc>
            <array length="2" zero-terminated="0" c:type="const double*">
              <type name="gdouble" c:type="double"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="608">number of constants in @c</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="609">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="atan2_const1"
              c:identifier="vips_atan2_const1"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/math2.c"
             line="709">Perform [enum@Vips.OperationMath2.ATAN2] on an image and a constant. See
[method@Image.math2_const].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="525"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/math2.c"
               line="719">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="711">left-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="712">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="713">constant</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="714">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="atanh" c:identifier="vips_atanh" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/math.c"
             line="564">Perform [enum@Vips.OperationMath.ATANH] on an image. See [method@Image.math].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="308"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/math.c"
               line="572">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="566">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="567">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="568">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="autorot" c:identifier="vips_autorot" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/autorot.c"
             line="234">Look at the image metadata and rotate and flip the image to make it
upright. The [const@META_ORIENTATION] tag is removed from @out to prevent
accidental double rotation.

Read @angle to find the amount the image was rotated by. Read @flip to
see if the image was also flipped.

::: tip "Optional arguments"
    * @angle: [enum@Angle], output, the image was rotated by
    * @flip: `gboolean`, output, whether the image was flipped</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="220"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/autorot.c"
               line="251">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/autorot.c"
                 line="236">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/autorot.c"
                 line="237">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/autorot.c"
                 line="238">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="autorot_remove_angle"
              c:identifier="vips_autorot_remove_angle">
        <doc xml:space="preserve"
             filename="libvips/conversion/autorot.c"
             line="88">Remove the orientation tag on @image. Also remove any exif orientation tags.
You must [method@Image.copy] the image before calling this function since it
modifies metadata.</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="218"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/autorot.c"
                 line="90">image to remove orientation from</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="avg" c:identifier="vips_avg" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/avg.c"
             line="247">This operation finds the average value in an image. It operates on all
bands of the input image: use [method@Image.stats] if you need to calculate an
average for each band. For complex images, return the average modulus.

::: seealso
    [method@Image.stats], [method@Image.bandmean], [method@Image.deviate], [method@Image.rank]</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="529"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/avg.c"
               line="260">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/avg.c"
                 line="249">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/avg.c"
                 line="250">output pixel average</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/avg.c"
                 line="251">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="bandand" c:identifier="vips_bandand" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/bandbool.c"
             line="300">Perform [enum@Vips.OperationBoolean.AND] on an image. See
[method@Image.bandbool].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="299"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/bandbool.c"
               line="309">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/bandbool.c"
                 line="302">left-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/bandbool.c"
                 line="303">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/bandbool.c"
                 line="304">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="bandbool" c:identifier="vips_bandbool" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/bandbool.c"
             line="259">Perform various boolean operations across the bands of an image. For
example, a three-band uchar image operated on with
[enum@Vips.OperationBoolean.AND] will produce a one-band uchar image where each
pixel is the bitwise and of the band elements of the corresponding pixel in
the input image.

The output image is the same format as the input image for integer
types. Float types are cast to int before processing. Complex types are not
supported.

The output image always has one band.

This operation is useful in conjunction with [method@Image.relational]. You can use
it to see if all image bands match exactly.

::: seealso
    [method@Image.boolean_const].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="295"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/bandbool.c"
               line="284">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/bandbool.c"
                 line="261">left-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/bandbool.c"
                 line="262">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="boolean" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/bandbool.c"
                 line="263">boolean operation to perform</doc>
            <type name="OperationBoolean" c:type="VipsOperationBoolean"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/bandbool.c"
                 line="264">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="bandeor" c:identifier="vips_bandeor" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/bandbool.c"
             line="348">Perform [enum@Vips.OperationBoolean.EOR] on an image. See
[method@Image.bandbool].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="305"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/bandbool.c"
               line="357">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/bandbool.c"
                 line="350">left-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/bandbool.c"
                 line="351">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/bandbool.c"
                 line="352">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="bandfold" c:identifier="vips_bandfold" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/bandfold.c"
             line="182">Fold up an image horizontally: width is collapsed into bands.
Use @factor to set how much to fold by: @factor 3, for example, will make
the output image three times narrower than the input, and with three times
as many bands. By default the whole of the input width is folded up.

::: tip "Optional arguments"
    * @factor: `gint`, fold by this factor

::: seealso
    [ctor@Image.csvload], [method@Image.bandunfold].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="288"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/bandfold.c"
               line="199">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/bandfold.c"
                 line="184">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/bandfold.c"
                 line="185">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/bandfold.c"
                 line="186">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="bandjoin2"
              c:identifier="vips_bandjoin2"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/bandjoin.c"
             line="267">Join a pair of images together, bandwise. See [func@Image.bandjoin].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="276"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/bandjoin.c"
               line="276">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/bandjoin.c"
                 line="269">first input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="in2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/bandjoin.c"
                 line="270">second input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/bandjoin.c"
                 line="271">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/bandjoin.c"
                 line="272">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="bandjoin_const"
              c:identifier="vips_bandjoin_const"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/bandjoin.c"
             line="471">Append a set of constant bands to an image.

::: seealso
    [func@Image.bandjoin].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="279"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/bandjoin.c"
               line="484">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/bandjoin.c"
                 line="473">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/bandjoin.c"
                 line="474">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/bandjoin.c"
                 line="475">array of constants to append</doc>
            <array length="2" zero-terminated="0" c:type="double*">
              <type name="gdouble" c:type="double"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/bandjoin.c"
                 line="476">number of constants</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/bandjoin.c"
                 line="477">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="bandjoin_const1"
              c:identifier="vips_bandjoin_const1"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/bandjoin.c"
             line="499">Append a single constant band to an image.</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="282"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/bandjoin.c"
               line="508">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/bandjoin.c"
                 line="501">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/bandjoin.c"
                 line="502">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/bandjoin.c"
                 line="503">constant to append</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/bandjoin.c"
                 line="504">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="bandmean" c:identifier="vips_bandmean" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/bandmean.c"
             line="223">This operation writes a one-band image where each pixel is the average of
the bands for that pixel in the input image. The output band format is
the same as the input band format. Integer types use round-to-nearest
averaging.

::: seealso
    [method@Image.add], [method@Image.avg], [method@Image.recomb]</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="308"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/bandmean.c"
               line="237">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/bandmean.c"
                 line="225">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/bandmean.c"
                 line="226">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/bandmean.c"
                 line="227">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="bandor" c:identifier="vips_bandor" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/bandbool.c"
             line="324">Perform [enum@Vips.OperationBoolean.OR] on an image. See
[method@Image.bandbool].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="302"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/bandbool.c"
               line="333">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/bandbool.c"
                 line="326">left-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/bandbool.c"
                 line="327">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/bandbool.c"
                 line="328">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="bandunfold"
              c:identifier="vips_bandunfold"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/bandunfold.c"
             line="185">Unfold image bands into x axis.
Use @factor to set how much to unfold by: @factor 3, for example, will make
the output image three times wider than the input, and with one third
as many bands. By default, all bands are unfolded.

::: tip "Optional arguments"
    * @factor: `gint`, unfold by this factor

::: seealso
    [ctor@Image.csvload], [method@Image.bandfold].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="291"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/bandunfold.c"
               line="202">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/bandunfold.c"
                 line="187">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/bandunfold.c"
                 line="188">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/bandunfold.c"
                 line="189">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="boolean" c:identifier="vips_boolean" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/boolean.c"
             line="297">Perform various boolean operations on pairs of images.

The output image is the same format as the upcast input images for integer
types. Float types are cast to int before processing. Complex types are not
supported.

If the images differ in size, the smaller image is enlarged to match the
larger by adding zero pixels along the bottom and right.

If the number of bands differs, one of the images
must have one band. In this case, an n-band image is formed from the
one-band image by joining n copies of the one-band image together, and then
the two n-band images are operated upon.

The two input images are cast up to the smallest common format (see table
Smallest common format in
[arithmetic](libvips-arithmetic.html)).

::: seealso
    [method@Image.boolean_const].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="422"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/boolean.c"
               line="326">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="299">left-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="300">right-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="301">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="boolean" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="302">boolean operation to perform</doc>
            <type name="OperationBoolean" c:type="VipsOperationBoolean"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="303">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="boolean_const"
              c:identifier="vips_boolean_const"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/boolean.c"
             line="607">Perform various boolean operations on an image against an array of
constants.

The output type is always uchar, with 0 for `FALSE` and 255 for `TRUE`.

If the array of constants has just one element, that constant is used for
all image bands. If the array has more than one element and they have
the same number of elements as there are bands in the image, then
one array element is used for each band. If the arrays have more than one
element and the image only has a single band, the result is a many-band
image where each band corresponds to one array element.

::: seealso
    [method@Image.boolean], [method@Image.boolean_const1].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="442"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/boolean.c"
               line="631">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="609">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="610">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="boolean" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="611">boolean operation to perform</doc>
            <type name="OperationBoolean" c:type="VipsOperationBoolean"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="612">array of constants</doc>
            <array length="3" zero-terminated="0" c:type="const double*">
              <type name="gdouble" c:type="double"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="613">number of constants in @c</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="614">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="boolean_const1"
              c:identifier="vips_boolean_const1"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/boolean.c"
             line="797">Perform various boolean operations on an image with a single constant. See
[method@Image.boolean_const].

::: seealso
    [method@Image.boolean], [method@Image.boolean_const].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="466"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/boolean.c"
               line="811">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="799">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="800">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="boolean" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="801">boolean operation to perform</doc>
            <type name="OperationBoolean" c:type="VipsOperationBoolean"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="802">constant</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="803">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="buildlut" c:identifier="vips_buildlut" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/create/buildlut.c"
             line="274">This operation builds a lookup table from a set of points. Intermediate
values are generated by piecewise linear interpolation. The lookup table is
always of type [enum@Vips.BandFormat.DOUBLE], use [method@Image.cast] to
change it to the type you need.

For example, consider this 2 x 2 matrix of (x, y) coordinates:

```
2 2
0   0
255 100
```

We then generate a 1 x 256 element LUT like this:

| Index | Value |
|-------|-------|
| 0     | 0     |
| 1     | 0.4   |
| etc.  | 0.4   |
| 255   | 100   |

This is then written as the output image, with the left column giving the
index in the image to place the value.

The (x, y) points don't need to be sorted: we do that. You can have
several Ys, each becomes a band in the output LUT. You don't need to
start at zero, any integer will do, including negatives.

::: seealso
    [ctor@Image.identity], [method@Image.invertlut], [method@Image.cast],
    [method@Image.maplut].</doc>
        <source-position filename="libvips/include/vips/create.h" line="98"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/buildlut.c"
               line="313">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/create/buildlut.c"
                 line="276">input matrix</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/create/buildlut.c"
                 line="277">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/create/buildlut.c"
                 line="278">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="byteswap" c:identifier="vips_byteswap" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/byteswap.c"
             line="249">Swap the byte order in an image.

::: seealso
    [ctor@Image.rawload].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="269"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/byteswap.c"
               line="260">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/byteswap.c"
                 line="251">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/byteswap.c"
                 line="252">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/byteswap.c"
                 line="253">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="canny" c:identifier="vips_canny" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/convolution/canny.c"
             line="475">Find edges by Canny's method: The maximum of the derivative of the gradient
in the direction of the gradient. Output is float, except for uchar input,
where output is uchar, and double input, where output is double. Non-complex
images only.

Use @sigma to control the scale over which gradient is measured. 1.4 is
usually a good value.

Use @precision to set the precision of edge detection. For uchar images,
setting this to [enum@Vips.Precision.INTEGER] will make edge detection much
faster, but sacrifice some sensitivity.

You will probably need to process the output further to eliminate weak
edges.

::: tip "Optional arguments"
    * @sigma: `gdouble`, sigma for gaussian blur
    * @precision: [enum@Precision], calculation accuracy

::: seealso
    [method@Image.sobel].</doc>
        <source-position filename="libvips/include/vips/convolution.h"
                         line="94"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/convolution/canny.c"
               line="503">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/convolution/canny.c"
                 line="477">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/convolution/canny.c"
                 line="478">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/convolution/canny.c"
                 line="479">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="case" c:identifier="vips_case" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/histogram/case.c"
             line="277">Use values in @index to select pixels from @cases.

@index must have one band. @cases can have up to 256 elements. Values in
@index greater than or equal to @n use the final image in @cases. The
images in @cases must have either one band or the same number of bands.
The output image is the same size as @index. Images in @cases are
expanded to the smallest common format and number of bands.

Combine this with [func@Image.switch] to make something like a case
statement or a multi-way [method@Image.ifthenelse].

::: seealso
    [method@Image.maplut], [func@Image.switch], [method@Image.ifthenelse].</doc>
        <source-position filename="libvips/include/vips/histogram.h"
                         line="77"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/histogram/case.c"
               line="299">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/histogram/case.c"
                 line="279">index image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="cases" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/histogram/case.c"
                 line="280">array of case images</doc>
            <array length="2" zero-terminated="0" c:type="VipsImage**">
              <type name="Image" c:type="VipsImage*"/>
            </array>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/histogram/case.c"
                 line="281">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/histogram/case.c"
                 line="282">number of case images</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/histogram/case.c"
                 line="283">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="cast" c:identifier="vips_cast" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/cast.c"
             line="560">Convert @in to @format. You can convert between any pair of formats.
Floats are truncated (not rounded). Out of range values are clipped.

Casting from complex to real returns the real part.

If @shift is `TRUE`, integer values are shifted up and down. For example,
casting from unsigned 8 bit to unsigned 16 bit would
shift every value left by 8 bits. The bottom bit is copied into the new
bits, so 255 would become 65535.

::: tip "Optional arguments"
    * @shift: `gboolean`, integer values are shifted

::: seealso
    [method@Image.scale], [method@Image.complexform], [method@Image.real],
    [method@Image.imag], [method@Image.cast_uchar], [method@Image.msb].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="230"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/cast.c"
               line="584">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/cast.c"
                 line="562">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/cast.c"
                 line="563">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/cast.c"
                 line="564">format to convert to</doc>
            <type name="BandFormat" c:type="VipsBandFormat"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/cast.c"
                 line="565">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="cast_char"
              c:identifier="vips_cast_char"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/cast.c"
             line="625">Convert @in to [enum@Vips.BandFormat.CHAR]. See [method@Image.cast].

::: tip "Optional arguments"
    * @shift: `gboolean`, integer values are shifted</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="236"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/cast.c"
               line="636">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/cast.c"
                 line="627">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/cast.c"
                 line="628">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/cast.c"
                 line="629">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="cast_complex"
              c:identifier="vips_cast_complex"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/cast.c"
             line="801">Convert @in to [enum@Vips.BandFormat.COMPLEX]. See [method@Image.cast].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="257"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/cast.c"
               line="809">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/cast.c"
                 line="803">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/cast.c"
                 line="804">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/cast.c"
                 line="805">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="cast_double"
              c:identifier="vips_cast_double"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/cast.c"
             line="778">Convert @in to [enum@Vips.BandFormat.DOUBLE]. See [method@Image.cast].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="254"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/cast.c"
               line="786">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/cast.c"
                 line="780">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/cast.c"
                 line="781">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/cast.c"
                 line="782">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="cast_dpcomplex"
              c:identifier="vips_cast_dpcomplex"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/cast.c"
             line="824">Convert @in to [enum@Vips.BandFormat.DPCOMPLEX]. See [method@Image.cast].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="260"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/cast.c"
               line="832">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/cast.c"
                 line="826">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/cast.c"
                 line="827">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/cast.c"
                 line="828">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="cast_float"
              c:identifier="vips_cast_float"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/cast.c"
             line="755">Convert @in to [enum@Vips.BandFormat.FLOAT]. See [method@Image.cast].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="251"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/cast.c"
               line="763">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/cast.c"
                 line="757">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/cast.c"
                 line="758">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/cast.c"
                 line="759">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="cast_int" c:identifier="vips_cast_int" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/cast.c"
             line="729">Convert @in to [enum@Vips.BandFormat.INT]. See [method@Image.cast].

::: tip "Optional arguments"
    * @shift: `gboolean`, integer values are shifted</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="248"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/cast.c"
               line="740">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/cast.c"
                 line="731">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/cast.c"
                 line="732">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/cast.c"
                 line="733">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="cast_short"
              c:identifier="vips_cast_short"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/cast.c"
             line="677">Convert @in to [enum@Vips.BandFormat.SHORT]. See [method@Image.cast].

::: tip "Optional arguments"
    * @shift: `gboolean`, integer values are shifted</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="242"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/cast.c"
               line="688">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/cast.c"
                 line="679">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/cast.c"
                 line="680">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/cast.c"
                 line="681">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="cast_uchar"
              c:identifier="vips_cast_uchar"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/cast.c"
             line="599">Convert @in to [enum@Vips.BandFormat.UCHAR]. See [method@Image.cast].

::: tip "Optional arguments"
    * @shift: `gboolean`, integer values are shifted</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="233"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/cast.c"
               line="610">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/cast.c"
                 line="601">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/cast.c"
                 line="602">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/cast.c"
                 line="603">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="cast_uint"
              c:identifier="vips_cast_uint"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/cast.c"
             line="703">Convert @in to [enum@Vips.BandFormat.UINT]. See [method@Image.cast].

::: tip "Optional arguments"
    * @shift: `gboolean`, integer values are shifted</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="245"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/cast.c"
               line="714">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/cast.c"
                 line="705">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/cast.c"
                 line="706">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/cast.c"
                 line="707">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="cast_ushort"
              c:identifier="vips_cast_ushort"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/cast.c"
             line="651">Convert @in to [enum@Vips.BandFormat.USHORT]. See [method@Image.cast].

::: tip "Optional arguments"
    * @shift: `gboolean`, integer values are shifted</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="239"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/cast.c"
               line="662">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/cast.c"
                 line="653">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/cast.c"
                 line="654">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/cast.c"
                 line="655">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="ceil" c:identifier="vips_ceil" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/round.c"
             line="257">Round to an integral value with [enum@Vips.OperationRound.CEIL]. See
[method@Image.round].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="252"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/round.c"
               line="266">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/round.c"
                 line="259">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/round.c"
                 line="260">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/round.c"
                 line="261">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="clamp" c:identifier="vips_clamp" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/clamp.c"
             line="183">This operation clamps pixel values to a range, by default 0 - 1.

Use @min and @max to change the range.

::: tip "Optional arguments"
    * @min: `gdouble`, minimum value
    * @max: `gdouble`, maximum value

::: seealso
    [method@Image.sign], [method@Image.abs], [ctor@Image.sdf].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="237"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/clamp.c"
               line="200">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/clamp.c"
                 line="185">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/clamp.c"
                 line="186">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/clamp.c"
                 line="187">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="colourspace"
              c:identifier="vips_colourspace"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/colour/colourspace.c"
             line="656">This operation looks at the interpretation field of @in (or uses
@source_space, if set) and runs
a set of colourspace conversion functions to move it to @space.

For example, given an image tagged as [enum@Vips.Interpretation.YXY], running
[method@Image.colourspace] with @space set to
[enum@Vips.Interpretation.LAB] will convert with [method@Image.Yxy2XYZ]
and [method@Image.XYZ2Lab].

::: tip "Optional arguments"
    * @source_space: [enum@Interpretation], input colour space

::: seealso
    [method@Image.colourspace_issupported],
    [method@Image.guess_interpretation].</doc>
        <source-position filename="libvips/include/vips/colour.h" line="120"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/colourspace.c"
               line="679">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/colourspace.c"
                 line="658">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/colour/colourspace.c"
                 line="659">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="space" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/colourspace.c"
                 line="660">convert to this colour space</doc>
            <type name="Interpretation" c:type="VipsInterpretation"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/colourspace.c"
                 line="661">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="colourspace_issupported"
              c:identifier="vips_colourspace_issupported">
        <doc xml:space="preserve"
             filename="libvips/colour/colourspace.c"
             line="502">Test if @image is in a colourspace that [method@Image.colourspace] can process.</doc>
        <source-position filename="libvips/include/vips/colour.h" line="118"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/colourspace.c"
               line="508">`TRUE` if @image is in a supported colourspace.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/colourspace.c"
                 line="504">input image</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="compass" c:identifier="vips_compass" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/convolution/compass.c"
             line="216">This convolves @in with @mask @times times, rotating @mask by @angle
each time. By default, it comvolves twice, rotating by 90 degrees, taking
the maximum result.

::: tip "Optional arguments"
    * @times: `gint`, how many times to rotate and convolve
    * @angle: [enum@Angle45], rotate mask by this much between colvolutions
    * @combine: [enum@Combine], combine results like this
    * @precision: [enum@Precision], precision for blur, default float
    * @layers: `gint`, number of layers for approximation
    * @cluster: `gint`, cluster lines closer than this distance

::: seealso
    [method@Image.conv].</doc>
        <source-position filename="libvips/include/vips/convolution.h"
                         line="68"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/convolution/compass.c"
               line="238">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/convolution/compass.c"
                 line="218">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/convolution/compass.c"
                 line="219">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="mask" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/convolution/compass.c"
                 line="220">convolve with this mask</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/convolution/compass.c"
                 line="221">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="complex" c:identifier="vips_complex" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/complex.c"
             line="277">Perform various operations on complex images.

Angles are expressed in degrees. The output type is complex unless the
input is double or dpcomplex, in which case the output is dpcomplex.</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="312"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/complex.c"
               line="289">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/complex.c"
                 line="279">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/complex.c"
                 line="280">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="cmplx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/complex.c"
                 line="281">complex operation to perform</doc>
            <type name="OperationComplex" c:type="VipsOperationComplex"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/complex.c"
                 line="282">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="complex2" c:identifier="vips_complex2" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/complex.c"
             line="558">Perform various binary operations on complex images.

Angles are expressed in degrees. The output type is complex unless the
input is double or dpcomplex, in which case the output is dpcomplex.</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="326"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/complex.c"
               line="571">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/complex.c"
                 line="560">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/complex.c"
                 line="561">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/complex.c"
                 line="562">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="cmplx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/complex.c"
                 line="563">complex2 operation to perform</doc>
            <type name="OperationComplex2" c:type="VipsOperationComplex2"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/complex.c"
                 line="564">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="complexform"
              c:identifier="vips_complexform"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/complex.c"
             line="992">Compose two real images to make a complex image. If either @left or @right
are [enum@Vips.BandFormat.DOUBLE], @out is [enum@Vips.BandFormat.DPCOMPLEX]. Otherwise @out
is [enum@Vips.BandFormat.COMPLEX]. @left becomes the real component of @out and
@right the imaginary.

If the number of bands differs, one of the images
must have one band. In this case, an n-band image is formed from the
one-band image by joining n copies of the one-band image together, and then
the two n-band images are operated upon.

::: seealso
    [method@Image.complexget].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="345"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/complex.c"
               line="1012">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/complex.c"
                 line="994">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/complex.c"
                 line="995">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/complex.c"
                 line="996">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/complex.c"
                 line="997">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="complexget"
              c:identifier="vips_complexget"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/complex.c"
             line="791">Get components of complex images.

The output type is the same as the input type, except [enum@Vips.BandFormat.COMPLEX]
becomes [enum@Vips.BandFormat.FLOAT] and [enum@Vips.BandFormat.DPCOMPLEX] becomes
[enum@Vips.BandFormat.DOUBLE].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="334"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/complex.c"
               line="804">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/complex.c"
                 line="793">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/complex.c"
                 line="794">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="get" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/complex.c"
                 line="795">complex operation to perform</doc>
            <type name="OperationComplexget" c:type="VipsOperationComplexget"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/complex.c"
                 line="796">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="composite2"
              c:identifier="vips_composite2"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="106">Composite @overlay on top of @base with @mode. See [func@Image.composite].

::: tip "Optional arguments"
    * @compositing_space: [enum@Interpretation] to composite in
    * @premultiplied: `gboolean`, images are already premultiplied
    * @x: `gint`, position of overlay
    * @y: `gint`, position of overlay</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="339"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/conversion.c"
               line="122">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="base" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/conversion.c"
                 line="108">first input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="overlay" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/conversion.c"
                 line="109">second input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/conversion.c"
                 line="110">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/conversion.c"
                 line="111">composite with this blend mode</doc>
            <type name="BlendMode" c:type="VipsBlendMode"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/conversion.c"
                 line="112">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="conj" c:identifier="vips_conj" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/complex.c"
             line="350">Perform [enum@Vips.OperationComplex.CONJ] on an image. See [method@Image.complex].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="322"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/complex.c"
               line="358">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/complex.c"
                 line="352">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/complex.c"
                 line="353">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/complex.c"
                 line="354">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="conv" c:identifier="vips_conv" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/convolution/conv.c"
             line="163">Perform a convolution of @in with @mask.

Each output pixel is calculated as:

```
sigma[i]{pixel[i] * mask[i]} / scale + offset
```

where scale and offset are part of @mask.

By default, @precision is
[enum@Vips.Precision.FLOAT]. The output image
is always [enum@Vips.BandFormat.FLOAT] unless @in is
[enum@Vips.BandFormat.DOUBLE], in which case @out is also
[enum@Vips.BandFormat.DOUBLE].

If @precision is [enum@Vips.Precision.INTEGER], then elements of @mask
are converted to integers before convolution, using `rint()`,
and the output image always has the same [enum@BandFormat] as the input
image.

For [enum@Vips.BandFormat.UCHAR] images and [enum@Vips.Precision.INTEGER]
@precision, [method@Image.conv] uses a fast vector path based on
half-float arithmetic. This can produce slightly different results.
Disable the vector path with `--vips-novector` or `VIPS_NOVECTOR` or
[func@vector_set_enabled].

If @precision is [enum@Vips.Precision.APPROXIMATE] then, like
[enum@Vips.Precision.INTEGER], @mask is converted to int before
convolution, and the output image
always has the same [enum@BandFormat] as the input image.

Larger values for @layers give more accurate
results, but are slower. As @layers approaches the mask radius, the
accuracy will become close to exact convolution and the speed will drop to
match. For many large masks, such as Gaussian, @n_layers need be only 10% of
this value and accuracy will still be good.

Smaller values of @cluster will give more accurate results, but be slower
and use more memory. 10% of the mask radius is a good rule of thumb.

::: tip "Optional arguments"
    * @precision: [enum@Precision], calculation accuracy
    * @layers: `gint`, number of layers for approximation
    * @cluster: `gint`, cluster lines closer than this distance

::: seealso
    [method@Image.convsep].</doc>
        <source-position filename="libvips/include/vips/convolution.h"
                         line="49"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/convolution/conv.c"
               line="219">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/convolution/conv.c"
                 line="165">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/convolution/conv.c"
                 line="166">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="mask" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/convolution/conv.c"
                 line="167">convolve with this mask</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/convolution/conv.c"
                 line="168">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="conva" c:identifier="vips_conva" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/convolution/conva.c"
             line="1344">Perform an approximate integer convolution of @in with @mask.
This is a low-level operation, see [method@Image.conv] for something more
convenient.

The output image
always has the same [enum@BandFormat] as the input image.
Elements of @mask are converted to
integers before convolution.

Larger values for @layers give more accurate
results, but are slower. As @layers approaches the mask radius, the
accuracy will become close to exact convolution and the speed will drop to
match. For many large masks, such as Gaussian, @layers need be only 10% of
this value and accuracy will still be good.

Smaller values of @cluster will give more accurate results, but be slower
and use more memory. 10% of the mask radius is a good rule of thumb.

::: tip "Optional arguments"
    * @layers: `gint`, number of layers for approximation
    * @cluster: `gint`, cluster lines closer than this distance

::: seealso
    [method@Image.conv].</doc>
        <source-position filename="libvips/include/vips/convolution.h"
                         line="58"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/convolution/conva.c"
               line="1376">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/convolution/conva.c"
                 line="1346">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/convolution/conva.c"
                 line="1347">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="mask" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/convolution/conva.c"
                 line="1348">convolution mask</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/convolution/conva.c"
                 line="1349">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="convasep" c:identifier="vips_convasep" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/convolution/convasep.c"
             line="932">Approximate separable integer convolution. This is a low-level operation, see
[method@Image.convsep] for something more convenient.

The image is convolved twice: once with @mask and then again with @mask
rotated by 90 degrees.
@mask must be 1xn or nx1 elements.
Elements of @mask are converted to
integers before convolution.

Larger values for @layers give more accurate
results, but are slower. As @layers approaches the mask radius, the
accuracy will become close to exact convolution and the speed will drop to
match. For many large masks, such as Gaussian, @layers need be only 10% of
this value and accuracy will still be good.

The output image
always has the same [enum@BandFormat] as the input image.

::: tip "Optional arguments"
    * @layers: `gint`, number of layers for approximation

::: seealso
    [method@Image.convsep].</doc>
        <source-position filename="libvips/include/vips/convolution.h"
                         line="64"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/convolution/convasep.c"
               line="963">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/convolution/convasep.c"
                 line="934">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/convolution/convasep.c"
                 line="935">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="mask" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/convolution/convasep.c"
                 line="936">convolve with this mask</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/convolution/convasep.c"
                 line="937">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="convf" c:identifier="vips_convf" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/convolution/convf.c"
             line="386">Convolution. This is a low-level operation, see [method@Image.conv] for something
more convenient.

Perform a convolution of @in with @mask.
Each output pixel is
calculated as sigma[i]{pixel[i] * mask[i]} / scale + offset, where scale
and offset are part of @mask.

The convolution is performed with floating-point arithmetic. The output image
is always [enum@Vips.BandFormat.FLOAT] unless @in is [enum@Vips.BandFormat.DOUBLE], in which case
@out is also [enum@Vips.BandFormat.DOUBLE].

::: seealso
    [method@Image.conv].</doc>
        <source-position filename="libvips/include/vips/convolution.h"
                         line="52"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/convolution/convf.c"
               line="408">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/convolution/convf.c"
                 line="388">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/convolution/convf.c"
                 line="389">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="mask" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/convolution/convf.c"
                 line="390">convolve with this mask</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/convolution/convf.c"
                 line="391">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="convi" c:identifier="vips_convi" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/convolution/convi.c"
             line="1260">Integer convolution. This is a low-level operation, see [method@Image.conv] for
something more convenient.

@mask is converted to an integer mask with `rint()` of each element, rint of
scale and rint of offset. Each output pixel is then calculated as

```
sigma[i]{pixel[i] * mask[i]} / scale + offset
```

The output image always has the same [enum@BandFormat] as the input image.

For [enum@Vips.BandFormat.UCHAR] images, [method@Image.convi] uses a fast vector path based on
half-float arithmetic. This can produce slightly different results.
Disable the vector path with `--vips-novector` or `VIPS_NOVECTOR` or
[func@vector_set_enabled].

::: seealso
    [method@Image.conv].</doc>
        <source-position filename="libvips/include/vips/convolution.h"
                         line="55"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/convolution/convi.c"
               line="1287">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/convolution/convi.c"
                 line="1262">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/convolution/convi.c"
                 line="1263">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="mask" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/convolution/convi.c"
                 line="1264">convolve with this mask</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/convolution/convi.c"
                 line="1265">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="convsep" c:identifier="vips_convsep" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/convolution/convsep.c"
             line="159">Perform a separable convolution of @in with @mask.
See [method@Image.conv] for a detailed description.

The mask must be 1xn or nx1 elements.

The image is convolved twice: once with @mask and then again with @mask
rotated by 90 degrees. This is much faster for certain types of mask
(gaussian blur, for example) than doing a full 2D convolution.

::: tip "Optional arguments"
    * @precision: [enum@Precision], calculation accuracy
    * @layers: `gint`, number of layers for approximation
    * @cluster: `gint`, cluster lines closer than this distance

::: seealso
    [method@Image.conv], [ctor@Image.gaussmat].</doc>
        <source-position filename="libvips/include/vips/convolution.h"
                         line="61"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/convolution/convsep.c"
               line="183">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/convolution/convsep.c"
                 line="161">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/convolution/convsep.c"
                 line="162">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="mask" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/convolution/convsep.c"
                 line="163">convolution mask</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/convolution/convsep.c"
                 line="164">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="vips_copy" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/copy.c"
             line="361">Copy an image, optionally modifying the header. VIPS copies images by
copying pointers, so this operation is instant, even for very large images.

You can optionally change any or all header fields during the copy. You can
make any change which does not change the size of a pel, so for example
you can turn a 4-band uchar image into a 2-band ushort image, but you
cannot change a 100 x 100 RGB image into a 300 x 100 mono image.

::: tip "Optional arguments"
    * @width: `gint`, set image width
    * @height: `gint`, set image height
    * @bands: `gint`, set image bands
    * @format: [enum@BandFormat], set image format
    * @coding: [enum@Coding], set image coding
    * @interpretation: [enum@Interpretation], set image interpretation
    * @xres: `gdouble`, set image xres
    * @yres: `gdouble`, set image yres
    * @xoffset: `gint`, set image xoffset
    * @yoffset: `gint`, set image yoffset

::: seealso
    [method@Image.byteswap], [method@Image.bandfold],
    [method@Image.bandunfold].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="138"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/copy.c"
               line="391">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/copy.c"
                 line="363">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/copy.c"
                 line="364">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/copy.c"
                 line="365">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="copy_file"
              c:identifier="vips_copy_file"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/copy.c"
             line="406">A simple convenience function to copy an image to a file, then copy
again to output. If the image is already a file, just copy straight
through.

The file is allocated with [ctor@Image.new_temp_file].
The file is automatically deleted when @out is closed.

::: seealso
    [method@Image.copy], [ctor@Image.new_temp_file].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="150"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/copy.c"
               line="422">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/copy.c"
                 line="408">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/copy.c"
                 line="409">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/copy.c"
                 line="410">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="copy_memory" c:identifier="vips_image_copy_memory">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="3294">This function allocates memory, renders @image into it, builds a new
image around the memory area, and returns that.

If the image is already a simple area of memory, it just refs @image and
returns it.

Call this before using the draw operations to make sure you have a
memory image that can be modified.

[method@Image.copy] adds a null "copy" node to a pipeline. Use that
instead if you want to change metadata and not pixels.

This operation is thread-safe, unlike [method@Image.wio_input].

If you are sure that @image is not shared with another thread (perhaps you
have made it yourself), use [method@Image.wio_input] instead.

::: seealso
    [method@Image.wio_input].</doc>
        <source-position filename="libvips/include/vips/image.h" line="552"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="3318">the new [class@Image], or `NULL` on error.</doc>
          <type name="Image" c:type="VipsImage*"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="3296">image to copy to a memory buffer</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="cos" c:identifier="vips_cos" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/math.c"
             line="334">Perform [enum@Vips.OperationMath.COS] on an image. See [method@Image.math].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="266"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/math.c"
               line="342">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="336">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="337">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="338">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="cosh" c:identifier="vips_cosh" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/math.c"
             line="472">Perform [enum@Vips.OperationMath.COSH] on an image. See [method@Image.math].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="296"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/math.c"
               line="480">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="474">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="475">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="476">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="countlines"
              c:identifier="vips_countlines"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/morphology/countlines.c"
             line="158">Function which calculates the number of transitions
between black and white for the horizontal or the vertical
direction of an image.  black&lt;128 , white&gt;=128
The function calculates the number of transitions for all
Xsize or Ysize and returns the mean of the result
Input should be one band, 8-bit.

::: seealso
    [method@Image.morph], [method@Image.conv].</doc>
        <source-position filename="libvips/include/vips/morphology.h"
                         line="59"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/morphology/countlines.c"
               line="175">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/morphology/countlines.c"
                 line="160">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="nolines"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/morphology/countlines.c"
                 line="161">output average number of lines</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="direction" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/morphology/countlines.c"
                 line="162">count lines horizontally or vertically</doc>
            <type name="Direction" c:type="VipsDirection"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/morphology/countlines.c"
                 line="163">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="crop" c:identifier="vips_crop" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/extract.c"
             line="304">A synonym for [method@Image.extract_area].

::: seealso
    [method@Image.extract_band], [method@Image.smartcrop].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="180"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/extract.c"
               line="319">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/extract.c"
                 line="306">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/extract.c"
                 line="307">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/extract.c"
                 line="308">left edge of area to extract</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="top" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/extract.c"
                 line="309">top edge of area to extract</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/extract.c"
                 line="310">width of area to extract</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/extract.c"
                 line="311">height of area to extract</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/extract.c"
                 line="312">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="cross_phase"
              c:identifier="vips_cross_phase"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/complex.c"
             line="587">Perform [enum@Vips.OperationComplex2.CROSS_PHASE] on an image.
See [method@Image.complex2].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="330"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/complex.c"
               line="597">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/complex.c"
                 line="589">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/complex.c"
                 line="590">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/complex.c"
                 line="591">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/complex.c"
                 line="592">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="csvsave" c:identifier="vips_csvsave" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/csvsave.c"
             line="337">Writes the pixels in @in to the @filename as CSV (comma-separated values).

The image is written
one line of text per scanline. Complex numbers are written as
"(real,imaginary)" and will need extra parsing I guess. Only the first band
is written.

@separator gives the string to use to separate numbers in the output.
The default is "\\t" (tab).

::: tip "Optional arguments"
    * @separator: `gchararray`, separator string

::: seealso
    [method@Image.write_to_file].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="693"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/csvsave.c"
               line="359">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/csvsave.c"
                 line="339">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/csvsave.c"
                 line="340">file to write to</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/csvsave.c"
                 line="341">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="csvsave_target"
              c:identifier="vips_csvsave_target"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/csvsave.c"
             line="374">As [method@Image.csvsave], but save to a target.

::: tip "Optional arguments"
    * @separator: `gchararray`, separator string

::: seealso
    [method@Image.csvsave].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="696"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/csvsave.c"
               line="388">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/csvsave.c"
                 line="376">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/csvsave.c"
                 line="377">save image to this target</doc>
            <type name="Target" c:type="VipsTarget*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/csvsave.c"
                 line="378">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="dE00" c:identifier="vips_dE00" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/colour/dE00.c"
             line="249">Calculate dE 00.</doc>
        <source-position filename="libvips/include/vips/colour.h" line="249"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/dE00.c"
               line="258">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/dE00.c"
                 line="251">first input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/dE00.c"
                 line="252">second input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/dE00.c"
                 line="253">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/dE00.c"
                 line="254">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="dE76" c:identifier="vips_dE76" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/colour/dE76.c"
             line="126">Calculate dE 76.</doc>
        <source-position filename="libvips/include/vips/colour.h" line="246"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/dE76.c"
               line="135">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/dE76.c"
                 line="128">first input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/dE76.c"
                 line="129">second input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/colour/dE76.c"
                 line="130">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/dE76.c"
                 line="131">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="dECMC" c:identifier="vips_dECMC" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/colour/dECMC.c"
             line="74">Calculate dE CMC. The input images are transformed to CMC colour space and
the euclidean distance between corresponding pixels calculated.

To calculate a colour difference with values for (l:c) other than (1:1),
transform the two source images to CMC yourself, scale the channels
appropriately, and call this function.

::: seealso
    [method@Image.colourspace]</doc>
        <source-position filename="libvips/include/vips/colour.h" line="252"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/dECMC.c"
               line="91">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/dECMC.c"
                 line="76">first input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/dECMC.c"
                 line="77">second input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/colour/dECMC.c"
                 line="78">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/dECMC.c"
                 line="79">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="decode" c:identifier="vips_image_decode">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="2907">A convenience function to unpack to a format that we can compute with.
@out.coding is always [enum@Vips.Coding.NONE].

This unpacks LABQ to plain LAB. Use [method@Image.LabQ2LabS] for a bit
more speed if you need it.

::: seealso
    [method@Image.encode], [method@Image.LabQ2Lab], [method@Image.rad2float].</doc>
        <source-position filename="libvips/include/vips/image.h" line="538"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="2921">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2909">image to decode</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2910">write to this image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
        </parameters>
      </method>
      <method name="decode_predict" c:identifier="vips_image_decode_predict">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="2944">We often need to know what an image will decode to without actually
decoding it, for example, in arg checking.

::: seealso
    [method@Image.decode].</doc>
        <source-position filename="libvips/include/vips/image.h" line="535"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2946">image to decode</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="bands"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2947">predict bands here</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
          <parameter name="format"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2948">predict format here</doc>
            <type name="BandFormat" c:type="VipsBandFormat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="deviate" c:identifier="vips_deviate" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/deviate.c"
             line="249">This operation finds the standard deviation of all pixels in @in. It
operates on all bands of the input image: use [method@Image.stats] if you need
to calculate an average for each band.

Non-complex images only.

::: seealso
    [method@Image.avg], [method@Image.stats]..</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="532"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/deviate.c"
               line="264">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/deviate.c"
                 line="251">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/deviate.c"
                 line="252">output pixel standard deviation</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/deviate.c"
                 line="253">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="divide" c:identifier="vips_divide" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/divide.c"
             line="222">This operation calculates @in1 / @in2 and writes the result to @out. If any
pixels in @in2 are zero, the corresponding pixel in @out is also zero.

If the images differ in size, the smaller image is enlarged to match the
larger by adding zero pixels along the bottom and right.

If the number of bands differs, one of the images
must have one band. In this case, an n-band image is formed from the
one-band image by joining n copies of the one-band image together, and then
the two n-band images are operated upon.

The two input images are cast up to the smallest common format (see table
Smallest common format in
[arithmetic](libvips-arithmetic.html)), then the
following table is used to determine the output type:

## [method@Image.divide] type promotion

| input type     | output type    |
|----------------|----------------|
| uchar          | float          |
| char           | float          |
| ushort         | float          |
| short          | float          |
| uint           | float          |
| int            | float          |
| float          | float          |
| double         | double         |
| complex        | complex        |
| double complex | double complex |

In other words, the output type is just large enough to hold the whole
range of possible values.

::: seealso
    [method@Image.multiply], [method@Image.linear], [method@Image.pow].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="207"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/divide.c"
               line="266">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/divide.c"
                 line="224">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/divide.c"
                 line="225">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/divide.c"
                 line="226">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/divide.c"
                 line="227">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="draw_circle"
              c:identifier="vips_draw_circle"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/draw/draw_circle.c"
             line="283">Draws a circle on @image.

If @fill is `TRUE` then the circle is filled,
otherwise a 1-pixel-wide perimeter is drawn.

@ink is an array of double containing values to draw.

::: tip "Optional arguments"
    * @fill: `gboolean`, fill the draw_circle

::: seealso
    [method@Image.draw_circle1], [method@Image.draw_line].</doc>
        <source-position filename="libvips/include/vips/draw.h" line="89"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/draw/draw_circle.c"
               line="306">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_circle.c"
                 line="285">image to draw on</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="ink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_circle.c"
                 line="286">value to draw</doc>
            <array length="1" zero-terminated="0" c:type="double*">
              <type name="gdouble" c:type="double"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_circle.c"
                 line="287">length of ink array</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_circle.c"
                 line="288">centre of draw_circle</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cy" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_circle.c"
                 line="289">centre of draw_circle</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="radius" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_circle.c"
                 line="290">draw_circle radius</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_circle.c"
                 line="291">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="draw_circle1"
              c:identifier="vips_draw_circle1"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/draw/draw_circle.c"
             line="322">As [method@Image.draw_circle], but just takes a single double for @ink.

::: tip "Optional arguments"
    * @fill: `gboolean`, fill the draw_circle

::: seealso
    [method@Image.draw_circle].</doc>
        <source-position filename="libvips/include/vips/draw.h" line="93"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/draw/draw_circle.c"
               line="339">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_circle.c"
                 line="324">image to draw on</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="ink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_circle.c"
                 line="325">value to draw</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="cx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_circle.c"
                 line="326">centre of draw_circle</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cy" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_circle.c"
                 line="327">centre of draw_circle</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="radius" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_circle.c"
                 line="328">draw_circle radius</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_circle.c"
                 line="329">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="draw_flood"
              c:identifier="vips_draw_flood"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/draw/draw_flood.c"
             line="690">Flood-fill @image with @ink, starting at position @x, @y.

The filled area is
bounded by pixels that are equal to the ink colour, in other words, it
searches for pixels enclosed by an edge of @ink.

If @equal is set, it instead searches for pixels which are equal to the
start point and fills them with @ink.

Normally it will test and set pixels in @image. If @test is set, it will
test pixels in @test and set pixels in @image. This lets you search an
image (@test) for continuous areas of pixels without modifying it.

@left, @top, @width, @height output the bounding box of the modified
pixels.

::: tip "Optional arguments"
    * @test: [class@Image], test this image
    * @equal: `gboolean`, fill while equal to edge
    * @left: `gint`, output left edge of bounding box of modified area
    * @top: `gint`, output top edge of bounding box of modified area
    * @width: `gint`, output width of bounding box of modified area
    * @height: `gint`, output height of bounding box of modified area

@ink is an array of double containing values to draw.

::: seealso
    [method@Image.draw_flood1].</doc>
        <source-position filename="libvips/include/vips/draw.h" line="98"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/draw/draw_flood.c"
               line="728">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_flood.c"
                 line="692">image to draw on</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="ink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_flood.c"
                 line="693">value to draw</doc>
            <array length="1" zero-terminated="0" c:type="double*">
              <type name="gdouble" c:type="double"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_flood.c"
                 line="694">length of ink array</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_flood.c"
                 line="695">centre of circle</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_flood.c"
                 line="696">centre of circle</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_flood.c"
                 line="697">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="draw_flood1"
              c:identifier="vips_draw_flood1"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/draw/draw_flood.c"
             line="744">As [method@Image.draw_flood], but just takes a single double for @ink.

::: tip "Optional arguments"
    * @test: [class@Image], test this image
    * @equal: `gboolean`, fill while equal to edge
    * @left: `gint`, output, left edge of bounding box of modified area
    * @top: `gint`, output, top edge of bounding box of modified area
    * @width: `gint`, output, width of bounding box of modified area
    * @height: `gint`, output, height of bounding box of modified area

::: seealso
    [method@Image.draw_flood].</doc>
        <source-position filename="libvips/include/vips/draw.h" line="101"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/draw/draw_flood.c"
               line="765">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_flood.c"
                 line="746">image to draw on</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="ink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_flood.c"
                 line="747">value to draw</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_flood.c"
                 line="748">centre of circle</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_flood.c"
                 line="749">centre of circle</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_flood.c"
                 line="750">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="draw_image"
              c:identifier="vips_draw_image"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/draw/draw_image.c"
             line="302">Draw @sub on top of @image at position @x, @y.

The two images must have the
same Coding. If @sub has 1 band, the bands will be duplicated to match the
number of bands in @image. @sub will be converted to @image's format, see
[method@Image.cast].

Use @mode to set how pixels are combined. If you use
[enum@Vips.CombineMode.ADD], both images must be uncoded.

::: tip "Optional arguments"
    * @mode: [enum@CombineMode], how to combine pixels

::: seealso
    [method@Image.draw_mask], [method@Image.insert].</doc>
        <source-position filename="libvips/include/vips/draw.h" line="67"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/draw/draw_image.c"
               line="326">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_image.c"
                 line="304">image to draw on</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="sub" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_image.c"
                 line="305">image to paint</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_image.c"
                 line="306">draw @sub here</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_image.c"
                 line="307">draw @sub here</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_image.c"
                 line="308">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="draw_line"
              c:identifier="vips_draw_line"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/draw/draw_line.c"
             line="332">Draws a 1-pixel-wide line on an image.

@ink is an array of double containing values to draw.

::: seealso
    [method@Image.draw_line1], [method@Image.draw_circle], [method@Image.draw_mask].</doc>
        <source-position filename="libvips/include/vips/draw.h" line="80"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/draw/draw_line.c"
               line="350">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_line.c"
                 line="334">image to draw on</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="ink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_line.c"
                 line="335">value to draw</doc>
            <array length="1" zero-terminated="0" c:type="double*">
              <type name="gdouble" c:type="double"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_line.c"
                 line="336">length of ink array</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="x1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_line.c"
                 line="337">start of draw_line</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="y1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_line.c"
                 line="338">start of draw_line</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="x2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_line.c"
                 line="339">end of draw_line</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="y2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_line.c"
                 line="340">end of draw_line</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_line.c"
                 line="341">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="draw_line1"
              c:identifier="vips_draw_line1"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/draw/draw_line.c"
             line="366">As [method@Image.draw_line], but just take a single double for @ink.

::: seealso
    [method@Image.draw_line].</doc>
        <source-position filename="libvips/include/vips/draw.h" line="84"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/draw/draw_line.c"
               line="381">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_line.c"
                 line="368">image to draw on</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="ink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_line.c"
                 line="369">value to draw</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="x1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_line.c"
                 line="370">start of draw_line</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="y1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_line.c"
                 line="371">start of draw_line</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="x2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_line.c"
                 line="372">end of draw_line</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="y2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_line.c"
                 line="373">end of draw_line</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_line.c"
                 line="374">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="draw_mask"
              c:identifier="vips_draw_mask"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/draw/draw_mask.c"
             line="372">Draw @mask on the image. @mask is a monochrome 8-bit image with 0/255
for transparent or @ink coloured points. Intermediate values blend the ink
with the pixel. Use with [ctor@Image.text] to draw text on an image. Use in a
[method@Image.draw_line] subclass to draw an object along a line.

@ink is an array of double containing values to draw.

::: seealso
    [ctor@Image.text], [method@Image.draw_line].</doc>
        <source-position filename="libvips/include/vips/draw.h" line="71"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/draw/draw_mask.c"
               line="392">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_mask.c"
                 line="374">image to draw on</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="ink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_mask.c"
                 line="375">value to draw</doc>
            <array length="1" zero-terminated="0" c:type="double*">
              <type name="gdouble" c:type="double"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_mask.c"
                 line="376">size of ink array</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="mask" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_mask.c"
                 line="377">mask of 0/255 values showing where to plot</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_mask.c"
                 line="378">draw mask here</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_mask.c"
                 line="379">draw mask here</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_mask.c"
                 line="380">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="draw_mask1"
              c:identifier="vips_draw_mask1"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/draw/draw_mask.c"
             line="408">As [method@Image.draw_mask], but just takes a single double for @ink.

::: seealso
    [method@Image.draw_mask].</doc>
        <source-position filename="libvips/include/vips/draw.h" line="75"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/draw/draw_mask.c"
               line="422">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_mask.c"
                 line="410">image to draw on</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="ink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_mask.c"
                 line="411">value to draw</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="mask" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_mask.c"
                 line="412">mask of 0/255 values showing where to plot</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_mask.c"
                 line="413">draw mask here</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_mask.c"
                 line="414">draw mask here</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_mask.c"
                 line="415">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="draw_point"
              c:identifier="vips_draw_point"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/draw/draw_rect.c"
             line="305">As [method@Image.draw_rect], but draw a single pixel at @x, @y.

::: seealso
    [method@Image.draw_rect].</doc>
        <source-position filename="libvips/include/vips/draw.h" line="60"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/draw/draw_rect.c"
               line="319">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_rect.c"
                 line="307">image to draw on</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="ink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_rect.c"
                 line="308">value to draw</doc>
            <array length="1" zero-terminated="0" c:type="double*">
              <type name="gdouble" c:type="double"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_rect.c"
                 line="309">length of ink array</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_rect.c"
                 line="310">point to paint</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_rect.c"
                 line="311">point to paint</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_rect.c"
                 line="312">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="draw_point1"
              c:identifier="vips_draw_point1"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/draw/draw_rect.c"
             line="334">As [method@Image.draw_point], but just take a single double for @ink.

::: seealso
    [method@Image.draw_point].</doc>
        <source-position filename="libvips/include/vips/draw.h" line="63"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/draw/draw_rect.c"
               line="347">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_rect.c"
                 line="336">image to draw on</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="ink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_rect.c"
                 line="337">value to draw</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_rect.c"
                 line="338">point to draw</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_rect.c"
                 line="339">point to draw</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_rect.c"
                 line="340">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="draw_rect"
              c:identifier="vips_draw_rect"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/draw/draw_rect.c"
             line="229">Paint pixels within @left, @top, @width, @height in @image with @ink.

If @fill is zero, just paint a 1-pixel-wide outline.

::: tip "Optional arguments"
    * @fill: `gboolean`, fill the rect

::: seealso
    [method@Image.draw_circle].</doc>
        <source-position filename="libvips/include/vips/draw.h" line="52"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/draw/draw_rect.c"
               line="250">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_rect.c"
                 line="231">image to draw on</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="ink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_rect.c"
                 line="232">value to draw</doc>
            <array length="1" zero-terminated="0" c:type="double*">
              <type name="gdouble" c:type="double"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_rect.c"
                 line="233">length of ink array</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_rect.c"
                 line="234">area to paint</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="top" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_rect.c"
                 line="235">area to paint</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_rect.c"
                 line="236">area to paint</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_rect.c"
                 line="237">area to paint</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_rect.c"
                 line="238">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="draw_rect1"
              c:identifier="vips_draw_rect1"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/draw/draw_rect.c"
             line="267">As [method@Image.draw_rect], but just take a single double for @ink.

::: tip "Optional arguments"
    * @fill: `gboolean`, fill the rect

::: seealso
    [method@Image.draw_rect].</doc>
        <source-position filename="libvips/include/vips/draw.h" line="56"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/draw/draw_rect.c"
               line="285">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_rect.c"
                 line="269">image to draw on</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="ink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_rect.c"
                 line="270">value to draw</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_rect.c"
                 line="271">area to paint</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="top" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_rect.c"
                 line="272">area to paint</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_rect.c"
                 line="273">area to paint</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_rect.c"
                 line="274">area to paint</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_rect.c"
                 line="275">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="draw_smudge"
              c:identifier="vips_draw_smudge"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/draw/draw_smudge.c"
             line="248">Smudge a section of @image. Each pixel in the area @left, @top, @width,
@height is replaced by the average of the surrounding 3x3 pixels.

::: seealso
    [method@Image.draw_line].</doc>
        <source-position filename="libvips/include/vips/draw.h" line="105"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/draw/draw_smudge.c"
               line="263">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_smudge.c"
                 line="250">image to draw on</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_smudge.c"
                 line="251">point to paint</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="top" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_smudge.c"
                 line="252">point to paint</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_smudge.c"
                 line="253">area to paint</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_smudge.c"
                 line="254">area to paint</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/draw/draw_smudge.c"
                 line="255">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="dzsave" c:identifier="vips_dzsave" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/dzsave.c"
             line="2786">Save an image as a set of tiles at various resolutions. By default dzsave
uses DeepZoom layout -- use @layout to pick other conventions.

[method@Image.dzsave] creates a directory called @name to hold the tiles.
If @name ends `.zip`, [method@Image.dzsave] will create a zip file called
@name to hold the tiles. You can use @container to force zip file output.

Use @basename to set the name of the image we are creating. The
default value is set from @name.

By default, tiles are written as JPEGs. Use @Q set set the JPEG quality
factor.

You can set @suffix to something like `".png[bitdepth=4]"` to write tiles
in another format.

In Google layout mode, edge tiles are expanded to @tile_size by @tile_size
pixels. Normally they are filled with white, but you can set another colour
with @background. Images are usually placed at the top-left of the tile,
but you can have them centred by turning on @centre.

You can set the size and overlap of tiles with @tile_size and @overlap.
They default to the correct settings for the selected @layout. The deepzoom
defaults produce 256x256 jpeg files for centre tiles, the most efficient
size.

Use @depth to control how low the pyramid goes. This defaults to the
correct setting for the @layout you select.

You can rotate the image during write with the @angle argument. However,
this will only work for images which support random access, like openslide,
and not for things like JPEG. You'll need to rotate those images
yourself with [method@Image.rot]. Note that the `autorotate` option to the loader
may do what you need.

By default, all tiles are stripped since usually you do not want a copy of
all metadata in every tile. Set @keep if you want to keep metadata.

If @container is set to `zip`, you can set a compression level from -1
(use zlib default), 0 (store, compression disabled) to 9 (max compression).
If no value is given, the default is to store files without compression.

You can use @region_shrink to control the method for shrinking each 2x2
region. This defaults to using the average of the 4 input pixels but you can
also use the median in cases where you want to preserve the range of values.

If you set @skip_blanks to a value greater than or equal to zero, tiles
which are all within that many pixel values to the background are skipped.
This can save a lot of space for some image types. This option defaults to
5 in Google layout mode, -1 otherwise.

In IIIF layout, you can set the base of the `id` property in `info.json`
with @id. The default is `https://example.com/iiif`.

Use @layout [enum@Vips.ForeignDzLayout.IIIF3] for IIIF v3 layout.

::: tip "Optional arguments"
    * @basename: `gchararray`, base part of name
    * @layout: [enum@ForeignDzLayout], directory layout convention
    * @suffix: `gchararray`, suffix for tiles
    * @overlap: `gint`, set tile overlap
    * @tile_size: `gint`, set tile size
    * @background: [struct@ArrayDouble], background colour
    * @depth: [enum@ForeignDzDepth], how deep to make the pyramid
    * @centre: `gboolean`, centre the tiles
    * @angle: [enum@Angle], rotate the image by this much
    * @container: [enum@ForeignDzContainer], set container type
    * @compression: `gint`, zip deflate compression level
    * @region_shrink: [enum@RegionShrink], how to shrink each 2x2 region
    * @skip_blanks: `gint`, skip tiles which are nearly equal to the
      background
    * @id: `gchararray`, id for IIIF properties
    * @Q: `gint`, quality factor

::: seealso
    [method@Image.tiffsave].</doc>
        <source-position filename="libvips/include/vips/foreign.h"
                         line="1054"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/dzsave.c"
               line="2869">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/dzsave.c"
                 line="2788">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/dzsave.c"
                 line="2789">name to save to</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/dzsave.c"
                 line="2790">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="dzsave_buffer"
              c:identifier="vips_dzsave_buffer"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/dzsave.c"
             line="2884">As [method@Image.dzsave], but save to a memory buffer.

Output is always in a zip container. Use @basename to set the name of the
directory that the zip will create when unzipped.

The address of the buffer is returned in @buf, the length of the buffer in
@len. You are responsible for freeing the buffer with [func@GLib.free] when you
are done with it.

::: tip "Optional arguments"
    * @basename: `gchararray`, base part of name
    * @layout: [enum@ForeignDzLayout], directory layout convention
    * @suffix: `gchararray`, suffix for tiles
    * @overlap: `gint`, set tile overlap
    * @tile_size: `gint`, set tile size
    * @background: [struct@ArrayDouble], background colour
    * @depth: [enum@ForeignDzDepth], how deep to make the pyramid
    * @centre: `gboolean`, centre the tiles
    * @angle: [enum@Angle], rotate the image by this much
    * @container: [enum@ForeignDzContainer], set container type
    * @compression: `gint`, zip deflate compression level
    * @region_shrink: [enum@RegionShrink], how to shrink each 2x2 region
    * @skip_blanks: `gint`, skip tiles which are nearly equal to the
      background
    * @id: `gchararray`, id for IIIF properties
    * @Q: `gint`, quality factor

::: seealso
    [method@Image.dzsave], [method@Image.write_to_file].</doc>
        <source-position filename="libvips/include/vips/foreign.h"
                         line="1057"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/dzsave.c"
               line="2921">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/dzsave.c"
                 line="2886">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/dzsave.c"
                 line="2887">return output buffer here</doc>
            <array length="1" zero-terminated="0" c:type="void**">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/dzsave.c"
                 line="2888">return output length here</doc>
            <type name="gsize" c:type="size_t*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/dzsave.c"
                 line="2889">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="dzsave_target"
              c:identifier="vips_dzsave_target"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/dzsave.c"
             line="2951">As [method@Image.dzsave], but save to a target.

::: tip "Optional arguments"
    * @basename: `gchararray`, base part of name
    * @layout: [enum@ForeignDzLayout], directory layout convention
    * @suffix: `gchararray`, suffix for tiles
    * @overlap: `gint`, set tile overlap
    * @tile_size: `gint`, set tile size
    * @background: [struct@ArrayDouble], background colour
    * @depth: [enum@ForeignDzDepth], how deep to make the pyramid
    * @centre: `gboolean`, centre the tiles
    * @angle: [enum@Angle], rotate the image by this much
    * @container: [enum@ForeignDzContainer], set container type
    * @compression: `gint`, zip deflate compression level
    * @region_shrink: [enum@RegionShrink], how to shrink each 2x2 region
    * @skip_blanks: `gint`, skip tiles which are nearly equal to the
      background
    * @id: `gchararray`, id for IIIF properties
    * @Q: `gint`, quality factor

::: seealso
    [method@Image.dzsave], [method@Image.write_to_target].</doc>
        <source-position filename="libvips/include/vips/foreign.h"
                         line="1060"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/dzsave.c"
               line="2980">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/dzsave.c"
                 line="2953">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/dzsave.c"
                 line="2954">save image to this target</doc>
            <type name="Target" c:type="VipsTarget*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/dzsave.c"
                 line="2955">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="embed" c:identifier="vips_embed" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/embed.c"
             line="675">The opposite of [method@Image.extract_area]: embed @in within an image of
size @width by @height at position @x, @y.

@extend controls what appears in the new pels, see [enum@Extend].

::: tip "Optional arguments"
    * @extend: [enum@Extend] to generate the edge pixels
      (default: [enum@Vips.Extend.BLACK])
    * @background: [struct@ArrayDouble] colour for edge pixels

::: seealso
    [method@Image.extract_area], [method@Image.insert].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="154"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/embed.c"
               line="698">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/embed.c"
                 line="677">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/embed.c"
                 line="678">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/embed.c"
                 line="679">place @in at this x position in @out</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/embed.c"
                 line="680">place @in at this y position in @out</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/embed.c"
                 line="681">@out should be this many pixels across</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/embed.c"
                 line="682">@out should be this many pixels down</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/embed.c"
                 line="683">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="encode" c:identifier="vips_image_encode">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="2984">A convenience function to pack to a coding. The inverse of
[method@Image.decode].

::: seealso
    [method@Image.decode].</doc>
        <source-position filename="libvips/include/vips/image.h" line="540"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="2996">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2986">image to encode</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2987">write to this image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="coding" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2988">coding to apply</doc>
            <type name="Coding" c:type="VipsCoding"/>
          </parameter>
        </parameters>
      </method>
      <method name="eorimage" c:identifier="vips_eorimage" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/boolean.c"
             line="392">Perform [enum@Vips.OperationBoolean.EOR] on a pair of images. See
[method@Image.boolean].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="432"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/boolean.c"
               line="402">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="394">left-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="395">right-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="396">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="397">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="eorimage_const"
              c:identifier="vips_eorimage_const"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/boolean.c"
             line="707">Perform [enum@Vips.OperationBoolean.EOR] on an image and an array of constants.
See [method@Image.boolean_const].

::: seealso
    [method@Image.boolean], [method@Image.boolean_const1].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="454"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/boolean.c"
               line="721">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="709">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="710">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="711">array of constants</doc>
            <array length="2" zero-terminated="0" c:type="const double*">
              <type name="gdouble" c:type="double"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="712">number of constants in @c</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="713">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="eorimage_const1"
              c:identifier="vips_eorimage_const1"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/boolean.c"
             line="884">Perform [enum@Vips.OperationBoolean.EOR] on an image and a constant.
See [method@Image.boolean_const1].

::: seealso
    [method@Image.boolean], [method@Image.boolean_const].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="476"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/boolean.c"
               line="897">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="886">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="887">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="888">constant</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="889">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="vips_equal" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/relational.c"
             line="317">Perform [enum@Vips.OperationRelational.EQUAL] on a pair of images. See
[method@Image.relational].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="353"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/relational.c"
               line="327">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="319">left-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="320">right-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="321">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="322">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="equal_const"
              c:identifier="vips_equal_const"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/relational.c"
             line="688">Perform [enum@Vips.OperationRelational.EQUAL] on an image and a constant. See
[method@Image.relational_const].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="375"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/relational.c"
               line="699">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="690">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="691">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="692">array of constants</doc>
            <array length="2" zero-terminated="0" c:type="const double*">
              <type name="gdouble" c:type="double"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="693">number of constants in @c</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="694">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="equal_const1"
              c:identifier="vips_equal_const1"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/relational.c"
             line="881">Perform [enum@Vips.OperationRelational.EQUAL] on an image and a constant. See
[method@Image.relational_const].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="403"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/relational.c"
               line="891">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="883">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="884">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="885">constant</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="886">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="eval" c:identifier="vips_image_eval">
        <source-position filename="libvips/include/vips/image.h" line="451"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="processed" transfer-ownership="none">
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="exp" c:identifier="vips_exp" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/math.c"
             line="633">Perform [enum@Vips.OperationMath.EXP] on an image. See [method@Image.math].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="281"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/math.c"
               line="641">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="635">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="636">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="637">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="exp10" c:identifier="vips_exp10" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/math.c"
             line="656">Perform [enum@Vips.OperationMath.EXP10] on an image. See [method@Image.math].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="284"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/math.c"
               line="664">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="658">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="659">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="660">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="extract_area"
              c:identifier="vips_extract_area"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/extract.c"
             line="245">Extract an area from an image. The area must fit within @in.

::: seealso
    [method@Image.extract_band], [method@Image.smartcrop].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="176"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/extract.c"
               line="260">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/extract.c"
                 line="247">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/extract.c"
                 line="248">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/extract.c"
                 line="249">left edge of area to extract</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="top" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/extract.c"
                 line="250">top edge of area to extract</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/extract.c"
                 line="251">width of area to extract</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/extract.c"
                 line="252">height of area to extract</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/extract.c"
                 line="253">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="extract_band"
              c:identifier="vips_extract_band"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/extract.c"
             line="464">Extract a band or bands from an image. Extracting out of range is an error.

@n defaults to 1.

::: tip "Optional arguments"
    * @n: `gint`, number of bands to extract

::: seealso
    [method@Image.extract_area].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="187"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/extract.c"
               line="481">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/extract.c"
                 line="466">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/extract.c"
                 line="467">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="band" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/extract.c"
                 line="468">index of first band to extract</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/extract.c"
                 line="469">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="falsecolour"
              c:identifier="vips_falsecolour"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/falsecolour.c"
             line="391">Force @in to 1 band, 8-bit, then transform to
a 3-band 8-bit image with a false colour
map. The map is supposed to make small differences in brightness more
obvious.

::: seealso
    [method@Image.maplut].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="344"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/falsecolour.c"
               line="405">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/falsecolour.c"
                 line="393">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/falsecolour.c"
                 line="394">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/falsecolour.c"
                 line="395">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="fastcor" c:identifier="vips_fastcor" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/convolution/fastcor.c"
             line="229">Calculate a fast correlation surface.

@ref is placed at every position in @in and the sum of squares of
differences calculated.

The output
image is the same size as the input. Extra input edge pixels are made by
copying the existing edges outwards.

If the number of bands differs, one of the images
must have one band. In this case, an n-band image is formed from the
one-band image by joining n copies of the one-band image together, and then
the two n-band images are operated upon.

The output type is uint if both inputs are integer, float if both are float
or complex, and double if either is double or double complex.
In other words, the output type is just large enough to hold the whole
range of possible values.

::: seealso
    [method@Image.spcor].</doc>
        <source-position filename="libvips/include/vips/convolution.h"
                         line="81"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/convolution/fastcor.c"
               line="258">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/convolution/fastcor.c"
                 line="231">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="ref" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/convolution/fastcor.c"
                 line="232">reference image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/convolution/fastcor.c"
                 line="233">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/convolution/fastcor.c"
                 line="234">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="fill_nearest"
              c:identifier="vips_fill_nearest"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/morphology/nearest.c"
             line="326">Fill outwards from every non-zero pixel in @in, setting pixels in @distance
and @value.

At the position of zero pixels in @in, @distance contains the distance to
the nearest non-zero pixel in @in, and @value contains the value of that
pixel.

@distance is a one-band float image. @value has the same number of bands and
format as @in.

::: tip "Optional arguments"
    * @distance: [class@Image], output, image of distance to nearest
      non-zero pixel

::: seealso
    [method@Image.hist_find_indexed].</doc>
        <source-position filename="libvips/include/vips/morphology.h"
                         line="66"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/morphology/nearest.c"
               line="349">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/morphology/nearest.c"
                 line="328">image to test</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/morphology/nearest.c"
                 line="329">image with zero pixels filled with the nearest non-zero pixel</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/morphology/nearest.c"
                 line="330">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="find_trim"
              c:identifier="vips_find_trim"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/find_trim.c"
             line="250">Search @in for the bounding box of the non-background area.

Any alpha is flattened out, then the image is median-filtered (unless
@line_art is set, see below). The absolute difference from @background is
computed and binarized according to @threshold. Row and column sums of
the absolute difference are calculated from this binary image and searched
for the first row or column in each direction to obtain the bounding box.

If the image is entirely background, [method@Image.find_trim] returns
@width == 0 and @height == 0.

@background defaults to 255, or 65535 for 16-bit images. Set another value,
or use [method@Image.getpoint] to pick a value from an edge. You'll need
to flatten before [method@Image.getpoint] to get a correct background value.

@threshold defaults to 10.

The detector is designed for photographic or compressed images where there
is a degree of noise that needs filtering. If your images are synthetic
(eg. rendered from vector art, perhaps), set @line_art to disable this
filtering.

The image needs to be at least 3x3 pixels in size.

::: tip "Optional arguments"
    * @threshold: `gdouble`, background / object threshold
    * @background: [struct@ArrayDouble], background colour
    * @line_art: `gboolean`, enable line art mode

::: seealso
    [method@Image.getpoint], [method@Image.extract_area], [method@Image.smartcrop].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="547"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/find_trim.c"
               line="291">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/find_trim.c"
                 line="252">image to find_trim</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="left"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/find_trim.c"
                 line="253">output left edge</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
          <parameter name="top"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/find_trim.c"
                 line="254">output top edge</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
          <parameter name="width"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/find_trim.c"
                 line="255">output width</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
          <parameter name="height"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/find_trim.c"
                 line="256">output height</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/find_trim.c"
                 line="257">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="fitssave" c:identifier="vips_fitssave" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/fitssave.c"
             line="157">Write a VIPS image to a file in FITS format.

::: seealso
    [method@Image.write_to_file].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="665"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/fitssave.c"
               line="168">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/fitssave.c"
                 line="159">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/fitssave.c"
                 line="160">file to write to</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/fitssave.c"
                 line="161">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="flatten" c:identifier="vips_flatten" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/flatten.c"
             line="443">Take the last band of @in as an alpha and use it to blend the
remaining channels with @background.

The alpha channel is 0 - @max_alpha, where @max_alpha means 100% image
and 0 means 100% background. @background defaults to zero (black).

@max_alpha has the default value 255, or 65535 for images tagged as
[enum@Vips.Interpretation.RGB16] or [enum@Vips.Interpretation.GREY16].

Useful for flattening PNG images to RGB.

Non-complex images only.

::: tip "Optional arguments"
    * @background: [struct@ArrayDouble] colour for new pixels
    * @max_alpha: `gdouble`, maximum value for alpha

::: seealso
    [method@Image.premultiply], [ctor@Image.pngload].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="324"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/flatten.c"
               line="469">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/flatten.c"
                 line="445">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/flatten.c"
                 line="446">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/flatten.c"
                 line="447">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="flip" c:identifier="vips_flip" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/flip.c"
             line="261">Flips an image left-right or up-down.

::: seealso
    [method@Image.rot].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="162"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/flip.c"
               line="273">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/flip.c"
                 line="263">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/flip.c"
                 line="264">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="direction" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/flip.c"
                 line="265">flip horizontally or vertically</doc>
            <type name="Direction" c:type="VipsDirection"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/flip.c"
                 line="266">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="float2rad"
              c:identifier="vips_float2rad"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/colour/float2rad.c"
             line="227">Convert a three-band float image to Radiance 32-bit packed format.

::: seealso
    [method@Image.rad2float], [enum@Vips.Coding.RAD], [method@Image.LabQ2Lab].</doc>
        <source-position filename="libvips/include/vips/colour.h" line="131"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/float2rad.c"
               line="238">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/float2rad.c"
                 line="229">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/colour/float2rad.c"
                 line="230">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/float2rad.c"
                 line="231">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="floor" c:identifier="vips_floor" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/round.c"
             line="233">Round to an integral value with [enum@Vips.OperationRound.FLOOR]. See
[method@Image.round].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="249"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/round.c"
               line="242">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/round.c"
                 line="235">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/round.c"
                 line="236">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/round.c"
                 line="237">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="foreign_load_invalidate"
              c:identifier="vips_foreign_load_invalidate">
        <doc xml:space="preserve"
             filename="libvips/foreign/foreign.c"
             line="1307">Loaders can call this on the image they are making if they see a read error
from the load library. It signals "invalidate" on the load operation and
will cause it to be dropped from cache.

If we know a file will cause a read error, we don't want to cache the
failing operation, we want to make sure the image will really be opened
again if our caller tries again. For example, a broken file might be
replaced by a working one.</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="293"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/foreign.c"
                 line="1309">image to invalidate</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free_buffer" c:identifier="vips_image_free_buffer">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="3866">Free the externally allocated buffer found in the input image. This function
is intended to be used with g_signal_connect.</doc>
        <source-position filename="libvips/include/vips/image.h" line="612"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="3868">the image that contains the buffer</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="buffer"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="3869">the original buffer that was stolen</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
      <method name="freqmult" c:identifier="vips_freqmult" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/freqfilt/freqmult.c"
             line="141">Multiply @in by @mask in Fourier space.

@in is transformed to Fourier space, multiplied with @mask, then
transformed back to real space. If @in is already a complex image, just
multiply then inverse transform.

::: seealso
    [method@Image.invfft], [ctor@Image.mask_ideal].</doc>
        <source-position filename="libvips/include/vips/freqfilt.h" line="49"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/freqfilt/freqmult.c"
               line="157">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/freqfilt/freqmult.c"
                 line="143">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="mask" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/freqfilt/freqmult.c"
                 line="144">mask image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/freqfilt/freqmult.c"
                 line="145">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/freqfilt/freqmult.c"
                 line="146">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="fwfft" c:identifier="vips_fwfft" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/freqfilt/fwfft.c"
             line="362">Transform an image to Fourier space.

VIPS uses the fftw Fourier Transform library. If this library was not
available when VIPS was configured, these functions will fail.

::: seealso
    [method@Image.invfft].</doc>
        <source-position filename="libvips/include/vips/freqfilt.h" line="42"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/freqfilt/fwfft.c"
               line="376">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/freqfilt/fwfft.c"
                 line="364">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/freqfilt/fwfft.c"
                 line="365">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/freqfilt/fwfft.c"
                 line="366">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="gamma" c:identifier="vips_gamma" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/gamma.c"
             line="161">Calculate @in ** (1 / @exponent), normalising to the maximum range of the
input type. For float types use 1.0 as the maximum.

::: tip "Optional arguments"
    * @exponent: `gdouble`, gamma, default 1.0 / 2.4

::: seealso
    [ctor@Image.identity], [method@Image.pow_const1], [method@Image.maplut]</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="347"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/gamma.c"
               line="176">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/gamma.c"
                 line="163">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/gamma.c"
                 line="164">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/gamma.c"
                 line="165">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="gaussblur"
              c:identifier="vips_gaussblur"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/convolution/gaussblur.c"
             line="173">This operator runs [ctor@Image.gaussmat] and [method@Image.convsep] for
you on an image.

Set @min_ampl smaller to generate a larger, more accurate mask. Set @sigma
larger to make the blur more blurry.

::: tip "Optional arguments"
    * @precision: [enum@Precision], precision for blur, default int
    * @min_ampl: `gdouble`, minimum amplitude, default 0.2

::: seealso
    [ctor@Image.gaussmat], [method@Image.convsep].</doc>
        <source-position filename="libvips/include/vips/convolution.h"
                         line="71"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/convolution/gaussblur.c"
               line="193">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/convolution/gaussblur.c"
                 line="175">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/convolution/gaussblur.c"
                 line="176">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="sigma" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/convolution/gaussblur.c"
                 line="177">how large a mask to use</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/convolution/gaussblur.c"
                 line="178">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="generate" c:identifier="vips_image_generate">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/generate.c"
             line="657">Generates an image. The action depends on the image type.

For images created with [ctor@Image.new], [method@Image.generate] just
attaches the start/generate/stop callbacks and returns.

For images created with [ctor@Image.new_memory], memory is allocated for
the whole image and it is entirely generated using [func@sink_memory].

For images created with [ctor@Image.new_temp_file] and friends, memory for
a few scanlines is allocated and
[method@Image.sink_disc] used to generate the image in small chunks. As each
chunk is generated, it is written to disc.

::: seealso
    [func@sink_memory], [ctor@Image.new], [method@Region.prepare].</doc>
        <source-position filename="libvips/include/vips/generate.h" line="77"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/generate.c"
               line="682">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/generate.c"
                 line="659">generate this image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="start_fn" transfer-ownership="none" scope="async">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/generate.c"
                 line="660">start sequences with this function</doc>
            <type name="StartFn" c:type="VipsStartFn"/>
          </parameter>
          <parameter name="generate_fn"
                     transfer-ownership="none"
                     scope="async">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/generate.c"
                 line="661">generate pixels with this function</doc>
            <type name="GenerateFn" c:type="VipsGenerateFn"/>
          </parameter>
          <parameter name="stop_fn" transfer-ownership="none" scope="async">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/generate.c"
                 line="662">stop sequences with this function</doc>
            <type name="StopFn" c:type="VipsStopFn"/>
          </parameter>
          <parameter name="a"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/generate.c"
                 line="663">user data</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="b"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/generate.c"
                 line="664">user data</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get" c:identifier="vips_image_get">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="1353">Fill @value_copy with a copy of the header field. @value_copy must be zeroed
but uninitialised.

This will return -1 and add a message to the error buffer if the field
does not exist. Use [method@Image.get_typeof] to test for the
existence of a field first if you are not certain it will be there.

For example, to read a double from an image (though of course you would use
[method@Image.get_double] in practice):

```c
GValue value = G_VALUE_INIT;
double d;

if (vips_image_get(image, name, &amp;value))
    return -1;

if (G_VALUE_TYPE(&amp;value) != G_TYPE_DOUBLE) {
    vips_error("mydomain",
        _("field \"%s\" is of type %s, not double"),
        name,
        g_type_name(G_VALUE_TYPE(&amp;value)));
    g_value_unset(&amp;value);
    return -1;
}

d = g_value_get_double(&amp;value);
g_value_unset(&amp;value);
```

::: seealso
    [method@Image.get_typeof], [method@Image.get_double].</doc>
        <source-position filename="libvips/include/vips/header.h" line="270"/>
        <return-value transfer-ownership="none" skip="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="1393">0 on success, -1 otherwise.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1355">image to get the field from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1356">the name to fetch</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value_copy"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1357">the
  [struct@GObject.Value] is copied into this</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_area" c:identifier="vips_image_get_area">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="1694">Gets @data from @image under the name @name. A convenience
function over [method@Image.get]. Use [method@Image.get_typeof] to
test for the existence of a piece of metadata.

::: seealso
    [method@Image.set_area], [method@Image.get],
    [method@Image.get_typeof].</doc>
        <source-position filename="libvips/include/vips/header.h" line="290"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="1708">0 on success, -1 otherwise.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1696">image to get the metadata from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1697">metadata name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="data"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     nullable="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1698">return metadata value</doc>
            <type name="gpointer" c:type="void**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_array_double"
              c:identifier="vips_image_get_array_double">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="2184">Gets @out from @im under the name @name.
The field must be of type `VIPS_TYPE_ARRAY_INT`.

Do not free @out. @out is valid as long as @image is valid.

Use [method@Image.get_typeof] to test for the
existence of a piece of metadata.

::: seealso
    [method@Image.get], [method@Image.set_image]</doc>
        <source-position filename="libvips/include/vips/header.h" line="332"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="2202">0 on success, -1 otherwise.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="2186">image to get the metadata from</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="2187">metadata name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="2188">return pointer to array</doc>
            <array length="2" zero-terminated="0" c:type="double**">
              <type name="gdouble" c:type="double*"/>
            </array>
          </parameter>
          <parameter name="n"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="2189">return the number of elements here, optionally</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_array_int" c:identifier="vips_image_get_array_int">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="2125">Gets @out from @im under the name @name.
The field must be of type `VIPS_TYPE_ARRAY_INT`.

Do not free @out. @out is valid as long as @image is valid.

Use [method@Image.get_typeof] to test for the
existence of a piece of metadata.

::: seealso
    [method@Image.get], [method@Image.set_image]</doc>
        <source-position filename="libvips/include/vips/header.h" line="329"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="2143">0 on success, -1 otherwise.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="2127">image to get the metadata from</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="2128">metadata name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="2129">return pointer to array</doc>
            <array length="2" zero-terminated="0" c:type="int**">
              <type name="gint" c:type="int*"/>
            </array>
          </parameter>
          <parameter name="n"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="2130">return the number of elements here, optionally</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_as_string" c:identifier="vips_image_get_as_string">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="1998">Returns @name from @image in @out.
This function will read any field, returning it as a printable string.
You need to free the string with [func@GLib.free] when you are done with it.

This will base64-encode BLOBs, for example. Use [method@Buf.appendg] to
make a string that's for humans.

::: seealso
    [method@Image.get], [method@Image.get_typeof],
    [method@Buf.appendg].</doc>
        <source-position filename="libvips/include/vips/header.h" line="273"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="2015">0 on success, -1 otherwise.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="2000">image to get the header field from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="2001">field name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="2002">return field value as string</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_bands"
              c:identifier="vips_image_get_bands"
              glib:get-property="bands">
        <source-position filename="libvips/include/vips/header.h" line="210"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="414">the number of bands (channels) in the image.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="412">image to get from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_blob" c:identifier="vips_image_get_blob">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="1790">Gets @data from @image under the name @name, optionally returns its
length in @length. Use [method@Image.get_typeof] to test for the existence
of a piece of metadata.

::: seealso
    [method@Image.get], [method@Image.get_typeof],
    [method@Blob.get].</doc>
        <source-position filename="libvips/include/vips/header.h" line="300"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="1806">0 on success, -1 otherwise.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1792">image to get the metadata from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1793">metadata name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="data"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1794">pointer to area
  of memory</doc>
            <array length="2" zero-terminated="0" c:type="void**">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="length"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1796">return the blob length here, optionally</doc>
            <type name="gsize" c:type="size_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_coding"
              c:identifier="vips_image_get_coding"
              glib:get-property="coding">
        <source-position filename="libvips/include/vips/header.h" line="218"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="564">the [enum@Coding] from the image header.</doc>
          <type name="Coding" c:type="VipsCoding"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="562">image to get from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_concurrency" c:identifier="vips_image_get_concurrency">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="930">Fetch and sanity-check [const@META_CONCURRENCY]. Default to 1 if not
present or crazy.</doc>
        <source-position filename="libvips/include/vips/header.h" line="250"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="937">the suggested concurrency for this image</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="932">image to get from</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="default_concurrency" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_data" c:identifier="vips_image_get_data">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="1098">Return a pointer to the image's pixel data, if possible. This can involve
allocating large amounts of memory and performing a long computation. Image
pixels are laid out in band-packed rows.

Since this function modifies @image, it is not threadsafe. Only call it on
images which you are sure have not been shared with another thread.

::: seealso
    [method@Image.wio_input], [method@Image.copy_memory].</doc>
        <source-position filename="libvips/include/vips/header.h" line="258"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="1112">a pointer to pixel data, if possible.</doc>
          <type name="gpointer" c:type="void*"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1100">image to get data for</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_double" c:identifier="vips_image_get_double">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="1873">Gets @out from @im under the name @name.
The value will be transformed into a double, if possible.

::: seealso
    [method@Image.get], [method@Image.get_typeof].</doc>
        <source-position filename="libvips/include/vips/header.h" line="308"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="1885">0 on success, -1 otherwise.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1875">image to get the header field from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1876">field name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1877">return field value</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_fields" c:identifier="vips_image_get_fields">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="1620">Get a `NULL`-terminated array listing all the metadata field names on @image.
Free the return result with [func@GLib.strfreev].

This is handy for language bindings. From C, it's usually more convenient to
use [method@Image.map].</doc>
        <source-position filename="libvips/include/vips/header.h" line="284"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="1630">metadata fields in image, as a `NULL`-terminated
  array.</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1622">image to get fields from</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_filename"
              c:identifier="vips_image_get_filename"
              glib:get-property="filename">
        <source-position filename="libvips/include/vips/header.h" line="232"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="813">the name of the file the image was loaded from, or `NULL` if
  there is no filename.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="811">image to get from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_format"
              c:identifier="vips_image_get_format"
              glib:get-property="format">
        <source-position filename="libvips/include/vips/header.h" line="212"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="426">the format of each band element.</doc>
          <type name="BandFormat" c:type="VipsBandFormat"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="424">image to get from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_gainmap" c:identifier="vips_image_get_gainmap">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="1064">If the image has an attached `"gainmap"`, return that. If there's a
compressed `"gainmap-data"`, decompress, and return it.

You need to free the result with [method@GObject.Object.unref] when
you're done with it.</doc>
        <source-position filename="libvips/include/vips/header.h" line="256"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="1074">the gainmap image, if present, or NULL.</doc>
          <type name="Image" c:type="VipsImage*"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1066">image to get the gainmap from</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_height"
              c:identifier="vips_image_get_height"
              glib:get-property="height">
        <source-position filename="libvips/include/vips/header.h" line="208"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="402">the number of pixels down the image.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="400">image to get from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_history" c:identifier="vips_image_get_history">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="2340">This function reads the image history as a C string. The string is owned
by VIPS and must not be freed.

VIPS tracks the history of each image, that is, the sequence of operations
that generated that image. Applications built on VIPS need to call
[method@Image.history_printf] for each action they perform, setting the
command-line equivalent for the action.

::: seealso
    [method@Image.history_printf].</doc>
        <source-position filename="libvips/include/vips/header.h" line="345"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="2355">The history of @image as a C string. Do not free!</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="2342">get history from here</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_image" c:identifier="vips_image_get_image">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="2070">Gets @out from @im under the name @name.
The field must be of type `VIPS_TYPE_IMAGE`.
You must unref @out with [method@GObject.Object.unref].

Use [method@Image.get_typeof] to test for the
existence of a piece of metadata.

::: seealso
    [method@Image.get], [method@Image.set_image]</doc>
        <source-position filename="libvips/include/vips/header.h" line="321"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="2086">0 on success, -1 otherwise.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="2072">image to get the metadata from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="2073">metadata name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="2074">return metadata value</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int" c:identifier="vips_image_get_int">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="1823">Gets @out from @im under the name @name.
The value will be transformed into an int, if possible.

::: seealso
    [method@Image.get], [method@Image.get_typeof].</doc>
        <source-position filename="libvips/include/vips/header.h" line="304"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="1835">0 on success, -1 otherwise.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1825">image to get the header field from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1826">field name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1827">return field value</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_interpretation"
              c:identifier="vips_image_get_interpretation"
              glib:get-property="interpretation">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="572">Return the [enum@Interpretation] set in the image header.
Use [method@Image.guess_format] if you want a sanity-checked value.</doc>
        <source-position filename="libvips/include/vips/header.h" line="220"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="579">the [enum@Interpretation] from the image header.</doc>
          <type name="Interpretation" c:type="VipsInterpretation"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="574">image to get from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mode"
              c:identifier="vips_image_get_mode"
              glib:get-property="mode">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="822">Image modes are things like `"t"`, meaning a memory buffer, and `"p"`
meaning a delayed computation.</doc>
        <source-position filename="libvips/include/vips/header.h" line="234"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="829">the image mode.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="824">image to get from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_n_pages" c:identifier="vips_image_get_n_pages">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="904">Fetch and sanity-check [const@META_N_PAGES]. Default to 1 if not present
or crazy.

This is the number of pages in the image file, not the number of pages that
have been loaded into @image.</doc>
        <source-position filename="libvips/include/vips/header.h" line="242"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="914">the number of pages in the image file</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="906">image to get from</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_n_subifds" c:identifier="vips_image_get_n_subifds">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="954">Fetch and sanity-check [const@META_N_SUBIFDS]. Default to 0 if not
present or crazy.</doc>
        <source-position filename="libvips/include/vips/header.h" line="244"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="961">the number of subifds in the image file</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="956">image to get from</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_offset" c:identifier="vips_image_get_offset">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="858">Matrix images can have an optional `offset` field for use by integer
convolution.</doc>
        <source-position filename="libvips/include/vips/header.h" line="238"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="865">the offset.</doc>
          <type name="gdouble" c:type="double"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="860">image to get from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_orientation" c:identifier="vips_image_get_orientation">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="977">Fetch and sanity-check [const@META_ORIENTATION]. Default to 1 (no rotate,
no flip) if not present or crazy.</doc>
        <source-position filename="libvips/include/vips/header.h" line="246"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="984">the image orientation.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="979">image to get from</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_orientation_swap"
              c:identifier="vips_image_get_orientation_swap">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="1001">Return `TRUE` if applying the orientation would swap width and height.</doc>
        <source-position filename="libvips/include/vips/header.h" line="248"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="1007">if width/height will swap</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1003">image to get from</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_page_height" c:identifier="vips_image_get_page_height">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="879">Multi-page images can have a page height. Fetch it, and sanity check it. If
page-height is not set, it defaults to the image height.</doc>
        <source-position filename="libvips/include/vips/header.h" line="240"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="886">the page height.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="881">image to get from</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_scale" c:identifier="vips_image_get_scale">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="837">Matrix images can have an optional `scale` field for use by integer
convolution.</doc>
        <source-position filename="libvips/include/vips/header.h" line="236"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="844">the scale.</doc>
          <type name="gdouble" c:type="double"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="839">image to get from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_string" c:identifier="vips_image_get_string">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="1923">Gets @out from @im under the name @name.
The field must be of type `G_TYPE_STRING` or `VIPS_TYPE_REF_STRING`.

Do not free @out.

Use [method@Image.get_as_string] to fetch any field as a string.

::: seealso
    [method@Image.get], [method@Image.get_typeof].</doc>
        <source-position filename="libvips/include/vips/header.h" line="313"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="1939">0 on success, -1 otherwise.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1925">image to get the header field from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1926">field name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1927">return field value</doc>
            <type name="utf8" c:type="const char**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_tile_height" c:identifier="vips_image_get_tile_height">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="1041">Fetch and sanity-check [const@META_TILE_HEIGHT]. Default to -1 (no tiling)
if not present or crazy.</doc>
        <source-position filename="libvips/include/vips/header.h" line="254"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="1048">the height of the tiles encoded in the image.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1043">image to get from</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_tile_size" c:identifier="vips_get_tile_size">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/thread.c"
             line="252">Pick a tile size and a buffer height for this image and the current
value of [func@concurrency_get]. The buffer height
will always be a multiple of tile_height.

The buffer height is the height of each buffer we fill in sink disc. Since
we have two buffers, the largest range of input locality is twice the output
buffer size, plus whatever margin we add for things like convolution.</doc>
        <source-position filename="libvips/include/vips/threadpool.h"
                         line="145"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="im" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/thread.c"
                 line="254">image to guess for</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="tile_width"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/thread.c"
                 line="255">return selected tile width</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
          <parameter name="tile_height"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/thread.c"
                 line="256">return selected tile height</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
          <parameter name="n_lines"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/thread.c"
                 line="257">return buffer height in scanlines</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_tile_width" c:identifier="vips_image_get_tile_width">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="1018">Fetch and sanity-check [const@META_TILE_WIDTH]. Default to -1 (no tiling)
if not present or crazy.</doc>
        <source-position filename="libvips/include/vips/header.h" line="252"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="1025">the width of the tiles encoded in the image.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1020">image to get from</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_typeof" c:identifier="vips_image_get_typeof">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="1445">Read the [alias@GObject.Type] for a header field. Returns zero if there
is no field of that name.

::: seealso
    [method@Image.get].</doc>
        <source-position filename="libvips/include/vips/header.h" line="276"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="1456">the [alias@GObject.Type] of the field, or zero if there is no
  field of that name.</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1447">image to test</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1448">the name to search for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_width"
              c:identifier="vips_image_get_width"
              glib:get-property="width">
        <source-position filename="libvips/include/vips/header.h" line="206"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="390">the number of pixels across the image.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="388">image to get from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_xoffset"
              c:identifier="vips_image_get_xoffset"
              glib:get-property="xoffset">
        <source-position filename="libvips/include/vips/header.h" line="228"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="789">the horizontal position of the image origin, in pixels.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="787">image to get from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_xres"
              c:identifier="vips_image_get_xres"
              glib:get-property="xres">
        <source-position filename="libvips/include/vips/header.h" line="224"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="765">the horizontal image resolution in pixels per millimeter.</doc>
          <type name="gdouble" c:type="double"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="763">image to get from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_yoffset"
              c:identifier="vips_image_get_yoffset"
              glib:get-property="yoffset">
        <source-position filename="libvips/include/vips/header.h" line="230"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="801">the vertical position of the image origin, in pixels.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="799">image to get from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_yres"
              c:identifier="vips_image_get_yres"
              glib:get-property="yres">
        <source-position filename="libvips/include/vips/header.h" line="226"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="777">the vertical image resolution in pixels per millimeter.</doc>
          <type name="gdouble" c:type="double"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="775">image to get from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="getpoint" c:identifier="vips_getpoint" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/getpoint.c"
             line="187">Reads a single pixel on an image.

The pixel values are returned in @vector, the length of the
array in @n. You must free the array with [func@GLib.free] when you are
done with it.

The result array has an element for each band. If @unpack_complex is set,
pixels in complex images are returned as double-length arrays.

This operation is slow. If you want to read many points, use
[method@Image.write_to_memory].

::: seealso
    [method@Image.draw_point], [method@Image.write_to_memory].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="551"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/getpoint.c"
               line="211">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/getpoint.c"
                 line="189">image to read from</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="vector"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/getpoint.c"
                 line="190">output pixel value here</doc>
            <array length="1" zero-terminated="0" c:type="double**">
              <type name="gdouble" c:type="double*"/>
            </array>
          </parameter>
          <parameter name="n"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/getpoint.c"
                 line="191">length of output vector</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/getpoint.c"
                 line="192">position to read</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/getpoint.c"
                 line="193">position to read</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/getpoint.c"
                 line="194">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="gifsave" c:identifier="vips_gifsave" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/cgifsave.c"
             line="1131">Write to a file in GIF format.

Use @dither to set the degree of Floyd-Steinberg dithering
and @effort to control the CPU effort (1 is the fastest,
10 is the slowest, 7 is the default).

Use @bitdepth (from 1 to 8, default 8) to control the number
of colours in the palette. The first entry in the palette is
always reserved for transparency. For example, a bitdepth of
4 will allow the output to contain up to 15 colours.

Use @interframe_maxerror to set the threshold below which pixels are
considered equal.
Pixels which don't change from frame to frame can be made transparent,
improving the compression rate. Default 0.

Use @interpalette_maxerror to set the threshold below which the
previously generated palette will be reused.

If @reuse is `TRUE`, the GIF will be saved with a single global
palette taken from the metadata in @in, and no new palette optimisation
will be done.

If @interlace is `TRUE`, the GIF file will be interlaced (progressive GIF).
These files may be better for display over a slow network
connection, but need more memory to encode.

If @keep_duplicate_frames is `TRUE`, duplicate frames in the input will be
kept in the output instead of combining them.

::: tip "Optional arguments"
    * @dither: `gdouble`, quantisation dithering level
    * @effort: `gint`, quantisation CPU effort
    * @bitdepth: `gint`, number of bits per pixel
    * @interframe_maxerror: `gdouble`, maximum inter-frame error for
      transparency
    * @reuse: `gboolean`, reuse palette from input
    * @interlace: `gboolean`, write an interlaced (progressive) GIF
    * @interpalette_maxerror: `gdouble`, maximum inter-palette error for
      palette reusage
    * @keep_duplicate_frames: `gboolean`, keep duplicate frames in the output
      instead of combining them

::: seealso
    [ctor@Image.new_from_file].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="898"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/cgifsave.c"
               line="1183">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/cgifsave.c"
                 line="1133">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/cgifsave.c"
                 line="1134">file to write to</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/cgifsave.c"
                 line="1135">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="gifsave_buffer"
              c:identifier="vips_gifsave_buffer"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/cgifsave.c"
             line="1198">As [method@Image.gifsave], but save to a memory buffer.

The address of the buffer is returned in @buf, the length of the buffer in
@len. You are responsible for freeing the buffer with [func@GLib.free] when you
are done with it.

::: tip "Optional arguments"
    * @dither: `gdouble`, quantisation dithering level
    * @effort: `gint`, quantisation CPU effort
    * @bitdepth: `gint`, number of bits per pixel
    * @interframe_maxerror: `gdouble`, maximum inter-frame error for
      transparency
    * @reuse: `gboolean`, reuse palette from input
    * @interlace: `gboolean`, write an interlaced (progressive) GIF
    * @interpalette_maxerror: `gdouble`, maximum inter-palette error for
      palette reusage
    * @keep_duplicate_frames: `gboolean`, keep duplicate frames in the output
      instead of combining them

::: seealso
    [method@Image.gifsave], [method@Image.write_to_file].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="901"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/cgifsave.c"
               line="1227">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/cgifsave.c"
                 line="1200">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/cgifsave.c"
                 line="1201">return output buffer here</doc>
            <array length="1" zero-terminated="0" c:type="void**">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/cgifsave.c"
                 line="1202">return output length here</doc>
            <type name="gsize" c:type="size_t*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/cgifsave.c"
                 line="1203">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="gifsave_target"
              c:identifier="vips_gifsave_target"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/cgifsave.c"
             line="1257">As [method@Image.gifsave], but save to a target.

::: tip "Optional arguments"
    * @dither: `gdouble`, quantisation dithering level
    * @effort: `gint`, quantisation CPU effort
    * @bitdepth: `gint`, number of bits per pixel
    * @interframe_maxerror: `gdouble`, maximum inter-frame error for
      transparency
    * @reuse: `gboolean`, reuse palette from input
    * @interlace: `gboolean`, write an interlaced (progressive) GIF
    * @interpalette_maxerror: `gdouble`, maximum inter-palette error for
      palette reusage
    * @keep_duplicate_frames: `gboolean`, keep duplicate frames in the output
      instead of combining them

::: seealso
    [method@Image.gifsave], [method@Image.write_to_target].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="904"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/cgifsave.c"
               line="1281">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/cgifsave.c"
                 line="1259">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/cgifsave.c"
                 line="1260">save image to this target</doc>
            <type name="Target" c:type="VipsTarget*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/cgifsave.c"
                 line="1261">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="globalbalance"
              c:identifier="vips_globalbalance"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/mosaicing/global_balance.c"
             line="1950">[method@Image.globalbalance] can be used to remove contrast differences in
an assembled mosaic.

It reads the History field attached to @in and builds a list of the source
images that were used to make the mosaic and the position that each ended
up at in the final image.

It opens each of the source images in turn and extracts all parts which
overlap with any of the other images. It finds the average values in the
overlap areas and uses least-mean-square to find a set of correction
factors which will minimise overlap differences. It uses @gamma to
gamma-correct the source images before calculating the factors. A value of
1.0 will stop this.

Each of the source images is transformed with the appropriate correction
factor, then the mosaic is reassembled. @out is
[enum@Vips.BandFormat.FLOAT], but if @int_output is set, the output image
is the same format as the input images.

There are some conditions that must be met before this operation can work:
the source images must all be present under the filenames recorded in the
history on @in, and the mosaic must have been built using only operations in
this package.

::: tip "Optional arguments"
    * @gamma: `gdouble`, gamma of source images
    * @int_output: `gboolean`, `TRUE` for integer image output

::: seealso
    [method@Image.mosaic].</doc>
        <source-position filename="libvips/include/vips/mosaicing.h"
                         line="64"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/mosaicing/global_balance.c"
               line="1987">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/global_balance.c"
                 line="1952">mosaic to rebuild</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/global_balance.c"
                 line="1953">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/global_balance.c"
                 line="1954">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="gravity" c:identifier="vips_gravity" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/embed.c"
             line="824">The opposite of [method@Image.extract_area]: place @in within an image of
size @width by @height at a certain gravity.

@extend controls what appears in the new pels, see [enum@Extend].

::: tip "Optional arguments"
    * @extend: [enum@Extend] to generate the edge pixels
      (default: [enum@Vips.Extend.BLACK])
    * @background: [struct@ArrayDouble] colour for edge pixels

::: seealso
    [method@Image.extract_area], [method@Image.insert].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="158"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/embed.c"
               line="846">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/embed.c"
                 line="826">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/embed.c"
                 line="827">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="direction" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/embed.c"
                 line="828">place @in at this direction in @out</doc>
            <type name="CompassDirection" c:type="VipsCompassDirection"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/embed.c"
                 line="829">@out should be this many pixels across</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/embed.c"
                 line="830">@out should be this many pixels down</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/embed.c"
                 line="831">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="grid" c:identifier="vips_grid" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/grid.c"
             line="234">Chop a tall thin image up into a set of tiles, lay the tiles out in a grid.

The input image should be a very tall, thin image containing a list of
smaller images. Volumetric or time-sequence images are often laid out like
this. This image is chopped into a series of tiles, each @tile_height
pixels high and the width of @in. The tiles are then rearranged into a grid
@across tiles across and @down tiles down in row-major order.

Supplying @tile_height, @across and @down is not strictly necessary, we
only really need two of these. Requiring three is a double-check that the
image has the expected geometry.

::: seealso
    [method@Image.embed], [method@Image.insert], [method@Image.join].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="193"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/grid.c"
               line="258">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/grid.c"
                 line="236">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/grid.c"
                 line="237">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="tile_height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/grid.c"
                 line="238">chop into tiles this high</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="across" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/grid.c"
                 line="239">tiles across</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="down" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/grid.c"
                 line="240">tiles down</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/grid.c"
                 line="241">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="guess_format" c:identifier="vips_image_guess_format">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="475">Return the [enum@BandFormat] for an image, guessing a sane value if
the set value looks crazy.

For example, for a float image tagged as rgb16, we'd return ushort.</doc>
        <source-position filename="libvips/include/vips/header.h" line="216"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="484">a sensible [enum@BandFormat] for the image.</doc>
          <type name="BandFormat" c:type="VipsBandFormat"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="477">image to guess for</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="guess_interpretation"
              c:identifier="vips_image_guess_interpretation">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="659">Return the [enum@Interpretation] for an image, guessing a sane value if
the set value looks crazy.</doc>
        <source-position filename="libvips/include/vips/header.h" line="222"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="666">a sensible [enum@Interpretation] for the image.</doc>
          <type name="Interpretation" c:type="VipsInterpretation"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="661">image to guess for</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="hasalpha" c:identifier="vips_image_hasalpha">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="3077">Look at an image's interpretation and see if it has extra alpha bands. For
example, a 4-band [enum@Vips.Interpretation.sRGB] would, but a six-band
[enum@Vips.Interpretation.MULTIBAND] would not.

Return `TRUE` if @image has an alpha channel.</doc>
        <source-position filename="libvips/include/vips/image.h" line="549"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="3079">image to check</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="heifsave" c:identifier="vips_heifsave" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/foreign.c"
             line="2351">Write a VIPS image to a file in HEIF format.

Use @Q to set the compression factor. Default 50, which seems to be roughly
what the iphone uses. Q 30 gives about the same quality as JPEG Q 75.

Set @lossless `TRUE` to switch to lossless compression.

Use @compression to set the compression format e.g. HEVC, AVC, AV1 to use.
It defaults to AV1 if the target filename ends with ".avif", otherwise HEVC.

Use @effort to control the CPU effort spent improving compression.
This is currently only applicable to AV1 encoders. Defaults to 4, 0 is
fastest, 9 is slowest.

Chroma subsampling is normally automatically disabled for Q &gt;= 90. You can
force the subsampling mode with @subsample_mode.

Use @bitdepth to set the bitdepth of the output file. HEIC supports at
least 8, 10 and 12 bits; other codecs may support more or fewer options.

Use @encoder to set the encode library to use, e.g. aom, SVT-AV1, rav1e etc.

Use @tune to pass a set of tuning parameters to the encoder, see the
libheif documentation.

::: tip "Optional arguments"
    * @Q: `gint`, quality factor
    * @bitdepth: `gint`, set write bit depth to 8, 10, or 12 bits
    * @lossless: `gboolean`, enable lossless encoding
    * @compression: [enum@ForeignHeifCompression], write with this
      compression
    * @effort: `gint`, encoding effort
    * @subsample_mode: [enum@ForeignSubsample], chroma subsampling mode
    * @encoder: [enum@ForeignHeifEncoder], select encoder to use
    * @tune: `gchararray`, encoder tuning parameters

::: seealso
    [method@Image.write_to_file], [ctor@Image.heifload].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="947"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2396">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/foreign.c"
                 line="2353">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/foreign.c"
                 line="2354">file to write to</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/foreign.c"
                 line="2355">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="heifsave_buffer"
              c:identifier="vips_heifsave_buffer"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/foreign.c"
             line="2411">As [method@Image.heifsave], but save to a memory buffer.

The address of the buffer is returned in @obuf, the length of the buffer in
@olen. You are responsible for freeing the buffer with [func@GLib.free]
when you are done with it.

::: tip "Optional arguments"
    * @Q: `gint`, quality factor
    * @bitdepth: `gint`, set write bit depth to 8, 10, or 12 bits
    * @lossless: `gboolean`, enable lossless encoding
    * @compression: [enum@ForeignHeifCompression], write with this
      compression
    * @effort: `gint`, encoding effort
    * @subsample_mode: [enum@ForeignSubsample], chroma subsampling mode
    * @encoder: [enum@ForeignHeifEncoder], select encoder to use
    * @tune: `gchararray`, encoder tuning parameters

::: seealso
    [method@Image.heifsave], [method@Image.write_to_file].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="950"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2438">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/foreign.c"
                 line="2413">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/foreign.c"
                 line="2414">return output buffer here</doc>
            <array length="1" zero-terminated="0" c:type="void**">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/foreign.c"
                 line="2415">return output length here</doc>
            <type name="gsize" c:type="size_t*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/foreign.c"
                 line="2416">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="heifsave_target"
              c:identifier="vips_heifsave_target"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/foreign.c"
             line="2468">As [method@Image.heifsave], but save to a target.

::: tip "Optional arguments"
    * @Q: `gint`, quality factor
    * @bitdepth: `gint`, set write bit depth to 8, 10, or 12 bits
    * @lossless: `gboolean`, enable lossless encoding
    * @compression: [enum@ForeignHeifCompression], write with this
      compression
    * @effort: `gint`, encoding effort
    * @subsample_mode: [enum@ForeignSubsample], chroma subsampling mode
    * @encoder: [enum@ForeignHeifEncoder], select encoder to use
    * @tune: `gchararray`, encoder tuning parameters

::: seealso
    [method@Image.heifsave], [method@Image.write_to_target].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="953"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2490">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/foreign.c"
                 line="2470">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/foreign.c"
                 line="2471">save image to this target</doc>
            <type name="Target" c:type="VipsTarget*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/foreign.c"
                 line="2472">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="hist_cum" c:identifier="vips_hist_cum" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/histogram/hist_cum.c"
             line="169">Form cumulative histogram.

::: seealso
    [method@Image.hist_norm].</doc>
        <source-position filename="libvips/include/vips/histogram.h"
                         line="51"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/histogram/hist_cum.c"
               line="180">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/histogram/hist_cum.c"
                 line="171">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/histogram/hist_cum.c"
                 line="172">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/histogram/hist_cum.c"
                 line="173">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="hist_entropy"
              c:identifier="vips_hist_entropy"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/histogram/hist_entropy.c"
             line="129">Estimate image entropy from a histogram. Entropy is calculated as:

```
-sum(p * log2(p))
```

where p is histogram-value / sum-of-histogram-values.</doc>
        <source-position filename="libvips/include/vips/histogram.h"
                         line="73"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/histogram/hist_entropy.c"
               line="143">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/histogram/hist_entropy.c"
                 line="131">input histogram</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/histogram/hist_entropy.c"
                 line="132">image entropy</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/histogram/hist_entropy.c"
                 line="133">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="hist_equal"
              c:identifier="vips_hist_equal"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/histogram/hist_equal.c"
             line="139">Histogram-equalise @in.

Equalise using band @bandno, or if @bandno is -1,
equalise bands independently. The output format is always the same as the
input format.

::: tip "Optional arguments"
    * @band: `gint`, band to equalise</doc>
        <source-position filename="libvips/include/vips/histogram.h"
                         line="57"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/histogram/hist_equal.c"
               line="154">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/histogram/hist_equal.c"
                 line="141">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/histogram/hist_equal.c"
                 line="142">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/histogram/hist_equal.c"
                 line="143">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="hist_find"
              c:identifier="vips_hist_find"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/hist_find.c"
             line="450">Find the histogram of @in. Find the histogram for band @band (producing a
one-band histogram), or for all bands (producing an n-band histogram) if
@band is -1.

char and uchar images are cast to uchar before histogramming, all other
image types are cast to ushort.

::: tip "Optional arguments"
    * @band: `gint`, band to equalise

::: seealso
    [method@Image.hist_find_ndim], [method@Image.hist_find_indexed].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="554"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/hist_find.c"
               line="469">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/hist_find.c"
                 line="452">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/hist_find.c"
                 line="453">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/hist_find.c"
                 line="454">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="hist_find_indexed"
              c:identifier="vips_hist_find_indexed"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/hist_find_indexed.c"
             line="494">Make a histogram of @in, but use image @index to pick the bins. In other
words, element zero in @out contains the combination of all the pixels in @in
whose corresponding pixel in @index is zero.

char and uchar @index images are cast to uchar before histogramming, all
other image types are cast to ushort. @index must have just one band.

@in must be non-complex.

@out always has the same size and format as @in.

Normally, bins are summed, but you can use @combine to set other combine
modes.

This operation is useful in conjunction with [method@Image.labelregions].
You can use it to find the centre of gravity of blobs in an image, for
example.

::: tip "Optional arguments"
    * @combine: [enum@Combine], combine bins like this

::: seealso
    [method@Image.hist_find], [method@Image.labelregions].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="560"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/hist_find_indexed.c"
               line="526">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/hist_find_indexed.c"
                 line="496">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/hist_find_indexed.c"
                 line="497">input index [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/hist_find_indexed.c"
                 line="498">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/hist_find_indexed.c"
                 line="499">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="hist_find_ndim"
              c:identifier="vips_hist_find_ndim"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/hist_find_ndim.c"
             line="332">Make a one, two or three dimensional histogram of a 1, 2 or
3 band image. Divide each axis into @bins bins .. ie.
output is 1 x bins, bins x bins, or bins x bins x bins bands.
@bins defaults to 10.

char and uchar images are cast to uchar before histogramming, all other
image types are cast to ushort.

::: tip "Optional arguments"
    * @bins: `gint`, number of bins to make on each axis

::: seealso
    [method@Image.hist_find], [method@Image.hist_find_indexed].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="557"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/hist_find_ndim.c"
               line="352">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/hist_find_ndim.c"
                 line="334">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/hist_find_ndim.c"
                 line="335">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/hist_find_ndim.c"
                 line="336">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="hist_ismonotonic"
              c:identifier="vips_hist_ismonotonic"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/histogram/hist_ismonotonic.c"
             line="136">Test @in for monotonicity. @out is set non-zero if @in is monotonic.</doc>
        <source-position filename="libvips/include/vips/histogram.h"
                         line="70"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/histogram/hist_ismonotonic.c"
               line="144">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/histogram/hist_ismonotonic.c"
                 line="138">lookup-table to test</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/histogram/hist_ismonotonic.c"
                 line="139">set non-zero if @in is monotonic</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/histogram/hist_ismonotonic.c"
                 line="140">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="hist_local"
              c:identifier="vips_hist_local"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/histogram/hist_local.c"
             line="399">Performs local histogram equalisation on @in using a
window of size @width by @height centered on the input pixel.

The output image is the same size as the input image. The edge pixels are
created by mirroring the input image outwards.

If @max_slope is greater than 0, it sets the maximum value for the slope of
the cumulative histogram, that is, the maximum brightening that is
performed. A value of 3 is often used. Local histogram equalization with
contrast limiting is usually called CLAHE.

::: tip "Optional arguments"
    * @max_slope: `gint`, maximum brightening

::: seealso
    [method@Image.hist_equal].</doc>
        <source-position filename="libvips/include/vips/histogram.h"
                         line="66"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/histogram/hist_local.c"
               line="424">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/histogram/hist_local.c"
                 line="401">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/histogram/hist_local.c"
                 line="402">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/histogram/hist_local.c"
                 line="403">width of region</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/histogram/hist_local.c"
                 line="404">height of region</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/histogram/hist_local.c"
                 line="405">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="hist_match"
              c:identifier="vips_hist_match"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/histogram/hist_match.c"
             line="178">Adjust @in to match @ref. If @in and @ref are normalised
cumulative histograms, @out will be a LUT that adjusts the PDF of the image
from which @in was made to match the PDF of @ref's image.

::: seealso
    [method@Image.maplut], [method@Image.hist_find], [method@Image.hist_norm],
    [method@Image.hist_cum].</doc>
        <source-position filename="libvips/include/vips/histogram.h"
                         line="63"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/histogram/hist_match.c"
               line="193">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/histogram/hist_match.c"
                 line="180">input histogram</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="ref" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/histogram/hist_match.c"
                 line="181">reference histogram</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/histogram/hist_match.c"
                 line="182">output histogram</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/histogram/hist_match.c"
                 line="183">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="hist_norm"
              c:identifier="vips_hist_norm"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/histogram/hist_norm.c"
             line="158">Normalise histogram. The maximum of each band becomes equal to the maximum
index, so for example the max for a uchar image becomes 255.
Normalise each band separately.

::: seealso
    [method@Image.hist_cum].</doc>
        <source-position filename="libvips/include/vips/histogram.h"
                         line="54"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/histogram/hist_norm.c"
               line="171">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/histogram/hist_norm.c"
                 line="160">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/histogram/hist_norm.c"
                 line="161">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/histogram/hist_norm.c"
                 line="162">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="hist_plot"
              c:identifier="vips_hist_plot"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/histogram/hist_plot.c"
             line="350">Plot a 1 by any or any by 1 image file as a max by any or
any by max image using these rules:

*unsigned char* max is always 256

*other unsigned integer types* output 0 - maximum
value of @in.

*signed int types* min moved to 0, max moved to max + min.

*float types* min moved to 0, max moved to any
(square output)</doc>
        <source-position filename="libvips/include/vips/histogram.h"
                         line="60"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/histogram/hist_plot.c"
               line="369">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/histogram/hist_plot.c"
                 line="352">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/histogram/hist_plot.c"
                 line="353">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/histogram/hist_plot.c"
                 line="354">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="history_args" c:identifier="vips_image_history_args">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="2303">Formats the name/argv as a single string and calls
[method@Image.history_printf]. A convenience function for
command-line programs.

::: seealso
    [method@Image.get_history].</doc>
        <source-position filename="libvips/include/vips/header.h" line="342"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="2317">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="2305">image to attach history line to</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="2306">program name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="argc" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="2307">number of program arguments</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="argv" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="2308">program arguments</doc>
            <array length="1" zero-terminated="0" c:type="char**">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="history_printf"
              c:identifier="vips_image_history_printf"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="2243">Add a line to the image history. The @format and arguments are expanded, the
date and time is appended prefixed with a hash character, and the whole
string is appended to the image history and terminated with a newline.

For example:

```c
vips_image_history_printf(image, "vips invert %s %s",
    in-&gt;filename, out-&gt;filename);
```

Might add the string

```bash
"vips invert /home/john/fred.v /home/john/jim.v # Fri Apr 3 23:30:35 2009\n"
```

VIPS operations don't add history lines for you because a single action at
the application level might involve many VIPS operations. History must be
recorded by the application.</doc>
        <source-position filename="libvips/include/vips/header.h" line="339"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="2270">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="2245">add history line to this image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="2246">`printf()`-style format string</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="2247">arguments to format string</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="hough_circle"
              c:identifier="vips_hough_circle"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/hough_circle.c"
             line="262">Find the circular Hough transform of an image. @in must be one band, with
non-zero pixels for image edges. @out is three-band, with the third channel
representing the detected circle radius. The operation scales the number of
votes by circle circumference so circles of differing size are given equal
weight.

The output pixel at (x, y, band) is the strength of the circle centred on
(x, y) and with radius (band).

Use @max_radius and @min_radius to set the range of radii to search for.

Use @scale to set how @in coordinates are scaled to @out coordinates. A
@scale of 3, for example, will make @out 1/3rd of the width and height of
@in, and reduce the number of radii tested (and hence the number of bands
int @out) by a factor of three as well.

::: tip "Optional arguments"
    * @scale: `gint`, scale down dimensions by this much
    * @min_radius: `gint`, smallest radius to search for
    * @max_radius: `gint`, largest radius to search for

::: seealso
    [method@Image.hough_line].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="567"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/hough_circle.c"
               line="292">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/hough_circle.c"
                 line="264">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/hough_circle.c"
                 line="265">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/hough_circle.c"
                 line="266">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="hough_line"
              c:identifier="vips_hough_line"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/hough_line.c"
             line="170">Find the line Hough transform for @in. @in must have one band. @out has one
band, with pixels being the number of votes for that line. The X dimension
of @out is the line angle in 0 - 180 degrees, the Y dimension is the
distance of the closest part of that line to the origin in the top-left.

Use @width @height to set the size of the parameter space image (@out),
that is, how accurate the line determination should be.

::: tip "Optional arguments"
    * @width: `gint`, horizontal size of parameter space
    * @height: `gint`, vertical size of parameter space

::: seealso
    [method@Image.hough_circle].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="564"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/hough_line.c"
               line="191">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/hough_line.c"
                 line="172">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/hough_line.c"
                 line="173">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/hough_line.c"
                 line="174">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="icc_ac2rc" c:identifier="vips_icc_ac2rc">
        <doc xml:space="preserve"
             filename="libvips/colour/icc_transform.c"
             line="1263">Transform an image from absolute to relative colorimetry using the
MediaWhitePoint stored in the ICC profile.

::: seealso
    [method@Image.icc_transform], [method@Image.icc_import].</doc>
        <source-position filename="libvips/include/vips/colour.h" line="239"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/icc_transform.c"
               line="1275">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/icc_transform.c"
                 line="1265">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/colour/icc_transform.c"
                 line="1266">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="profile_filename" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/icc_transform.c"
                 line="1267">use this profile</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="icc_export"
              c:identifier="vips_icc_export"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/colour/icc_transform.c"
             line="1458">Export an image from D65 LAB to device space with an ICC profile.

If @pcs is set to [enum@Vips.PCS.XYZ], use CIE XYZ PCS instead.
If @output_profile is not set, use the embedded profile, if any.
If @output_profile is set, export with that and attach it to the output
image.

If @black_point_compensation is set, LCMS black point compensation is
enabled.

::: tip "Optional arguments"
    * @pcs: [enum@PCS], use XYZ or LAB PCS
    * @intent: [enum@Intent], transform with this intent
    * @black_point_compensation: `gboolean`, enable black point compensation
    * @output_profile: `gchararray`, get the output profile from here
    * @depth: `gint`, depth of output image in bits</doc>
        <source-position filename="libvips/include/vips/colour.h" line="236"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/icc_transform.c"
               line="1481">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/icc_transform.c"
                 line="1460">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/colour/icc_transform.c"
                 line="1461">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/icc_transform.c"
                 line="1462">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="icc_import"
              c:identifier="vips_icc_import"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/colour/icc_transform.c"
             line="1409">Import an image from device space to D65 LAB with an ICC profile.

If @pcs is set to [enum@Vips.PCS.XYZ], use CIE XYZ PCS instead.

The input profile is searched for in three places:

1. If @embedded is set, libvips will try to use any profile in the input
   image metadata. You can test for the presence of an embedded profile
   with [method@Image.get_typeof] with [const@META_ICC_NAME] as an
   argument. This will return [alias@GObject.Type] 0 if there is no profile.

2. Otherwise, if @input_profile is set, libvips will try to load a
   profile from the named file. This can also be the name of one of the
   built-in profiles.

3. Otherwise, libvips will try to pick a compatible profile from the set
   of built-in profiles.

If @black_point_compensation is set, LCMS black point compensation is
enabled.

::: tip "Optional arguments"
    * @pcs: [enum@PCS], use XYZ or LAB PCS
    * @intent: [enum@Intent], transform with this intent
    * @black_point_compensation: `gboolean`, enable black point compensation
    * @embedded: `gboolean`, use profile embedded in input image
    * @input_profile: `gchararray`, get the input profile from here</doc>
        <source-position filename="libvips/include/vips/colour.h" line="233"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/icc_transform.c"
               line="1443">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/icc_transform.c"
                 line="1411">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/colour/icc_transform.c"
                 line="1412">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/icc_transform.c"
                 line="1413">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="icc_transform"
              c:identifier="vips_icc_transform"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/colour/icc_transform.c"
             line="1496">Transform an image with a pair of ICC profiles.

The input image is moved to profile-connection space with the input
profile and then to the output space with the output profile.

The input profile is searched for in three places:

1. If @embedded is set, libvips will try to use any profile in the input
   image metadata. You can test for the presence of an embedded profile
   with [method@Image.get_typeof] with [const@META_ICC_NAME] as an
   argument. This will return [alias@GObject.Type] 0 if there is no profile.

2. Otherwise, if @input_profile is set, libvips will try to load a
   profile from the named file. This can also be the name of one of the
   built-in profiles.

3. Otherwise, libvips will try to pick a compatible profile from the set
   of built-in profiles.

If @black_point_compensation is set, LCMS black point compensation is
enabled.

@depth defaults to 8, or 16 if @in is a 16-bit image.

The output image has the output profile attached to the [const@META_ICC_NAME]
field.

Use [method@Image.icc_import] and [method@Image.icc_export] to do either
the first or second half of this operation in isolation.

::: tip "Optional arguments"
    * @pcs: [enum@PCS], use XYZ or LAB PCS
    * @intent: [enum@Intent], transform with this intent
    * @black_point_compensation: `gboolean`, enable black point compensation
    * @embedded: `gboolean`, use profile embedded in input image
    * @input_profile: `gchararray`, get the input profile from here
    * @depth: `gint`, depth of output image in bits</doc>
        <source-position filename="libvips/include/vips/colour.h" line="229"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/icc_transform.c"
               line="1541">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/icc_transform.c"
                 line="1498">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/colour/icc_transform.c"
                 line="1499">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="output_profile" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/icc_transform.c"
                 line="1500">get the output profile from here</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/icc_transform.c"
                 line="1501">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="ifthenelse"
              c:identifier="vips_ifthenelse"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/ifthenelse.c"
             line="559">This operation scans the condition image @cond
and uses it to select pixels from either the then image @in1 or the else
image @in2. Non-zero means @in1, 0 means @in2.

Any image can have either 1 band or n bands, where n is the same for all
the non-1-band images. Single band images are then effectively copied to
make n-band images.

Images @in1 and @in2 are cast up to the smallest common format. @cond is
cast to uchar.

If the images differ in size, the smaller images are enlarged to match the
largest by adding zero pixels along the bottom and right.

If @blend is `TRUE`, then values in @out are smoothly blended between @in1
and @in2 using the formula:

```
out = (cond / 255) * in1 + (1 - cond / 255) * in2
```

::: tip "Optional arguments"
    * @blend: `gboolean`, blend smoothly between @in1 and @in2

::: seealso
    [method@Image.equal].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="316"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/ifthenelse.c"
               line="594">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="cond" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/ifthenelse.c"
                 line="561">condition [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="in1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/ifthenelse.c"
                 line="562">then [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="in2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/ifthenelse.c"
                 line="563">else [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/ifthenelse.c"
                 line="564">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/ifthenelse.c"
                 line="565">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="imag" c:identifier="vips_imag" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/complex.c"
             line="844">Perform [enum@Vips.OperationComplexget.IMAG] on an image. See [method@Image.complexget].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="341"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/complex.c"
               line="852">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/complex.c"
                 line="846">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/complex.c"
                 line="847">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/complex.c"
                 line="848">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="init_fields" c:identifier="vips_image_init_fields">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="1123">A convenience function to set the header fields after creating an image.
Normally you copy the fields from your input images with
[method.Image.pipelinev] and then make any adjustments you need,
but if you are creating an image from scratch, for example
[ctor@Image.black] or [ctor@Image.jpegload], you do need to set all the
fields yourself.

::: seealso
    [method.Image.pipelinev].</doc>
        <source-position filename="libvips/include/vips/header.h" line="261"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1125">image to init</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="xsize" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1126">image width</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="ysize" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1127">image height</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="bands" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1128">image bands</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1129">band format</doc>
            <type name="BandFormat" c:type="VipsBandFormat"/>
          </parameter>
          <parameter name="coding" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1130">image coding</doc>
            <type name="Coding" c:type="VipsCoding"/>
          </parameter>
          <parameter name="interpretation" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1131">image type</doc>
            <type name="Interpretation" c:type="VipsInterpretation"/>
          </parameter>
          <parameter name="xres" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1132">horizontal resolution, pixels per millimetre</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="yres" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1133">vertical resolution, pixels per millimetre</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="inplace" c:identifier="vips_image_inplace">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="3532">Gets @image ready for an in-place operation, such as
[method@Image.draw_circle]. After calling this function you can both read
and write the image with [func@IMAGE_ADDR].

This method is called for you by the base class of the draw operations,
there's no need to call it yourself.

Since this function modifies @image, it is not thread-safe. Only call it on
images which you are sure have not been shared with another thread.
All in-place operations are inherently not thread-safe, so you need to take
great care in any case.

::: seealso
    [method@Image.draw_circle], [method@Image.wio_input].</doc>
        <source-position filename="libvips/include/vips/image.h" line="560"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="3551">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="3534">image to make read-write</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="insert" c:identifier="vips_insert" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/insert.c"
             line="514">Insert @sub into @main at position @x, @y.

Normally @out shows the whole of @main. If @expand is `TRUE` then @out is
made large enough to hold all of @main and @sub.
Any areas of @out not coming from
either @main or @sub are set to @background (default 0).

If @sub overlaps @main,
@sub will appear on top of @main.

If the number of bands differs, one of the images
must have one band. In this case, an n-band image is formed from the
one-band image by joining n copies of the one-band image together, and then
the two n-band images are operated upon.

The two input images are cast up to the smallest common type (see table
Smallest common format in
[arithmetic](libvips-arithmetic.html)).

::: tip "Optional arguments"
    * @expand: `gdouble`, expand output to hold whole of both images
    * @background: [struct@ArrayDouble], colour for new pixels

::: seealso
    [method@Image.join], [method@Image.embed], [method@Image.extract_area].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="165"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/insert.c"
               line="549">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="main" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/insert.c"
                 line="516">big image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="sub" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/insert.c"
                 line="517">small image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/insert.c"
                 line="518">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/insert.c"
                 line="519">left position of @sub</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/insert.c"
                 line="520">top position of @sub</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/insert.c"
                 line="521">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="invalidate_all" c:identifier="vips_image_invalidate_all">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="1367">Invalidate all pixel caches on @image and any downstream images, that
is, images which depend on this image. Additionally, all operations which
depend upon this image are dropped from the VIPS operation cache.

You should call this function after destructively modifying an image with
something like [method@Image.draw_circle].

The [signal@Image::invalidate] signal is emitted for all invalidated images.

::: seealso
    [method@Region.invalidate].</doc>
        <source-position filename="libvips/include/vips/image.h" line="440"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="1369">[class@Image] to invalidate</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="invert" c:identifier="vips_invert" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/invert.c"
             line="190">For unsigned formats, this operation calculates (max - @in), eg. (255 -
@in) for uchar. For signed and float formats, this operation calculates (-1
@in).

For complex images, only the real part is inverted. See also [method@Image.conj].

::: seealso
    [method@Image.linear].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="228"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/invert.c"
               line="205">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/invert.c"
                 line="192">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/invert.c"
                 line="193">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/invert.c"
                 line="194">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="invertlut"
              c:identifier="vips_invertlut"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/create/invertlut.c"
             line="307">Given a mask of target values and real values, generate a LUT which
will map reals to targets.

Handy for linearising images from measurements of a colour chart. All
values in [0,1]. Piecewise linear interpolation, extrapolate head and tail
to 0 and 1.

Eg. input like this:

```
4 3
0.1 0.2 0.3 0.1
0.2 0.4 0.4 0.2
0.7 0.5 0.6 0.3
```

Means a patch with 10% reflectance produces an image with 20% in
channel 1, 30% in channel 2, and 10% in channel 3, and so on.

Inputs don't need to be sorted (we do that). Generate any precision
LUT, default to 256 elements.

It won't work too well for non-monotonic camera responses
(we should fix this). Interpolation is simple piecewise linear; we ought to
do something better really.

::: tip "Optional arguments"
    * @size: `gint`, generate this much

::: seealso
    [method@Image.buildlut].</doc>
        <source-position filename="libvips/include/vips/create.h" line="101"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/invertlut.c"
               line="345">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/create/invertlut.c"
                 line="309">input mask</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/create/invertlut.c"
                 line="310">output LUT</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/create/invertlut.c"
                 line="311">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="invfft" c:identifier="vips_invfft" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/freqfilt/invfft.c"
             line="281">Transform an image from Fourier space to real space.

The result is complex. If you are OK with a real result, set @real,
it's quicker.

VIPS uses the fftw Fourier Transform library. If this library was not
available when VIPS was configured, these functions will fail.

::: tip "Optional arguments"
    * @real: `gboolean`, only output the real part

::: seealso
    [method@Image.fwfft].</doc>
        <source-position filename="libvips/include/vips/freqfilt.h" line="45"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/freqfilt/invfft.c"
               line="301">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/freqfilt/invfft.c"
                 line="283">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/freqfilt/invfft.c"
                 line="284">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/freqfilt/invfft.c"
                 line="285">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="isMSBfirst" c:identifier="vips_image_isMSBfirst">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="3017">Return `TRUE` if @image is in most-significant-
byte first form. This is the byte order used on the SPARC
architecture and others.</doc>
        <source-position filename="libvips/include/vips/image.h" line="543"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="3019">image to test</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_sequential" c:identifier="vips_image_is_sequential">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="1437">`TRUE` if any of the images upstream from @image were opened in sequential
mode. Some operations change behaviour slightly in sequential mode to
optimize memory behaviour.</doc>
        <source-position filename="libvips/include/vips/image.h" line="446"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="1445">`TRUE` if @image is in sequential mode.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="1439">[class@Image] to minimise</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="isfile" c:identifier="vips_image_isfile">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="3034">Return `TRUE` if @image represents a file on disc in some way.</doc>
        <source-position filename="libvips/include/vips/image.h" line="545"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="3036">image to test</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="iskilled" c:identifier="vips_image_iskilled">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="1608">If @image has been killed (see [method@Image.set_kill]), set an error
message, clear the [class@Image].kill flag and return `TRUE`. Otherwise
return `FALSE`.

Handy for loops which need to run sets of threads which can fail.

::: seealso
    [method@Image.set_kill].</doc>
        <source-position filename="libvips/include/vips/image.h" line="458"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="1621">`TRUE` if @image has been killed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="1610">image to test</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ispartial" c:identifier="vips_image_ispartial">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="3062">Return `TRUE` if @im represents a partial image (a delayed calculation).</doc>
        <source-position filename="libvips/include/vips/image.h" line="547"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="3064">image to test</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="join" c:identifier="vips_join" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/join.c"
             line="290">Join @in1 and @in2 together, left-right or up-down depending on the value
of @direction.

If one is taller or wider than the
other, @out will be has high as the smaller. If @expand is `TRUE`, then
the output will be expanded to contain all of the input pixels.

Use @align to set the edge that the images align on. By default, they align
on the edge with the lower value coordinate.

Use @background to set the colour of any pixels in @out which are not
present in either @in1 or @in2.

Use @shim to set the spacing between the images. By default this is 0.

If the number of bands differs, one of the images
must have one band. In this case, an n-band image is formed from the
one-band image by joining n copies of the one-band image together, and then
the two n-band images are operated upon.

The two input images are cast up to the smallest common type (see table
Smallest common format in
[arithmetic](libvips-arithmetic.html)).

If you are going to be joining many thousands of images in a regular
grid, [func@Image.arrayjoin] is a better choice.

::: tip "Optional arguments"
    * @expand: `gboolean`, `TRUE` to expand the output image to hold all of
      the input pixels
    * @shim: `gint`, space between images, in pixels
    * @background: [struct@ArrayDouble], background ink colour
    * @align: [enumAlign], low, centre or high alignment

::: seealso
    [func@Image.arrayjoin], [method@Image.insert].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="169"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/join.c"
               line="335">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/join.c"
                 line="292">first input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="in2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/join.c"
                 line="293">second input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/join.c"
                 line="294">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="direction" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/join.c"
                 line="295">join horizontally or vertically</doc>
            <type name="Direction" c:type="VipsDirection"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/join.c"
                 line="296">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="jp2ksave" c:identifier="vips_jp2ksave" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/jp2ksave.c"
             line="1434">Write a VIPS image to a file in JPEG2000 format.

The saver supports 8, 16 and 32-bit int pixel
values, signed and unsigned. It supports greyscale, RGB, CMYK and
multispectral images.

Use @Q to set the compression quality factor. The default value
produces file with approximately the same size as regular JPEG Q 75.

Set @lossless to enable lossless compression.

Use @tile_width and @tile_height to set the tile size. The default is 512.

Chroma subsampling is normally disabled for compatibility. Set
@subsample_mode to auto to enable chroma subsample for Q &lt; 90. Subsample
mode uses YCC rather than RGB colourspace, and many jpeg2000 decoders do
not support this.

This operation always writes a pyramid.

::: tip "Optional arguments"
    * @Q: `gint`, quality factor
    * @lossless: `gboolean`, enables lossless compression
    * @tile_width: `gint`, tile width
    * @tile_height: `gint`, tile width
    * @subsample_mode: [enum@ForeignSubsample], chroma subsampling mode

::: seealso
    [method@Image.write_to_file], [ctor@Image.jp2kload].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="976"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/jp2ksave.c"
               line="1470">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/jp2ksave.c"
                 line="1436">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/jp2ksave.c"
                 line="1437">file to write to</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/jp2ksave.c"
                 line="1438">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="jp2ksave_buffer"
              c:identifier="vips_jp2ksave_buffer"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/jp2ksave.c"
             line="1485">As [method@Image.jp2ksave], but save to a target.

::: tip "Optional arguments"
    * @Q: `gint`, quality factor
    * @lossless: `gboolean`, enables lossless compression
    * @tile_width: `gint`, tile width
    * @tile_height: `gint`, tile width
    * @subsample_mode: [enum@ForeignSubsample], chroma subsampling mode

::: seealso
    [method@Image.jp2ksave], [method@Image.write_to_target].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="979"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/jp2ksave.c"
               line="1504">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/jp2ksave.c"
                 line="1487">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/jp2ksave.c"
                 line="1488">return output buffer here</doc>
            <array length="1" zero-terminated="0" c:type="void**">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/jp2ksave.c"
                 line="1489">return output length here</doc>
            <type name="gsize" c:type="size_t*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/jp2ksave.c"
                 line="1490">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="jp2ksave_target"
              c:identifier="vips_jp2ksave_target"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/jp2ksave.c"
             line="1534">As [method@Image.jp2ksave], but save to a target.

::: tip "Optional arguments"
    * @Q: `gint`, quality factor
    * @lossless: `gboolean`, enables lossless compression
    * @tile_width: `gint`, tile width
    * @tile_height: `gint`, tile width
    * @subsample_mode: [enum@ForeignSubsample], chroma subsampling mode

::: seealso
    [method@Image.jp2ksave], [method@Image.write_to_target].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="982"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/jp2ksave.c"
               line="1552">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/jp2ksave.c"
                 line="1536">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/jp2ksave.c"
                 line="1537">save image to this target</doc>
            <type name="Target" c:type="VipsTarget*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/jp2ksave.c"
                 line="1538">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="jpegsave" c:identifier="vips_jpegsave" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/jpegsave.c"
             line="517">Write a VIPS image to a file as JPEG.

Use @Q to set the JPEG compression factor. Default 75.

If @optimize_coding is set, the Huffman tables are optimized. This is
slightly slower and produces slightly smaller files.

If @interlace is set, the jpeg files will be interlaced (progressive jpeg,
in jpg parlance). These files may be better for display over a slow network
connection, but need much more memory to encode and decode.

Chroma subsampling is normally automatically disabled for Q &gt;= 90. You can
force the subsampling mode with @subsample_mode.

If @trellis_quant is set and the version of libjpeg supports it
(e.g. mozjpeg &gt;= 3.0), apply trellis quantisation to each 8x8 block.
Reduces file size but increases compression time.

If @overshoot_deringing is set and the version of libjpeg supports it
(e.g. mozjpeg &gt;= 3.0), apply overshooting to samples with extreme values
for example 0 and 255 for 8-bit. Overshooting may reduce ringing artifacts
from compression, in particular in areas where black text appears on a
white background.

If @optimize_scans is set and the version of libjpeg supports it
(e.g. mozjpeg &gt;= 3.0), split the spectrum of DCT coefficients into
separate scans. Reduces file size but increases compression time.

If @quant_table is set and the version of libjpeg supports it
(e.g. mozjpeg &gt;= 3.0) it selects the quantization table to use:

- 0  Tables from JPEG Annex K (vips and libjpeg default)
- 1  Flat table
- 2  Table tuned for MSSIM on Kodak image set
- 3  Table from ImageMagick by N. Robidoux (current mozjpeg default)
- 4  Table tuned for PSNR-HVS-M on Kodak image set
- 5  Table from Relevance of Human Vision to JPEG-DCT Compression (1992)
- 6  Table from DCTune Perceptual Optimization of Compressed Dental
  X-Rays (1997)
- 7  Table from A Visual Detection Model for DCT Coefficient
  Quantization (1993)
- 8  Table from An Improved Detection Model for DCT Coefficient
  Quantization (1993)

Quantization table 0 is the default in vips and libjpeg(-turbo), but it
tends to favor detail over color accuracy, producing colored patches and
stripes as well as heavy banding in flat areas at high compression ratios.
Quantization table 2 is a good candidate to try if the default quantization
table produces banding or color shifts and is well suited for hires images.
Quantization table 3 is the default in mozjpeg and has been tuned to produce
good results at the default quality setting; banding at high compression.
Quantization table 4 is the most accurate at the cost of compression ratio.
Tables 5-7 are based on older research papers, but generally achieve worse
compression ratios and/or quality than 2 or 4.

For maximum compression with mozjpeg, a useful set of options is `strip,
optimize-coding, interlace, optimize-scans, trellis-quant, quant_table=3`.

By default, the output stream won't have restart markers.  If a non-zero
restart_interval is specified, a restart marker will be added after each
specified number of MCU blocks.  This makes the stream more recoverable
if there are transmission errors, but also allows for some decoders to read
part of the JPEG without decoding the whole stream.

The image is automatically converted to RGB, Monochrome or CMYK before
saving.

EXIF data is constructed from [const@META_EXIF_NAME], then
modified with any other related tags on the image before being written to
the file. [const@META_RESOLUTION_UNIT] is used to set the EXIF resolution
unit. [const@META_ORIENTATION] is used to set the EXIF orientation tag.

IPTC as [const@META_IPTC_NAME] and XMP as [const@META_XMP_NAME]
are coded and attached.

::: tip "Optional arguments"
    * @Q: `gint`, quality factor
    * @optimize_coding: `gboolean`, compute optimal Huffman coding tables
    * @interlace: `gboolean`, write an interlaced (progressive) jpeg
    * @subsample_mode: [enum@ForeignSubsample], chroma subsampling mode
    * @trellis_quant: `gboolean`, apply trellis quantisation to each 8x8 block
    * @overshoot_deringing: `gboolean`, overshoot samples with extreme values
    * @optimize_scans: `gboolean`, split DCT coefficients into separate scans
    * @quant_table: `gint`, quantization table index
    * @restart_interval: `gint`, restart interval in mcu

::: seealso
    [method@Image.jpegsave_buffer], [method@Image.write_to_file].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="518"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/jpegsave.c"
               line="612">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/jpegsave.c"
                 line="519">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/jpegsave.c"
                 line="520">file to write to</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/jpegsave.c"
                 line="521">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="jpegsave_buffer"
              c:identifier="vips_jpegsave_buffer"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/jpegsave.c"
             line="664">As [method@Image.jpegsave], but save to a memory buffer.

The address of the buffer is returned in @obuf, the length of the buffer in
@olen. You are responsible for freeing the buffer with [func@GLib.free]
when you are done with it.

::: tip "Optional arguments"
    * @Q: `gint`, quality factor
    * @optimize_coding: `gboolean`, compute optimal Huffman coding tables
    * @interlace: `gboolean`, write an interlaced (progressive) jpeg
    * @subsample_mode: [enum@ForeignSubsample], chroma subsampling mode
    * @trellis_quant: `gboolean`, apply trellis quantisation to each 8x8 block
    * @overshoot_deringing: `gboolean`, overshoot samples with extreme values
    * @optimize_scans: `gboolean`, split DCT coefficients into separate scans
    * @quant_table: `gint`, quantization table index
    * @restart_interval: `gint`, restart interval in mcu

::: seealso
    [method@Image.jpegsave], [method@Image.write_to_file].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="521"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/jpegsave.c"
               line="691">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/jpegsave.c"
                 line="666">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/jpegsave.c"
                 line="667">return output buffer here</doc>
            <array length="1" zero-terminated="0" c:type="void**">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/jpegsave.c"
                 line="668">return output length here</doc>
            <type name="gsize" c:type="size_t*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/jpegsave.c"
                 line="669">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="jpegsave_mime"
              c:identifier="vips_jpegsave_mime"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/jpegsave.c"
             line="721">As [method@Image.jpegsave], but save as a mime jpeg on stdout.

::: tip "Optional arguments"
    * @Q: `gint`, quality factor
    * @optimize_coding: `gboolean`, compute optimal Huffman coding tables
    * @interlace: `gboolean`, write an interlaced (progressive) jpeg
    * @subsample_mode: [enum@ForeignSubsample], chroma subsampling mode
    * @trellis_quant: `gboolean`, apply trellis quantisation to each 8x8 block
    * @overshoot_deringing: `gboolean`, overshoot samples with extreme values
    * @optimize_scans: `gboolean`, split DCT coefficients into separate scans
    * @quant_table: `gint`, quantization table index
    * @restart_interval: `gint`, restart interval in mcu

::: seealso
    [method@Image.jpegsave], [method@Image.write_to_file].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="524"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/jpegsave.c"
               line="742">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/jpegsave.c"
                 line="723">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/jpegsave.c"
                 line="724">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="jpegsave_target"
              c:identifier="vips_jpegsave_target"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/jpegsave.c"
             line="627">As [method@Image.jpegsave], but save to a target.

::: tip "Optional arguments"
    * @Q: `gint`, quality factor
    * @optimize_coding: `gboolean`, compute optimal Huffman coding tables
    * @interlace: `gboolean`, write an interlaced (progressive) jpeg
    * @subsample_mode: [enum@ForeignSubsample], chroma subsampling mode
    * @trellis_quant: `gboolean`, apply trellis quantisation to each 8x8 block
    * @overshoot_deringing: `gboolean`, overshoot samples with extreme values
    * @optimize_scans: `gboolean`, split DCT coefficients into separate scans
    * @quant_table: `gint`, quantization table index
    * @restart_interval: `gint`, restart interval in mcu

::: seealso
    [method@Image.jpegsave], [method@Image.write_to_target].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="515"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/jpegsave.c"
               line="649">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/jpegsave.c"
                 line="629">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/jpegsave.c"
                 line="630">save image to this target</doc>
            <type name="Target" c:type="VipsTarget*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/jpegsave.c"
                 line="631">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="jxlsave" c:identifier="vips_jxlsave" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/foreign.c"
             line="2588">Write a VIPS image to a file in JPEG-XL format. The image can be unsigned
8 or 16-bit integer, or float. Use @bitdepth for fine control of the image
bitdepth.

@tier sets the overall decode speed the encoder will target. Minimum is 0
(highest quality), and maximum is 4 (lowest quality). Default is 0.

@distance sets the target maximum encoding error. Minimum is 0
(highest quality), and maximum is 15 (lowest quality). Default is 1.0
(visually lossless).

As a convenience, you can also use @Q to set @distance. @Q uses
approximately the same scale as regular JPEG.

@bitdepth sets the bitdepth to save at. It defaults to the full range of
the image numeric type, but can be set lower. It has no effect on float
images.

Set @lossless to enable lossless compression.

::: tip "Optional arguments"
    * @tier: `gint`, decode speed tier
    * @distance: `gdouble`, maximum encoding error
    * @effort: `gint`, encoding effort
    * @lossless: `gboolean`, enables lossless compression
    * @Q: `gint`, quality setting
    * @bitdepth: `gint`, image bitdepth</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="995"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2622">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/foreign.c"
                 line="2590">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/foreign.c"
                 line="2591">file to write to</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/foreign.c"
                 line="2592">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="jxlsave_buffer"
              c:identifier="vips_jxlsave_buffer"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/foreign.c"
             line="2637">As [method@Image.jxlsave], but save to a memory buffer.

::: tip "Optional arguments"
    * @tier: `gint`, decode speed tier
    * @distance: `gdouble`, maximum encoding error
    * @effort: `gint`, encoding effort
    * @lossless: `gboolean`, enables lossless compression
    * @Q: `gint`, quality setting

::: seealso
    [method@Image.jxlsave], [method@Image.write_to_target].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="998"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2656">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/foreign.c"
                 line="2639">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/foreign.c"
                 line="2640">return output buffer here</doc>
            <array length="1" zero-terminated="0" c:type="void**">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/foreign.c"
                 line="2641">return output length here</doc>
            <type name="gsize" c:type="size_t*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/foreign.c"
                 line="2642">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="jxlsave_target"
              c:identifier="vips_jxlsave_target"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/foreign.c"
             line="2686">As [method@Image.jxlsave], but save to a target.

::: tip "Optional arguments"
    * @tier: `gint`, decode speed tier
    * @distance: `gdouble`, maximum encoding error
    * @effort: `gint`, encoding effort
    * @lossless: `gboolean`, enables lossless compression
    * @Q: `gint`, quality setting

::: seealso
    [method@Image.jxlsave], [method@Image.write_to_target].</doc>
        <source-position filename="libvips/include/vips/foreign.h"
                         line="1001"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2704">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/foreign.c"
                 line="2688">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/foreign.c"
                 line="2689">save image to this target</doc>
            <type name="Target" c:type="VipsTarget*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/foreign.c"
                 line="2690">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="labelregions"
              c:identifier="vips_labelregions"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/morphology/labelregions.c"
             line="143">Label regions of equal pixels in an image.

Repeatedly scans @in for regions of 4-connected pixels
with the same pixel value. Every time a region is discovered, those
pixels are marked in @mask with a unique serial number. Once all pixels
have been labelled, the operation returns, setting @segments to the number
of discrete regions which were detected.

@mask is always a 1-band [enum@Vips.BandFormat.INT] image of the same
dimensions as @in.

This operation is useful for, for example, blob counting. You can use the
morphological operators to detect and isolate a series of objects, then use
[method@Image.labelregions] to number them all.

Use [method@Image.hist_find_indexed] to (for example) find blob coordinates.

::: tip "Optional arguments"
    * @segments: `gint`, output, number of regions found

::: seealso
    [method@Image.hist_find_indexed].</doc>
        <source-position filename="libvips/include/vips/morphology.h"
                         line="63"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/morphology/labelregions.c"
               line="172">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/morphology/labelregions.c"
                 line="145">image to test</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="mask" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/morphology/labelregions.c"
                 line="146">write labelled regions here</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/morphology/labelregions.c"
                 line="147">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="less" c:identifier="vips_less" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/relational.c"
             line="421">Perform [enum@Vips.OperationRelational.LESS] on a pair of images. See
[method@Image.relational].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="359"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/relational.c"
               line="431">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="423">left-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="424">right-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="425">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="426">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="less_const"
              c:identifier="vips_less_const"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/relational.c"
             line="743">Perform [enum@Vips.OperationRelational.LESS] on an image and a constant. See
[method@Image.relational_const].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="383"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/relational.c"
               line="754">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="745">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="746">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="747">array of constants</doc>
            <array length="2" zero-terminated="0" c:type="const double*">
              <type name="gdouble" c:type="double"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="748">number of constants in @c</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="749">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="less_const1"
              c:identifier="vips_less_const1"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/relational.c"
             line="933">Perform [enum@Vips.OperationRelational.LESS] on an image and a constant. See
[method@Image.relational_const].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="409"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/relational.c"
               line="943">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="935">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="936">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="937">constant</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="938">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="lesseq" c:identifier="vips_lesseq" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/relational.c"
             line="447">Perform [enum@Vips.OperationRelational.LESSEQ] on a pair of images. See
[method@Image.relational].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="362"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/relational.c"
               line="457">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="449">left-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="450">right-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="451">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="452">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="lesseq_const"
              c:identifier="vips_lesseq_const"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/relational.c"
             line="770">Perform [enum@Vips.OperationRelational.LESSEQ] on an image and a constant. See
[method@Image.relational_const].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="387"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/relational.c"
               line="781">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="772">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="773">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="774">array of constants</doc>
            <array length="2" zero-terminated="0" c:type="const double*">
              <type name="gdouble" c:type="double"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="775">number of constants in @c</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="776">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="lesseq_const1"
              c:identifier="vips_lesseq_const1"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/relational.c"
             line="959">Perform [enum@Vips.OperationRelational.LESSEQ] on an image and a constant. See
[method@Image.relational_const].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="412"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/relational.c"
               line="969">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="961">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="962">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="963">constant</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="964">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="linear" c:identifier="vips_linear" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/linear.c"
             line="494">Pass an image through a linear transform, ie. (@out = @in * @a + @b). Output
is float for integer input, double for double input, complex for
complex input and double complex for double complex input. Set @uchar to
output uchar pixels.

If the arrays of constants have just one element, that constant is used for
all image bands. If the arrays have more than one element and they have
the same number of elements as there are bands in the image, then
one array element is used for each band. If the arrays have more than one
element and the image only has a single band, the result is a many-band
image where each band corresponds to one array element.

::: tip "Optional arguments"
    * @uchar: `gboolean`, output uchar pixels

::: seealso
    [method@Image.linear1], [method@Image.add].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="210"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/linear.c"
               line="521">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/linear.c"
                 line="496">image to transform</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/linear.c"
                 line="497">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/linear.c"
                 line="498">array of constants for multiplication</doc>
            <array length="3" zero-terminated="0" c:type="const double*">
              <type name="gdouble" c:type="double"/>
            </array>
          </parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/linear.c"
                 line="499">array of constants for addition</doc>
            <array length="3" zero-terminated="0" c:type="const double*">
              <type name="gdouble" c:type="double"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/linear.c"
                 line="500">length of constant arrays</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/linear.c"
                 line="501">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="linear1" c:identifier="vips_linear1" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/linear.c"
             line="537">Run [method@Image.linear] with a single constant.

::: tip "Optional arguments"
    * @uchar: `gboolean`, output uchar pixels

::: seealso
    [method@Image.linear].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="214"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/linear.c"
               line="553">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/linear.c"
                 line="539">image to transform</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/linear.c"
                 line="540">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/linear.c"
                 line="541">constant for multiplication</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/linear.c"
                 line="542">constant for addition</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/linear.c"
                 line="543">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="linecache"
              c:identifier="vips_linecache"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/tilecache.c"
             line="1008">This operation behaves rather like [method@Image.copy] between images
@in and @out, except that it keeps a cache of computed scanlines.

The number of lines cached is enough for a small amount of non-local
access.

Each cache tile is made with a single call to [method@Region.prepare].

When the cache fills, a tile is chosen for reuse. If @access is
[enum@Vips.Access.RANDOM], then the least-recently-used tile is reused. If
@access is [enum@Vips.Access.SEQUENTIAL], then
the top-most tile is reused. @access defaults to [enum@Vips.Access.RANDOM].

@tile_height can be used to set the size of the strips that
[method@Image.linecache] uses. The default is 1 (a single scanline).

Normally, only a single thread at once is allowed to calculate tiles. If
you set @threaded to `TRUE`, [method@Image.linecache] will allow many
threads to calculate tiles at once and share the cache between them.

::: tip "Optional arguments"
    * @access: [enum@Access], hint expected access pattern
    * @tile_height: `gint`, height of tiles in cache
    * @threaded: `gboolean`, allow many threads

::: seealso
    [method@Image.tilecache].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="144"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/tilecache.c"
               line="1042">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/tilecache.c"
                 line="1010">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/tilecache.c"
                 line="1011">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/tilecache.c"
                 line="1012">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="log" c:identifier="vips_log" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/math.c"
             line="587">Perform [enum@Vips.OperationMath.LOG] on an image. See [method@Image.math].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="287"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/math.c"
               line="595">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="589">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="590">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="591">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="log10" c:identifier="vips_log10" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/math.c"
             line="610">Perform [enum@Vips.OperationMath.LOG10] on an image. See [method@Image.math].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="290"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/math.c"
               line="618">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="612">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="613">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="614">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="lshift" c:identifier="vips_lshift" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/boolean.c"
             line="417">Perform [enum@Vips.OperationBoolean.LSHIFT] on a pair of images. See
[method@Image.boolean].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="435"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/boolean.c"
               line="427">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="419">left-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="420">right-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="421">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="422">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="lshift_const"
              c:identifier="vips_lshift_const"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/boolean.c"
             line="737">Perform [enum@Vips.OperationBoolean.LSHIFT] on an image and an array of constants.
See [method@Image.boolean_const].

::: seealso
    [method@Image.boolean], [method@Image.boolean_const1].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="458"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/boolean.c"
               line="751">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="739">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="740">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="741">array of constants</doc>
            <array length="2" zero-terminated="0" c:type="const double*">
              <type name="gdouble" c:type="double"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="742">number of constants in @c</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="743">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="lshift_const1"
              c:identifier="vips_lshift_const1"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/boolean.c"
             line="913">Perform [enum@Vips.OperationBoolean.LSHIFT] on an image and a constant.
See [method@Image.boolean_const1].

::: seealso
    [method@Image.boolean], [method@Image.boolean_const].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="479"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/boolean.c"
               line="926">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="915">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="916">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="917">constant</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="918">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="magicksave"
              c:identifier="vips_magicksave"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/magicksave.c"
             line="57">Write an image using libMagick.

Use @quality to set the quality factor. Default 0.

Use @format to explicitly set the save format, for example, "BMP". Otherwise
the format is guessed from the filename suffix.

If @optimize_gif_frames is set, GIF frames are cropped to the smallest size
while preserving the results of the GIF animation. This takes some time for
computation but saves some time on encoding and produces smaller files in
some cases.

If @optimize_gif_transparency is set, pixels that don't change the image
through animation are made transparent. This takes some time for computation
but saves some time on encoding and produces smaller files in some cases.

@bitdepth specifies the number of bits per pixel. The image will be quantized
and dithered if the value is within the valid range (1 to 8).

::: tip "Optional arguments"
    * @quality: `gint`, quality factor
    * @format: `gchararray`, format to save as
    * @optimize_gif_frames: `gboolean`, apply GIF frames optimization
    * @optimize_gif_transparency: `gboolean`, apply GIF transparency
      optimization
    * @bitdepth: `gint`, number of bits per pixel

::: seealso
    [method@Image.magicksave_buffer], [ctor@Image.magickload].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="725"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/magicksave.c"
               line="93">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/magicksave.c"
                 line="59">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/magicksave.c"
                 line="60">file to write to</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/magicksave.c"
                 line="61">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="magicksave_buffer"
              c:identifier="vips_magicksave_buffer"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/magicksave.c"
             line="108">As [method@Image.magicksave], but save to a memory buffer.

The address of the buffer is returned in @obuf, the length of the buffer in
@olen. You are responsible for freeing the buffer with [func@GLib.free]
when you are done with it.

::: tip "Optional arguments"
    * @quality: `gint`, quality factor
    * @format: `gchararray`, format to save as
    * @optimize_gif_frames: `gboolean`, apply GIF frames optimization
    * @optimize_gif_transparency: `gboolean`, apply GIF transparency
      optimization
    * @bitdepth: `gint`, number of bits per pixel

::: seealso
    [method@Image.magicksave], [method@Image.write_to_file].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="728"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/magicksave.c"
               line="132">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/magicksave.c"
                 line="110">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/magicksave.c"
                 line="111">return output buffer here</doc>
            <array length="1" zero-terminated="0" c:type="void**">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/magicksave.c"
                 line="112">return output length here</doc>
            <type name="gsize" c:type="size_t*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/magicksave.c"
                 line="113">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="map" c:identifier="vips_image_map">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="1556">This function calls @fn for every header field, including every item of
metadata.

Like all _map functions, the user function should return `NULL` to continue
iteration, or a non-`NULL` pointer to indicate early termination.

::: seealso
    [method@Image.get_typeof], [method@Image.get].</doc>
        <source-position filename="libvips/include/vips/header.h" line="282"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="1571">`NULL` on success, the failing
  pointer otherwise.</doc>
          <type name="gpointer" c:type="void*"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1558">image to map over</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="fn"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1559">function to call for each header field</doc>
            <type name="ImageMapFn" c:type="VipsImageMapFn"/>
          </parameter>
          <parameter name="a"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1560">user data for @fn</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
      <method name="mapim" c:identifier="vips_mapim" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/resample/mapim.c"
             line="596">This operator resamples @in using @index to look up pixels.

@out is the same size as @index, with each pixel being fetched from that
position in @in. That is:

```
out[x, y] = in[index[x, y]]
```

If @index has one band, that band must be complex. Otherwise, @index must
have two bands of any format.

Coordinates in @index are in pixels, with (0, 0) being the top-left corner
of @in, and with y increasing down the image. Use [ctor@Image.xyz] to
build index images.

@interpolate defaults to bilinear.

By default, new pixels are filled with @background. This defaults to
zero (black). You can set other extend types with @extend. [enum@Vips.Extend.COPY]
is better for image upsizing.

Image are normally treated as unpremultiplied, so this operation can be used
directly on PNG images. If your images have been through
[method@Image.premultiply], set @premultiplied.

This operation does not change xres or yres. The image resolution needs to
be updated by the application.

See [method@Image.maplut] for a 1D equivalent of this operation.

::: tip "Optional arguments"
    * @interpolate: [class@Interpolate], interpolate pixels with this
    * @extend: [enum@Vips.Extend], how to generate new pixels
    * @background: [struct@ArrayDouble], colour for new pixels
    * @premultiplied: `gboolean`, images are already premultiplied

::: seealso
    [ctor@Image.xyz], [method@Image.affine], [method@Image.resize],
    [method@Image.maplut], [class@Interpolate].</doc>
        <source-position filename="libvips/include/vips/resample.h"
                         line="114"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/resample/mapim.c"
               line="644">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/mapim.c"
                 line="598">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/resample/mapim.c"
                 line="599">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/mapim.c"
                 line="600">index image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/mapim.c"
                 line="601">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="maplut" c:identifier="vips_maplut" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/histogram/maplut.c"
             line="775">Map an image through another image acting as a LUT (Look Up Table).
The lut may have any type and the output image will be that type.

The input image will be cast to one of the unsigned integer types, that is,
[enum@Vips.BandFormat.UCHAR], [enum@Vips.BandFormat.USHORT] or [enum@Vips.BandFormat.UINT].

If @lut is too small for the input type (for example, if @in is
[enum@Vips.BandFormat.UCHAR] but @lut only has 100 elements), the lut is padded out
by copying the last element. Overflows are reported at the end of
computation.
If @lut is too large, extra values are ignored.

If @lut has one band and @band is -1 (the default), then all bands of @in
pass through @lut. If @band is &gt;= 0, then just that band of @in passes
through @lut and other bands are just copied.

If @lut
has same number of bands as @in, then each band is mapped
separately. If @in has one band, then @lut may have many bands and
the output will have the same number of bands as @lut.

::: tip "Optional arguments"
    * @band: `gint`, apply one-band @lut to this band of @in

::: seealso
    [method@Image.hist_find], [ctor@Image.identity].</doc>
        <source-position filename="libvips/include/vips/histogram.h"
                         line="42"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/histogram/maplut.c"
               line="809">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/histogram/maplut.c"
                 line="777">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/histogram/maplut.c"
                 line="778">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="lut" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/histogram/maplut.c"
                 line="779">look-up table</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/histogram/maplut.c"
                 line="780">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="match" c:identifier="vips_match" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/mosaicing/match.c"
             line="305">Scale, rotate and translate @sec so that the tie-points line up.

If @search is `TRUE`, before performing the transformation, the tie-points
are improved by searching an area of @sec of size @harea for a
match of size @hwindow to @ref.

This function will only work well for small rotates and scales.

::: tip "Optional arguments"
    * @search: `gboolean`, search to improve tie-points
    * @hwindow: `gint`, half window size
    * @harea: `gint`, half search size
    * @interpolate: [class@Interpolate], interpolate pixels with this</doc>
        <source-position filename="libvips/include/vips/mosaicing.h"
                         line="58"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/mosaicing/match.c"
               line="334">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="ref" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/match.c"
                 line="307">reference image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="sec" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/match.c"
                 line="308">secondary image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/match.c"
                 line="309">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="xr1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/match.c"
                 line="310">first reference tie-point</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="yr1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/match.c"
                 line="311">first reference tie-point</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="xs1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/match.c"
                 line="312">first secondary tie-point</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="ys1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/match.c"
                 line="313">first secondary tie-point</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="xr2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/match.c"
                 line="314">second reference tie-point</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="yr2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/match.c"
                 line="315">second reference tie-point</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="xs2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/match.c"
                 line="316">second secondary tie-point</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="ys2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/match.c"
                 line="317">second secondary tie-point</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/match.c"
                 line="318">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="math" c:identifier="vips_math" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/math.c"
             line="279">Perform various functions in -lm, the maths library, on images.

Angles are expressed in degrees. The output type is float unless the
input is double, in which case the output is double.

Non-complex images only.

::: seealso
    [method@Image.math2].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="259"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/math.c"
               line="296">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="281">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="282">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="math" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="283">math operation to perform</doc>
            <type name="OperationMath" c:type="VipsOperationMath"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="284">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="math2" c:identifier="vips_math2" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/math2.c"
             line="260">This operation calculates a 2-ary maths operation on a pair of images
and writes the result to @out. The images may have any
non-complex format. @out is float except in the case that either of @left
or @right are double, in which case @out is also double.

It detects division by zero, setting those pixels to zero in the output.
Beware: it does this silently!

If the images differ in size, the smaller image is enlarged to match the
larger by adding zero pixels along the bottom and right.

If the number of bands differs, one of the images
must have one band. In this case, an n-band image is formed from the
one-band image by joining n copies of the one-band image together, and then
the two n-band images are operated upon.

The two input images are cast up to the smallest common format (see table
Smallest common format in
[arithmetic](libvips-arithmetic.html)), and that format is the
result type.

::: seealso
    [method@Image.math2_const].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="486"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/math2.c"
               line="292">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="262">left-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="263">right-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="264">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="math2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="265">math operation to perform</doc>
            <type name="OperationMath2" c:type="VipsOperationMath2"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="266">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="math2_const"
              c:identifier="vips_math2_const"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/math2.c"
             line="505">This operation calculates various 2-ary maths operations on an image and
an array of constants and writes the result to @out.
The image may have any
non-complex format. @out is float except in the case that @in
is double, in which case @out is also double.

It detects division by zero, setting those pixels to zero in the output.
Beware: it does this silently!

If the array of constants has just one element, that constant is used for
all image bands. If the array has more than one element and they have
the same number of elements as there are bands in the image, then
one array element is used for each band. If the arrays have more than one
element and the image only has a single band, the result is a many-band
image where each band corresponds to one array element.

::: seealso
    [method@Image.math2], [method@Image.math].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="499"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/math2.c"
               line="533">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="507">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="508">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="math2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="509">math operation to perform</doc>
            <type name="OperationMath2" c:type="VipsOperationMath2"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="510">array of constants</doc>
            <array length="3" zero-terminated="0" c:type="const double*">
              <type name="gdouble" c:type="double"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="511">number of constants in @c</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="512">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="math2_const1"
              c:identifier="vips_math2_const1"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/math2.c"
             line="630">This operation calculates various 2-ary maths operations on an image and
a constant. See [method@Image.math2_const].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="515"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/math2.c"
               line="641">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="632">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="633">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="math2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="634">math operation to perform</doc>
            <type name="OperationMath2" c:type="VipsOperationMath2"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="635">constant</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="636">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="matrixinvert"
              c:identifier="vips_matrixinvert"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/mosaicing/matrixinvert.c"
             line="461">This operation calculates the inverse of the matrix represented in @m.
The scale and offset members of the input matrix are ignored.

::: seealso
    [ctor@Image.matrixload], [method@Image.matrixmultiply].</doc>
        <source-position filename="libvips/include/vips/mosaicing.h"
                         line="72"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/mosaicing/matrixinvert.c"
               line="473">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/matrixinvert.c"
                 line="463">matrix to invert</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/matrixinvert.c"
                 line="464">output matrix</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/matrixinvert.c"
                 line="465">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="matrixmultiply"
              c:identifier="vips_matrixmultiply"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/mosaicing/matrixmultiply.c"
             line="170">Multiplies two matrix images.

The scale and offset members of @left and @right are ignored.

::: seealso
    [method@Image.matrixinvert].</doc>
        <source-position filename="libvips/include/vips/mosaicing.h"
                         line="76"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/mosaicing/matrixmultiply.c"
               line="184">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/matrixmultiply.c"
                 line="172">input matrix</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/matrixmultiply.c"
                 line="173">input matrix</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/matrixmultiply.c"
                 line="174">output matrix</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/matrixmultiply.c"
                 line="175">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="matrixprint"
              c:identifier="vips_matrixprint"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/matrixsave.c"
             line="383">Print @in to %stdout in matrix format. See [ctor@Image.matrixload] for a
description of the format.

::: seealso
    [ctor@Image.matrixload].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="712"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/matrixsave.c"
               line="394">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/matrixsave.c"
                 line="385">image to print</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/matrixsave.c"
                 line="386">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="matrixsave"
              c:identifier="vips_matrixsave"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/matrixsave.c"
             line="330">Write @in to @filename in matrix format. See [ctor@Image.matrixload] for a
description of the format.

::: seealso
    [ctor@Image.matrixload].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="706"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/matrixsave.c"
               line="342">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/matrixsave.c"
                 line="332">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/matrixsave.c"
                 line="333">file to write to</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/matrixsave.c"
                 line="334">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="matrixsave_target"
              c:identifier="vips_matrixsave_target"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/matrixsave.c"
             line="357">As [method@Image.matrixsave], but save to a target.

::: seealso
    [method@Image.matrixsave].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="709"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/matrixsave.c"
               line="368">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/matrixsave.c"
                 line="359">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/matrixsave.c"
                 line="360">save image to this target</doc>
            <type name="Target" c:type="VipsTarget*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/matrixsave.c"
                 line="361">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="max" c:identifier="vips_max" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/max.c"
             line="507">This operation finds the maximum value in an image.

By default it finds the single largest value. If @size is set &gt;1, it will
find the @size largest values. It will stop searching early if has found
enough values.
Equal values will be sorted by y then x.

It operates on all
bands of the input image: use [method@Image.stats] if you need to find an
maximum for each band.

For complex images, this operation finds the maximum modulus.

You can read out the position of the maximum with @x and @y. You can read
out arrays of the values and positions of the top @size maxima with
@out_array, @x_array and @y_array. These values are returned sorted from
largest to smallest.

If there are more than @size maxima, the maxima returned will be a random
selection of the maxima in the image.

::: tip "Optional arguments"
    * @x: `gint`, output, horizontal position of maximum
    * @y: `gint`, output, vertical position of maximum
    * @size: `gint`, number of maxima to find
    * @out_array: [struct@ArrayDouble], output, array of maximum values
    * @x_array: [struct@ArrayInt], output, corresponding horizontal positions
    * @y_array: [struct@ArrayInt]. output, corresponding vertical positions

::: seealso
    [method@Image.min], [method@Image.stats].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="538"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/max.c"
               line="545">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/max.c"
                 line="509">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/max.c"
                 line="510">output pixel maximum</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/max.c"
                 line="511">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="maxpair" c:identifier="vips_maxpair" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/maxpair.c"
             line="163">For each pixel, pick the maximum of a pair of images.

::: seealso
    [method@Image.minpair].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="240"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/maxpair.c"
               line="175">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/maxpair.c"
                 line="165">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/maxpair.c"
                 line="166">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/maxpair.c"
                 line="167">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/maxpair.c"
                 line="168">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="measure" c:identifier="vips_measure" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/measure.c"
             line="254">Analyse a grid of colour patches, producing an array of patch averages.
The mask has a row for each measured patch and a column for each image
band. The operations issues a warning if any patch has a deviation more
than 20% of
the mean. Only the central 50% of each patch is averaged.

If the chart does not fill the whole image, use the optional @left, @top,
@width, @height arguments to indicate the
position of the chart.

::: tip "Optional arguments"
    * @left: `gint`, area of image containing chart
    * @top: `gint`, area of image containing chart
    * @width: `gint`, area of image containing chart
    * @height: `gint`, area of image containing chart

::: seealso
    [method@Image.avg], [method@Image.deviate].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="544"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/measure.c"
               line="281">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/measure.c"
                 line="256">image to measure</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/measure.c"
                 line="257">array of measurements</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="h" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/measure.c"
                 line="258">patches across chart</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/measure.c"
                 line="259">patches down chart</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/measure.c"
                 line="260">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="median" c:identifier="vips_median" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/morphology/rank.c"
             line="636">A convenience function equivalent to:

```c
vips_rank(in, out, size, size, (size * size) / 2);
```

::: seealso
    [method@Image.rank].</doc>
        <source-position filename="libvips/include/vips/morphology.h"
                         line="56"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/morphology/rank.c"
               line="652">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/morphology/rank.c"
                 line="638">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/morphology/rank.c"
                 line="639">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/morphology/rank.c"
                 line="640">size of region</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/morphology/rank.c"
                 line="641">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="merge" c:identifier="vips_merge" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/mosaicing/merge.c"
             line="174">This operation joins two images left-right (with @ref on the left) or
up-down (with @ref above) with a smooth seam.

If the number of bands differs, one of the images
must have one band. In this case, an n-band image is formed from the
one-band image by joining n copies of the one-band image together, and then
the two n-band images are operated upon.

The two input images are cast up to the smallest common type (see table
Smallest common format in
[arithmetic](libvips-arithmetic.html)).

@dx and @dy give the displacement of @sec relative to @ref, in other words,
the vector to get from the origin of @sec to the origin of @ref, in other
words, @dx will generally be a negative number.

@mblend limits the maximum width of the
blend area. A value of "-1" means "unlimited". The two images are blended
with a raised cosine.

Pixels with all bands equal to zero are "transparent", that
is, zero pixels in the overlap area do not contribute to the merge.
This makes it possible to join non-rectangular images.

::: tip "Optional arguments"
    * @mblend: `gint`, maximum blend size

::: seealso
    [method@Image.mosaic], [method@Image.insert].</doc>
        <source-position filename="libvips/include/vips/mosaicing.h"
                         line="42"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/mosaicing/merge.c"
               line="214">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="ref" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/merge.c"
                 line="176">reference image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="sec" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/merge.c"
                 line="177">secondary image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/merge.c"
                 line="178">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="direction" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/merge.c"
                 line="179">horizontal or vertical merge</doc>
            <type name="Direction" c:type="VipsDirection"/>
          </parameter>
          <parameter name="dx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/merge.c"
                 line="180">displacement of ref from sec</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="dy" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/merge.c"
                 line="181">displacement of ref from sec</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/merge.c"
                 line="182">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="min" c:identifier="vips_min" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/min.c"
             line="507">This operation finds the minimum value in an image.

By default it finds the single smallest value. If @size is set &gt;1, it will
find the @size smallest values. It will stop searching early if has found
enough values.
Equal values will be sorted by y then x.

It operates on all
bands of the input image: use [method@Image.stats] if you need to find an
minimum for each band.

For complex images, this operation finds the minimum modulus.

You can read out the position of the minimum with @x and @y. You can read
out arrays of the values and positions of the top @size minima with
@out_array, @x_array and @y_array.
These values are returned sorted from
smallest to largest.

If there are more than @size minima, the minima returned will be a random
selection of the minima in the image.

::: tip "Optional arguments"
    * @x: `gint`, output, horizontal position of minimum
    * @y: `gint`, output, vertical position of minimum
    * @size: `gint`, number of minima to find
    * @out_array: [struct@ArrayDouble], output, array of minimum values
    * @x_array: [struct@ArrayInt], output, corresponding horizontal positions
    * @y_array: [struct@ArrayInt], output, corresponding vertical positions

::: seealso
    [method@Image.min], [method@Image.stats].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="535"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/min.c"
               line="546">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/min.c"
                 line="509">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/min.c"
                 line="510">output pixel minimum</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/min.c"
                 line="511">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="minimise_all" c:identifier="vips_image_minimise_all">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="1408">Minimise memory use on this image and any upstream images, that is, images
which this image depends upon. This function is called automatically at the
end of a computation, but it might be useful to call at other times.

The [signal@Image::minimise] signal is emitted for all minimised images.</doc>
        <source-position filename="libvips/include/vips/image.h" line="443"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="1410">[class@Image] to minimise</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="minpair" c:identifier="vips_minpair" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/minpair.c"
             line="163">For each pixel, pick the minimum of a pair of images.

::: seealso
    [method@Image.minpair].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="243"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/minpair.c"
               line="175">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/minpair.c"
                 line="165">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/minpair.c"
                 line="166">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/minpair.c"
                 line="167">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/minpair.c"
                 line="168">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="more" c:identifier="vips_more" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/relational.c"
             line="369">Perform [enum@Vips.OperationRelational.MORE] on a pair of images. See
[method@Image.relational].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="365"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/relational.c"
               line="379">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="371">left-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="372">right-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="373">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="374">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="more_const"
              c:identifier="vips_more_const"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/relational.c"
             line="797">Perform [enum@Vips.OperationRelational.MORE] on an image and a constant. See
[method@Image.relational_const].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="391"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/relational.c"
               line="808">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="799">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="800">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="801">array of constants</doc>
            <array length="2" zero-terminated="0" c:type="const double*">
              <type name="gdouble" c:type="double"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="802">number of constants in @c</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="803">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="more_const1"
              c:identifier="vips_more_const1"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/relational.c"
             line="985">Perform [enum@Vips.OperationRelational.MORE] on an image and a constant. See
[method@Image.relational_const].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="415"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/relational.c"
               line="995">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="987">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="988">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="989">constant</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="990">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="moreeq" c:identifier="vips_moreeq" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/relational.c"
             line="395">Perform [enum@Vips.OperationRelational.MOREEQ] on a pair of images. See
[method@Image.relational].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="368"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/relational.c"
               line="405">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="397">left-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="398">right-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="399">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="400">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="moreeq_const"
              c:identifier="vips_moreeq_const"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/relational.c"
             line="824">Perform [enum@Vips.OperationRelational.MOREEQ] on an image and a constant. See
[method@Image.relational_const].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="395"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/relational.c"
               line="835">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="826">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="827">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="828">array of constants</doc>
            <array length="2" zero-terminated="0" c:type="const double*">
              <type name="gdouble" c:type="double"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="829">number of constants in @c</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="830">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="moreeq_const1"
              c:identifier="vips_moreeq_const1"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/relational.c"
             line="1011">Perform [enum@Vips.OperationRelational.MOREEQ] on an image and a constant. See
[method@Image.relational_const].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="418"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/relational.c"
               line="1021">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="1013">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="1014">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="1015">constant</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="1016">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="morph" c:identifier="vips_morph" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/morphology/morph.c"
             line="987">Performs a morphological operation on @in using @mask as a
structuring element.

The image should have 0 (black) for no object and 255
(non-zero) for an object. Note that this is the reverse of the usual
convention for these operations, but more convenient when combined with the
boolean operators. The output image is the same
size as the input image: edge pxels are made by expanding the input image
as necessary.

Mask coefficients can be either 0 (for object) or 255 (for background)
or 128 (for do not care).  The origin of the mask is at location
(m.xsize / 2, m.ysize / 2), integer division.  All algorithms have been
based on the book "Fundamentals of Digital Image Processing" by A. Jain,
pp 384-388, Prentice-Hall, 1989.

For [enum@Vips.OperationMorphology.ERODE],
the whole mask must match for the output pixel to be
set, that is, the result is the logical AND of the selected input pixels.

For [enum@Vips.OperationMorphology.DILATE],
the output pixel is set if any part of the mask
matches, that is, the result is the logical OR of the selected input pixels.

See the boolean operations [method@Image.andimage], [method@Image.orimage]
and [method@Image.eorimage]
for analogues of the usual set difference and set union operations.

Operations are performed using the processor's vector unit,
if possible. Disable this with `--vips-novector` or `VIPS_NOVECTOR` or
[func@vector_set_enabled].</doc>
        <source-position filename="libvips/include/vips/morphology.h"
                         line="48"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/morphology/morph.c"
               line="1027">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/morphology/morph.c"
                 line="989">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/morphology/morph.c"
                 line="990">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="mask" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/morphology/morph.c"
                 line="991">morphology with this mask</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="morph" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/morphology/morph.c"
                 line="992">operation to perform</doc>
            <type name="OperationMorphology" c:type="VipsOperationMorphology"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/morphology/morph.c"
                 line="993">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="mosaic" c:identifier="vips_mosaic" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/mosaicing/mosaic.c"
             line="311">This operation joins two images left-right (with @ref on the left) or
top-bottom (with @ref above) given an approximate overlap.

@sec is positioned so that the pixel (@xsec, @ysec) in @sec lies on top of
the pixel (@xref, @yref) in @ref. The overlap area is divided into three
sections, 20 high-contrast points in band @bandno of image @ref are found
in each, and a window of pixels of size @hwindow around each high-contrast
point is searched for in @sec over an area of @harea.

A linear model is fitted to the 60 tie-points, points a long way from the
fit are discarded, and the model refitted until either too few points
remain or the model reaches good agreement.

The detected displacement is used with [method@Image.merge] to join the
two images together.

You can read out the detected transform with @dx0, @dy0, @scale1, @angle1,
@dx1, @dy1.

::: tip "Optional arguments"
    * @bandno: `gint`, band to search for features
    * @hwindow: `gint`, half window size
    * @harea: `gint`, half search size
    * @mblend: `gint`, maximum blend size
    * @dx0: `gint`, output, detected displacement
    * @dy0: `gint`, output, detected displacement
    * @scale1: `gdouble`, output, detected first order scale
    * @angle1: `gdouble`, output, detected first order rotation
    * @dx1: `gdouble`, output, detected first order displacement
    * @dy1: `gdouble`, output, detected first order displacement

::: seealso
    [method@Image.merge], [method@Image.insert].</doc>
        <source-position filename="libvips/include/vips/mosaicing.h"
                         line="46"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/mosaicing/mosaic.c"
               line="357">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="ref" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/mosaic.c"
                 line="313">reference image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="sec" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/mosaic.c"
                 line="314">secondary image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/mosaic.c"
                 line="315">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="direction" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/mosaic.c"
                 line="316">horizontal or vertical join</doc>
            <type name="Direction" c:type="VipsDirection"/>
          </parameter>
          <parameter name="xref" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/mosaic.c"
                 line="317">position in reference image</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="yref" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/mosaic.c"
                 line="318">position in reference image</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="xsec" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/mosaic.c"
                 line="319">position in secondary image</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="ysec" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/mosaic.c"
                 line="320">position in secondary image</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/mosaic.c"
                 line="321">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="mosaic1" c:identifier="vips_mosaic1" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/mosaicing/mosaic1.c"
             line="628">This operation joins two images top-bottom (with @sec on the right)
or left-right (with @sec at the bottom)
given an approximate pair of tie-points. @sec is scaled and rotated as
necessary before the join.

If @search is `TRUE`, before performing the transformation, the tie-points
are improved by searching an area of @sec of size @harea for a
object of size @hwindow in @ref.

@mblend limits the maximum size of the
blend area. A value of "-1" means "unlimited". The two images are blended
with a raised cosine.

Pixels with all bands equal to zero are "transparent", that
is, zero pixels in the overlap area do not contribute to the merge.
This makes it possible to join non-rectangular images.

If the number of bands differs, one of the images
must have one band. In this case, an n-band image is formed from the
one-band image by joining n copies of the one-band image together, and then
the two n-band images are operated upon.

The two input images are cast up to the smallest common type (see table
Smallest common format in
[arithmetic](libvips-arithmetic.html)).

::: tip "Optional arguments"
    * @search: `gboolean`, search to improve tie-points
    * @hwindow: `gint`, half window size
    * @harea: `gint`, half search size
    * @interpolate: [class@Interpolate], interpolate pixels with this
    * @mblend: `gint`, maximum blend size

::: seealso
    [method@Image.merge], [method@Image.insert], [method@Image.globalbalance].</doc>
        <source-position filename="libvips/include/vips/mosaicing.h"
                         line="51"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/mosaicing/mosaic1.c"
               line="680">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="ref" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/mosaic1.c"
                 line="630">reference image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="sec" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/mosaic1.c"
                 line="631">secondary image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/mosaic1.c"
                 line="632">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="direction" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/mosaic1.c"
                 line="633">horizontal or vertical join</doc>
            <type name="Direction" c:type="VipsDirection"/>
          </parameter>
          <parameter name="xr1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/mosaic1.c"
                 line="634">first reference tie-point</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="yr1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/mosaic1.c"
                 line="635">first reference tie-point</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="xs1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/mosaic1.c"
                 line="636">first secondary tie-point</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="ys1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/mosaic1.c"
                 line="637">first secondary tie-point</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="xr2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/mosaic1.c"
                 line="638">second reference tie-point</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="yr2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/mosaic1.c"
                 line="639">second reference tie-point</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="xs2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/mosaic1.c"
                 line="640">second secondary tie-point</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="ys2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/mosaic1.c"
                 line="641">second secondary tie-point</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/mosaic1.c"
                 line="642">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="msb" c:identifier="vips_msb" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/msb.c"
             line="266">Turn any integer image to 8-bit unsigned char by discarding all but the most
significant byte. Signed values are converted to unsigned by adding 128.

Use @band to make a one-band 8-bit image.

This operator also works for LABQ coding.

::: tip "Optional arguments"
    * @band: `gint`, msb just this band

::: seealso
    [method@Image.scale], [method@Image.cast].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="266"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/msb.c"
               line="285">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/msb.c"
                 line="268">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/msb.c"
                 line="269">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/msb.c"
                 line="270">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="multiply" c:identifier="vips_multiply" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/multiply.c"
             line="207">This operation calculates @left * @right and writes the result to @out.

If the images differ in size, the smaller image is enlarged to match the
larger by adding zero pixels along the bottom and right.

If the number of bands differs, one of the images
must have one band. In this case, an n-band image is formed from the
one-band image by joining n copies of the one-band image together, and then
the two n-band images are operated upon.

The two input images are cast up to the smallest common format (see table
Smallest common format in
[arithmetic](libvips-arithmetic.html)), then the
following table is used to determine the output type:

## [method@Image.multiply] type promotion

| input type     | output type    |
|----------------|----------------|
| uchar          | ushort         |
| char           | short          |
| ushort         | uint           |
| short          | int            |
| uint           | uint           |
| int            | int            |
| float          | float          |
| double         | double         |
| complex        | complex        |
| double complex | double complex |

In other words, the output type is just large enough to hold the whole
range of possible values.

::: seealso
    [method@Image.add], [method@Image.linear].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="204"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/multiply.c"
               line="250">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/multiply.c"
                 line="209">left-hand image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/multiply.c"
                 line="210">right-hand image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/multiply.c"
                 line="211">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/multiply.c"
                 line="212">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="niftisave"
              c:identifier="vips_niftisave"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/niftisave.c"
             line="455">Write a VIPS image to a file in NIFTI format.

Use the various NIFTI suffixes to pick the nifti save format.

::: seealso
    [method@Image.write_to_file], [ctor@Image.niftiload].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="963"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/niftisave.c"
               line="468">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/niftisave.c"
                 line="457">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/niftisave.c"
                 line="458">file to write to</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/niftisave.c"
                 line="459">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="notequal" c:identifier="vips_notequal" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/relational.c"
             line="343">Perform [enum@Vips.OperationRelational.NOTEQ] on a pair of images. See
[method@Image.relational].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="356"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/relational.c"
               line="353">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="345">left-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="346">right-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="347">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="348">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="notequal_const"
              c:identifier="vips_notequal_const"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/relational.c"
             line="715">Perform [enum@Vips.OperationRelational.NOTEQ] on an image and a constant. See
[method@Image.relational_const].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="379"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/relational.c"
               line="726">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="717">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="718">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="719">array of constants</doc>
            <array length="2" zero-terminated="0" c:type="const double*">
              <type name="gdouble" c:type="double"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="720">number of constants in @c</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="721">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="notequal_const1"
              c:identifier="vips_notequal_const1"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/relational.c"
             line="907">Perform [enum@Vips.OperationRelational.NOTEQ] on an image and a constant. See
[method@Image.relational_const].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="406"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/relational.c"
               line="917">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="909">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="910">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="911">constant</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="912">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="orimage" c:identifier="vips_orimage" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/boolean.c"
             line="367">Perform [enum@Vips.OperationBoolean.OR] on a pair of images. See
[method@Image.boolean].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="429"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/boolean.c"
               line="377">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="369">left-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="370">right-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="371">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="372">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="orimage_const"
              c:identifier="vips_orimage_const"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/boolean.c"
             line="677">Perform [enum@Vips.OperationBoolean.OR] on an image and an array of constants.
See [method@Image.boolean_const].

::: seealso
    [method@Image.boolean], [method@Image.boolean_const1].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="450"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/boolean.c"
               line="691">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="679">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="680">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="681">array of constants</doc>
            <array length="2" zero-terminated="0" c:type="const double*">
              <type name="gdouble" c:type="double"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="682">number of constants in @c</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="683">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="orimage_const1"
              c:identifier="vips_orimage_const1"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/boolean.c"
             line="856">Perform [enum@Vips.OperationBoolean.OR] on an image and a constant.
See [method@Image.boolean_const1].

::: seealso
    [method@Image.boolean], [method@Image.boolean_const].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="473"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/boolean.c"
               line="869">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="858">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="859">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="860">constant</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="861">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="percent" c:identifier="vips_percent" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/histogram/percent.c"
             line="134">[method@Image.percent] returns (through the @threshold parameter) the threshold
below which there are @percent values of @in. For example:

```bash
$ vips percent k2.jpg 90
214
```

Means that 90% of pixels in `k2.jpg` have a value less than 214.

The function works for uchar and ushort images only.  It can be used
to threshold the scaled result of a filtering operation.

::: seealso
    [method@Image.hist_find], [method@Image.profile].</doc>
        <source-position filename="libvips/include/vips/histogram.h"
                         line="45"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/histogram/percent.c"
               line="157">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/histogram/percent.c"
                 line="136">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="percent" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/histogram/percent.c"
                 line="137">threshold percentage</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="threshold"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/histogram/percent.c"
                 line="138">output threshold value</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/histogram/percent.c"
                 line="139">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="phasecor" c:identifier="vips_phasecor" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/freqfilt/phasecor.c"
             line="122">Convert the two input images to Fourier space, calculate phase-correlation,
back to real space.

::: seealso
    [method@Image.fwfft], [method@Image.cross_phase],</doc>
        <source-position filename="libvips/include/vips/freqfilt.h" line="57"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/freqfilt/phasecor.c"
               line="135">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/freqfilt/phasecor.c"
                 line="124">first input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="in2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/freqfilt/phasecor.c"
                 line="125">second input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/freqfilt/phasecor.c"
                 line="126">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/freqfilt/phasecor.c"
                 line="127">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="pio_input" c:identifier="vips_image_pio_input">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="3593">Check that an image is readable with [method@Region.prepare] and friends.
If it isn't, try to transform the image so that [method@Region.prepare] can
work.

::: seealso
    [method@Image.pio_output], [method@Region.prepare].</doc>
        <source-position filename="libvips/include/vips/image.h" line="556"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="3604">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="3595">image to check</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="pio_output" c:identifier="vips_image_pio_output">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="3664">Check that an image is writeable with [method@Image.generate]. If it isn't,
try to transform the image so that [method@Image.generate] can work.

::: seealso
    [method@Image.pio_input].</doc>
        <source-position filename="libvips/include/vips/image.h" line="558"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="3674">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="3666">image to check</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="pipelinev"
              c:identifier="vips_image_pipelinev"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/generate.c"
             line="391">Build an array and call [func@Image.pipeline_array].

::: seealso
    [method@Image.generate].</doc>
        <source-position filename="libvips/include/vips/generate.h" line="85"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/generate.c"
                 line="393">output image of pipeline</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="hint" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/generate.c"
                 line="394">hint for this image</doc>
            <type name="DemandStyle" c:type="VipsDemandStyle"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/generate.c"
                 line="395">`NULL`-terminated list of input images</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="pngsave" c:identifier="vips_pngsave" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/pngsave.c"
             line="474">Write a VIPS image to a file as PNG.

@compression means compress with this much effort (0 - 9). Default 6.

Set @interlace to `TRUE` to interlace the image with ADAM7
interlacing. Beware
than an interlaced PNG can be up to 7 times slower to write than a
non-interlaced image.

Use @filter to specify one or more filters, defaults to none,
see [flags@ForeignPngFilter].

The image is automatically converted to RGB, RGBA, Monochrome or Mono +
alpha before saving. Images with more than one byte per band element are
saved as 16-bit PNG, others are saved as 8-bit PNG.

Set @palette to `TRUE` to enable palette mode for RGB or RGBA images. A
palette will be computed with enough space for @bitdepth (1, 2, 4 or 8)
bits. Use @Q to set the optimisation effort, @dither to set the degree of
Floyd-Steinberg dithering and @effort to control the CPU effort
(1 is the fastest, 10 is the slowest, 7 is the default).
This feature requires libvips to be compiled with libimagequant.

The default @bitdepth is either 8 or 16 depending on the interpretation.
You can also set @bitdepth for mono and mono + alpha images, and the image
will be quantized.

XMP metadata is written to the XMP chunk. PNG comments are written to
separate text chunks.

::: tip "Optional arguments"
    * @compression: `gint`, compression level
    * @interlace: `gboolean`, interlace image
    * @filter: [flags@ForeignPngFilter], row filter flag(s)
    * @palette: `gboolean`, enable quantisation to 8bpp palette
    * @Q: `gint`, quality for 8bpp quantisation
    * @dither: `gdouble`, amount of dithering for 8bpp quantization
    * @bitdepth: `gint`, set write bit depth to 1, 2, 4, 8 or 16
    * @effort: `gint`, quantisation CPU effort

::: seealso
    [ctor@Image.new_from_file].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="765"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/pngsave.c"
               line="523">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/pngsave.c"
                 line="476">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/pngsave.c"
                 line="477">file to write to</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/pngsave.c"
                 line="478">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="pngsave_buffer"
              c:identifier="vips_pngsave_buffer"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/pngsave.c"
             line="538">As [method@Image.pngsave], but save to a memory buffer.

The address of the buffer is returned in @buf, the length of the buffer in
@len. You are responsible for freeing the buffer with [func@GLib.free] when you
are done with it.

::: tip "Optional arguments"
    * @compression: `gint`, compression level
    * @interlace: `gboolean`, interlace image
    * @filter: [flags@ForeignPngFilter], row filter flag(s)
    * @palette: `gboolean`, enable quantisation to 8bpp palette
    * @Q: `gint`, quality for 8bpp quantisation
    * @dither: `gdouble`, amount of dithering for 8bpp quantization
    * @bitdepth: `gint`, set write bit depth to 1, 2, 4, 8 or 16
    * @effort: `gint`, quantisation CPU effort

::: seealso
    [method@Image.pngsave], [method@Image.write_to_file].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="768"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/pngsave.c"
               line="564">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/pngsave.c"
                 line="540">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/pngsave.c"
                 line="541">return output buffer here</doc>
            <array length="1" zero-terminated="0" c:type="void**">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/pngsave.c"
                 line="542">return output length here</doc>
            <type name="gsize" c:type="size_t*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/pngsave.c"
                 line="543">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="pngsave_target"
              c:identifier="vips_pngsave_target"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/pngsave.c"
             line="594">As [method@Image.pngsave], but save to a target.

::: tip "Optional arguments"
    * @compression: `gint`, compression level
    * @interlace: `gboolean`, interlace image
    * @filter: [flags@ForeignPngFilter], row filter flag(s)
    * @palette: `gboolean`, enable quantisation to 8bpp palette
    * @Q: `gint`, quality for 8bpp quantisation
    * @dither: `gdouble`, amount of dithering for 8bpp quantization
    * @bitdepth: `gint`, set write bit depth to 1, 2, 4, 8 or 16
    * @effort: `gint`, quantisation CPU effort

::: seealso
    [method@Image.pngsave], [method@Image.write_to_target].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="762"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/pngsave.c"
               line="615">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/pngsave.c"
                 line="596">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/pngsave.c"
                 line="597">save image to this target</doc>
            <type name="Target" c:type="VipsTarget*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/pngsave.c"
                 line="598">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="polar" c:identifier="vips_polar" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/complex.c"
             line="304">Perform [enum@Vips.OperationComplex.POLAR] on an image. See [method@Image.complex].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="316"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/complex.c"
               line="312">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/complex.c"
                 line="306">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/complex.c"
                 line="307">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/complex.c"
                 line="308">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="posteval" c:identifier="vips_image_posteval">
        <source-position filename="libvips/include/vips/image.h" line="453"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="pow" c:identifier="vips_pow" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/math2.c"
             line="308">Perform [enum@Vips.OperationMath2.POW] on a pair of images. See
[method@Image.math2].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="490"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/math2.c"
               line="318">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="310">left-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="311">right-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="312">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="313">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="pow_const"
              c:identifier="vips_pow_const"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/math2.c"
             line="549">Perform [enum@Vips.OperationMath2.POW] on an image and a constant. See
[method@Image.math2_const].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="503"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/math2.c"
               line="560">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="551">left-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="552">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="553">array of constants</doc>
            <array length="2" zero-terminated="0" c:type="const double*">
              <type name="gdouble" c:type="double"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="554">number of constants in @c</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="555">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="pow_const1"
              c:identifier="vips_pow_const1"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/math2.c"
             line="657">Perform [enum@Vips.OperationMath2.POW] on an image and a constant. See
[method@Image.math2_const].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="519"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/math2.c"
               line="667">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="659">left-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="660">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="661">constant</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="662">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="ppmsave" c:identifier="vips_ppmsave" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/ppmsave.c"
             line="792">Write a VIPS image to a file as PPM.

It can write 1, 8, 16 or
32 bit unsigned integer images, float images, colour or monochrome,
stored as binary or ASCII.
Integer images of more than 8 bits can only be stored in ASCII.

When writing float (PFM) images the scale factor is set from the
"pfm-scale" metadata.

Set @ascii to `TRUE` to write as human-readable ASCII. Normally data is
written in binary.

Set @bitdepth to 1 to write a one-bit image.

@format defaults to the sub-type for this filename suffix.

::: tip "Optional arguments"
    * @format: [enum@ForeignPpmFormat], format to save in
    * @ascii: `gboolean`, save as ASCII rather than binary
    * @bitdepth: `gint`, bitdepth to save at

::: seealso
    [method@Image.write_to_file].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="812"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/ppmsave.c"
               line="823">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/ppmsave.c"
                 line="794">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/ppmsave.c"
                 line="795">file to write to</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/ppmsave.c"
                 line="796">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="ppmsave_target"
              c:identifier="vips_ppmsave_target"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/ppmsave.c"
             line="838">As [method@Image.ppmsave], but save to a target.

::: tip "Optional arguments"
    * @format: [enum@ForeignPpmFormat], format to save in
    * @ascii: `gboolean`, save as ASCII rather than binary
    * @bitdepth: `gint`, bitdepth to save at

::: seealso
    [method@Image.ppmsave].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="815"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/ppmsave.c"
               line="854">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/ppmsave.c"
                 line="840">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/ppmsave.c"
                 line="841">save image to this target</doc>
            <type name="Target" c:type="VipsTarget*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/ppmsave.c"
                 line="842">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="preeval" c:identifier="vips_image_preeval">
        <source-position filename="libvips/include/vips/image.h" line="449"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="premultiply"
              c:identifier="vips_premultiply"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/premultiply.c"
             line="280">Premultiplies any alpha channel.

The final band is taken to be the alpha and the bands are transformed as:

```
alpha = clip(0, in[in.bands - 1], max_alpha)
norm = alpha / max_alpha
out = [in[0] * norm, ..., in[in.bands - 1] * norm, alpha]
```

So for an N-band image, the first N - 1 bands are multiplied by the clipped
and normalised final band, the final band is clipped.
If there is only a single band,
the image is passed through unaltered.

The result is
[enum@Vips.BandFormat.FLOAT] unless the input format is
[enum@Vips.BandFormat.DOUBLE], in which case the output is double as well.

@max_alpha has the default value 255, or 65535 for images tagged as
[enum@Vips.Interpretation.RGB16] or [enum@Vips.Interpretation.GREY16], and
1.0 for images tagged as [enum@Vips.Interpretation.scRGB].

Non-complex images only.

::: tip "Optional arguments"
    * @max_alpha: `gdouble`, maximum value for alpha

::: seealso
    [method@Image.unpremultiply], [method@Image.flatten].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="330"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/premultiply.c"
               line="317">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/premultiply.c"
                 line="282">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/premultiply.c"
                 line="283">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/premultiply.c"
                 line="284">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="prewitt" c:identifier="vips_prewitt" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/convolution/edge.c"
             line="393">Prewitt edge detector.

uchar images are computed using a fast, low-precision path. Cast to float
for a high-precision implementation.

::: seealso
    [method@Image.canny], [method@Image.sobel], [method@Image.prewitt],
    [method@Image.scharr].</doc>
        <source-position filename="libvips/include/vips/convolution.h"
                         line="91"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/convolution/edge.c"
               line="408">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/convolution/edge.c"
                 line="395">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/convolution/edge.c"
                 line="396">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/convolution/edge.c"
                 line="397">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="print_field" c:identifier="vips_image_print_field">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="2048">Prints field @name to stdout as ASCII. Handy for debugging.</doc>
        <source-position filename="libvips/include/vips/header.h" line="319"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="2050">image to get the header field from</doc>
            <type name="Image" c:type="const VipsImage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="2051">field name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="profile" c:identifier="vips_profile" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/profile.c"
             line="318">[method@Image.profile] searches inward from the edge of @in and finds the
first non-zero pixel. Pixels in @columns have the distance from the top edge
to the first non-zero pixel in that column, @rows has the distance from the
left edge to the first non-zero pixel in that row.

::: seealso
    [method@Image.project], [method@Image.hist_find].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="573"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/profile.c"
               line="333">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/profile.c"
                 line="320">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="columns"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/profile.c"
                 line="321">distances from top edge</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="rows"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/profile.c"
                 line="322">distances from left edge</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/profile.c"
                 line="323">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="project" c:identifier="vips_project" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/project.c"
             line="349">Find the horizontal and vertical projections of an image, ie. the sum
of every row of pixels, and the sum of every column of pixels. The output
format is uint, int or double, depending on the input format.

Non-complex images only.

::: seealso
    [method@Image.hist_find], [method@Image.profile].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="570"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/project.c"
               line="365">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/project.c"
                 line="351">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="columns"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/project.c"
                 line="352">sums of columns</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="rows"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/project.c"
                 line="353">sums of rows</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/project.c"
                 line="354">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="quadratic"
              c:identifier="vips_quadratic"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/resample/quadratic.c"
             line="339">Transform an image with a 0, 1, 2, or 3rd order polynomial.

The transform we compute:

```
x = x' + a              : order 0     image shift only
  + b x' + c y'         : order 1     + affine transf.
  + d x' y'             : order 2     + bilinear transf.
  + e x' x' + f y' y'   : order 3     + quadratic transf.

y = y' + g
  + h y' + i x'
  + j y' x'
  + k y' y' + l x' x'
```

where:

```
x', y' = coordinates of srcim
x, y   = coordinates of dstim
a .. l = coefficients
```

The coefficients are in the input matrix, ordered as:

```
a g
--
b h
c i
--
d j
--
e k
f l
```

The matrix height may be 1, 3, 4, 6

::: tip "Optional arguments"
    * @interpolate: [class@Interpolate], use this interpolator (default bilinear)

::: seealso
    [method@Image.affine].</doc>
        <source-position filename="libvips/include/vips/resample.h"
                         line="118"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/resample/quadratic.c"
               line="392">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/quadratic.c"
                 line="341">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/resample/quadratic.c"
                 line="342">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="coeff" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/quadratic.c"
                 line="343">horizontal quadratic</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/quadratic.c"
                 line="344">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="rad2float"
              c:identifier="vips_rad2float"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/colour/rad2float.c"
             line="203">Unpack a RAD ([enum@Vips.Coding.RAD]) image to a three-band float image.

::: seealso
    [method@Image.float2rad], [method@Image.LabQ2LabS].</doc>
        <source-position filename="libvips/include/vips/colour.h" line="128"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/rad2float.c"
               line="214">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/rad2float.c"
                 line="205">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/colour/rad2float.c"
                 line="206">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/rad2float.c"
                 line="207">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="radsave" c:identifier="vips_radsave" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/radsave.c"
             line="288">Write a VIPS image in Radiance (HDR) format.

Sections of this reader from Greg Ward and Radiance with kind permission.

::: seealso
    [method@Image.write_to_file].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="832"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/radsave.c"
               line="301">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/radsave.c"
                 line="290">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/radsave.c"
                 line="291">file to write to</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/radsave.c"
                 line="292">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="radsave_buffer"
              c:identifier="vips_radsave_buffer"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/radsave.c"
             line="316">As [method@Image.radsave], but save to a memory buffer.

The address of the buffer is returned in @buf, the length of the buffer in
@len. You are responsible for freeing the buffer with [func@GLib.free] when you
are done with it.

::: seealso
    [method@Image.radsave], [method@Image.write_to_file].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="835"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/radsave.c"
               line="332">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/radsave.c"
                 line="318">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/radsave.c"
                 line="319">return output buffer here</doc>
            <array length="1" zero-terminated="0" c:type="void**">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/radsave.c"
                 line="320">return output length here</doc>
            <type name="gsize" c:type="size_t*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/radsave.c"
                 line="321">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="radsave_target"
              c:identifier="vips_radsave_target"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/radsave.c"
             line="362">As [method@Image.radsave], but save to a target.

::: seealso
    [method@Image.radsave].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="838"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/radsave.c"
               line="373">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/radsave.c"
                 line="364">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/radsave.c"
                 line="365">save image to this target</doc>
            <type name="Target" c:type="VipsTarget*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/radsave.c"
                 line="366">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="rank" c:identifier="vips_rank" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/morphology/rank.c"
             line="589">[method@Image.rank] does rank filtering on an image. A window of size @width by
@height is passed over the image. At each position, the pixels inside the
window are sorted into ascending order and the pixel at position @index is
output. @index numbers from 0.

It works for any non-complex image type, with any number of bands.
The input is expanded by copying edge pixels before performing the
operation so that the output image has the same size as the input.
Edge pixels in the output image are therefore only approximate.

For a median filter with mask size m (3 for 3x3, 5 for 5x5, etc.) use

```c
vips_rank(in, out, m, m, m * m / 2);
```

The special cases n == 0 and n == m * m - 1 are useful dilate and
expand operators.

::: seealso
    [method@Image.conv], [method@Image.median], [method@Image.spcor].</doc>
        <source-position filename="libvips/include/vips/morphology.h"
                         line="52"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/morphology/rank.c"
               line="620">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/morphology/rank.c"
                 line="591">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/morphology/rank.c"
                 line="592">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/morphology/rank.c"
                 line="593">width of region</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/morphology/rank.c"
                 line="594">height of region</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/morphology/rank.c"
                 line="595">select pixel</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/morphology/rank.c"
                 line="596">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="rawsave" c:identifier="vips_rawsave" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/rawsave.c"
             line="326">Writes the pixels in @in to the file @filename with no header or other
metadata.

::: seealso
    [method@Image.write_to_file].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="677"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/rawsave.c"
               line="338">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/rawsave.c"
                 line="328">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/rawsave.c"
                 line="329">file to write to</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/rawsave.c"
                 line="330">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="rawsave_buffer"
              c:identifier="vips_rawsave_buffer"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/rawsave.c"
             line="353">As [method@Image.rawsave], but save to a memory buffer.

The address of the buffer is returned in @buf, the length of the buffer in
@len. You are responsible for freeing the buffer with [func@GLib.free] when you
are done with it.

::: seealso
    [method@Image.rawsave], [method@Image.write_to_memory], [method@Image.write_to_file].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="680"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/rawsave.c"
               line="369">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/rawsave.c"
                 line="355">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/rawsave.c"
                 line="356">return output buffer here</doc>
            <array length="1" zero-terminated="0" c:type="void**">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/rawsave.c"
                 line="357">return output length here</doc>
            <type name="gsize" c:type="size_t*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/rawsave.c"
                 line="358">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="rawsave_target"
              c:identifier="vips_rawsave_target"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/rawsave.c"
             line="399">As [method@Image.rawsave], but save to a target.

::: seealso
    [method@Image.rawsave].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="683"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/rawsave.c"
               line="410">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/rawsave.c"
                 line="401">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/rawsave.c"
                 line="402">save image to this target</doc>
            <type name="Target" c:type="VipsTarget*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/rawsave.c"
                 line="403">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="real" c:identifier="vips_real" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/complex.c"
             line="820">Perform [enum@Vips.OperationComplexget.REAL] on an image. See [method@Image.complexget].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="338"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/complex.c"
               line="828">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/complex.c"
                 line="822">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/complex.c"
                 line="823">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/complex.c"
                 line="824">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="recomb" c:identifier="vips_recomb" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/recomb.c"
             line="241">This operation recombines an image's bands. Each pixel in @in is treated as
an n-element vector, where n is the number of bands in @in, and multiplied by
the n x m matrix @m to produce the m-band image @out.

@out is always float, unless @in is double, in which case @out is double
too. No complex images allowed.

It's useful for various sorts of colour space conversions.

::: seealso
    [method@Image.bandmean].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="312"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/recomb.c"
               line="260">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/recomb.c"
                 line="243">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/recomb.c"
                 line="244">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/recomb.c"
                 line="245">recombination matrix</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/recomb.c"
                 line="246">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="rect" c:identifier="vips_rect" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/complex.c"
             line="327">Perform [enum@Vips.OperationComplex.RECT] on an image. See [method@Image.complex].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="319"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/complex.c"
               line="335">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/complex.c"
                 line="329">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/complex.c"
                 line="330">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/complex.c"
                 line="331">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="reduce" c:identifier="vips_reduce" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/resample/reduce.c"
             line="201">Reduce @in by a pair of factors with a pair of 1D kernels.

This will not work well for shrink factors greater than three.

Set @gap to speed up reducing by having [method@Image.shrink] to shrink
with a box filter first. The bigger @gap, the closer the result
to the fair resampling. The smaller @gap, the faster resizing.
The default value is 0.0 (no optimization).

This is a very low-level operation: see [method@Image.resize] for a more
convenient way to resize images.

This operation does not change xres or yres. The image resolution needs to
be updated by the application.

::: tip "Optional arguments"
    * @kernel: [enum@Kernel], kernel to interpolate with
      (default: [enum@Vips.Kernel.LANCZOS3])
    * @gap: `gdouble`, reducing gap to use (default: 0.0)

::: seealso
    [method@Image.shrink], [method@Image.resize], [method@Image.affine].</doc>
        <source-position filename="libvips/include/vips/resample.h" line="73"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/resample/reduce.c"
               line="232">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/reduce.c"
                 line="203">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/resample/reduce.c"
                 line="204">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="hshrink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/reduce.c"
                 line="205">horizontal shrink</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="vshrink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/reduce.c"
                 line="206">vertical shrink</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/reduce.c"
                 line="207">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="reduceh" c:identifier="vips_reduceh" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/resample/reduceh.cpp"
             line="632">Reduce @in horizontally by a float factor.

The pixels in @out are
interpolated with a 1D mask generated by @kernel.

Set @gap to speed up reducing by having [method@Image.shrinkh] to shrink
with a box filter first. The bigger @gap, the closer the result
to the fair resampling. The smaller @gap, the faster resizing.
The default value is 0.0 (no optimization).

This is a very low-level operation: see [method@Image.resize] for a more
convenient way to resize images.

This operation does not change xres or yres. The image resolution needs to
be updated by the application.

::: tip "Optional arguments"
    * @kernel: [enum@Kernel], kernel to interpolate with
      (default: [enum@Vips.Kernel.LANCZOS3])
    * @gap: `gboolean`, reducing gap to use (default: 0.0)

::: seealso
    [method@Image.shrink], [method@Image.resize], [method@Image.affine].</doc>
        <source-position filename="libvips/include/vips/resample.h" line="77"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/resample/reduceh.cpp"
               line="663">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/reduceh.cpp"
                 line="634">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/resample/reduceh.cpp"
                 line="635">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="hshrink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/reduceh.cpp"
                 line="636">horizontal reduce</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/reduceh.cpp"
                 line="637">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="reducev" c:identifier="vips_reducev" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/resample/reducev.cpp"
             line="1116">Reduce @in vertically by a float factor.

The pixels in @out are
interpolated with a 1D mask generated by @kernel.

Set @gap to speed up reducing by having [method@Image.shrinkv] to shrink
with a box filter first. The bigger @gap, the closer the result
to the fair resampling. The smaller @gap, the faster resizing.
The default value is 0.0 (no optimization).

This is a very low-level operation: see [method@Image.resize] for a more
convenient way to resize images.

This operation does not change xres or yres. The image resolution needs to
be updated by the application.

::: tip "Optional arguments"
    * @kernel: [enum@Kernel], kernel to interpolate with
      (default: [enum@Vips.Kernel.LANCZOS3])
    * @gap: `gboolean`, reducing gap to use (default: 0.0)

::: seealso
    [method@Image.shrink], [method@Image.resize], [method@Image.affine].</doc>
        <source-position filename="libvips/include/vips/resample.h" line="80"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/resample/reducev.cpp"
               line="1147">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/reducev.cpp"
                 line="1118">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/resample/reducev.cpp"
                 line="1119">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="vshrink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/reducev.cpp"
                 line="1120">vertical reduce</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/reducev.cpp"
                 line="1121">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="relational"
              c:identifier="vips_relational"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/relational.c"
             line="267">Perform various relational operations on pairs of images.

The output type is always uchar, with 0 for `FALSE` and 255 for `TRUE`.

Less-than and greater-than for complex images compare the modulus.

If the images differ in size, the smaller image is enlarged to match the
larger by adding zero pixels along the bottom and right.

If the number of bands differs, one of the images
must have one band. In this case, an n-band image is formed from the
one-band image by joining n copies of the one-band image together, and then
the two n-band images are operated upon.

The two input images are cast up to the smallest common format (see table
Smallest common format in
[arithmetic](libvips-arithmetic.html)).

To decide if pixels match exactly, that is have the same value in every
band, use [method@Image.bandbool] after this operation to AND or OR image
bands together.

::: seealso
    [method@Image.boolean], [method@Image.bandbool],
    [method@Image.relational_const].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="349"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/relational.c"
               line="301">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="269">left-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="270">right-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="271">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="relational" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="272">relational operation to perform</doc>
            <type name="OperationRelational" c:type="VipsOperationRelational"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="273">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="relational_const"
              c:identifier="vips_relational_const"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/relational.c"
             line="648">Perform various relational operations on an image and an array of
constants.

The output type is always uchar, with 0 for `FALSE` and 255 for `TRUE`.

If the array of constants has just one element, that constant is used for
all image bands. If the array has more than one element and they have
the same number of elements as there are bands in the image, then
one array element is used for each band. If the arrays have more than one
element and the image only has a single band, the result is a many-band
image where each band corresponds to one array element.

::: seealso
    [method@Image.boolean], [method@Image.relational].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="371"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/relational.c"
               line="672">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="650">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="651">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="relational" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="652">relational operation to perform</doc>
            <type name="OperationRelational" c:type="VipsOperationRelational"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="653">array of constants</doc>
            <array length="3" zero-terminated="0" c:type="const double*">
              <type name="gdouble" c:type="double"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="654">number of constants in @c</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="655">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="relational_const1"
              c:identifier="vips_relational_const1"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/relational.c"
             line="851">Perform various relational operations on an image and a constant. See
[method@Image.relational_const].

::: seealso
    [method@Image.boolean], [method@Image.relational].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="399"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/relational.c"
               line="865">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="853">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="854">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="relational" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="855">relational operation to perform</doc>
            <type name="OperationRelational" c:type="VipsOperationRelational"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="856">constant</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/relational.c"
                 line="857">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="remainder"
              c:identifier="vips_remainder"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/remainder.c"
             line="206">This operation calculates @left % @right (remainder after integer division)
and writes the result to @out. The images may have any
non-complex format. For float formats, [method@Image.remainder] calculates @in1 -
@in2 * floor (@in1 / @in2).

If the images differ in size, the smaller image is enlarged to match the
larger by adding zero pixels along the bottom and right.

If the number of bands differs, one of the images
must have one band. In this case, an n-band image is formed from the
one-band image by joining n copies of the one-band image together, and then
the two n-band images are operated upon.

The two input images are cast up to the smallest common format (see table
Smallest common format in
[arithmetic](libvips-arithmetic.html)), and that format is the
result type.

::: seealso
    [method@Image.remainder_const], [method@Image.divide], [method@Image.round].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="217"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/remainder.c"
               line="234">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/remainder.c"
                 line="208">left-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/remainder.c"
                 line="209">right-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/remainder.c"
                 line="210">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/remainder.c"
                 line="211">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="remainder_const"
              c:identifier="vips_remainder_const"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/remainder.c"
             line="388">This operation calculates @in % @c (remainder after division by an
array of constants)
and writes the result to @out.
The image may have any
non-complex format. For float formats, [method@Image.remainder_const] calculates
@in - @c * floor (@in / @c).

If the array of constants has just one element, that constant is used for
all image bands. If the array has more than one element and they have
the same number of elements as there are bands in the image, then
one array element is used for each band. If the arrays have more than one
element and the image only has a single band, the result is a many-band
image where each band corresponds to one array element.

::: seealso
    [method@Image.remainder], [method@Image.divide], [method@Image.round].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="220"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/remainder.c"
               line="413">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/remainder.c"
                 line="390">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/remainder.c"
                 line="391">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/remainder.c"
                 line="392">array of constants</doc>
            <array length="2" zero-terminated="0" c:type="const double*">
              <type name="gdouble" c:type="double"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/remainder.c"
                 line="393">number of constants in @c</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/remainder.c"
                 line="394">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="remainder_const1"
              c:identifier="vips_remainder_const1"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/remainder.c"
             line="429">This operation calculates @in % @c (remainder after division by a
constant)
and writes the result to @out.
The image may have any
non-complex format. For float formats, [method@Image.remainder_const] calculates
@in - @c * floor (@in / @c).

If the array of constants has just one element, that constant is used for
all image bands. If the array has more than one element and they have
the same number of elements as there are bands in the image, then
one array element is used for each band. If the arrays have more than one
element and the image only has a single band, the result is a many-band
image where each band corresponds to one array element.

::: seealso
    [method@Image.remainder], [method@Image.divide], [method@Image.round].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="224"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/remainder.c"
               line="453">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/remainder.c"
                 line="431">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/remainder.c"
                 line="432">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/remainder.c"
                 line="433">constant</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/remainder.c"
                 line="434">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="remosaic" c:identifier="vips_remosaic" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/mosaicing/remosaic.c"
             line="195">[method@Image.remosaic] works rather as [method@Image.globalbalance]. It
takes apart the mosaiced image @in and rebuilds it, substituting images.

Unlike [method@Image.globalbalance], images are substituted based on their
filenames. The rightmost occurrence of the string @old_str is swapped
for @new_str, that file is opened, and that image substituted for
the old image.

It's convenient for multispectral images. You can mosaic one band, then
use that mosaic as a template for mosaicing the others automatically.

::: seealso
    [method@Image.globalbalance].</doc>
        <source-position filename="libvips/include/vips/mosaicing.h"
                         line="67"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/mosaicing/remosaic.c"
               line="217">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/remosaic.c"
                 line="197">mosaic to rebuild</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/remosaic.c"
                 line="198">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="old_str" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/remosaic.c"
                 line="199">gamma of source images</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="new_str" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/remosaic.c"
                 line="200">gamma of source images</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/mosaicing/remosaic.c"
                 line="201">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="remove" c:identifier="vips_image_remove">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="1490">Find and remove an item of metadata. Return `FALSE` if no metadata of that
name was found.

::: seealso
    [method@Image.set], [method@Image.get_typeof].</doc>
        <source-position filename="libvips/include/vips/header.h" line="278"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="1501">`TRUE` if an item of metadata of that name was found and removed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1492">image to test</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1493">the name to search for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="reorder_margin_hint"
              c:identifier="vips_reorder_margin_hint">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/reorder.c"
             line="352">[method@Image.reorder_margin_hint] sets a hint that @image contains a
margin, that is, that each [method@Region.prepare] on @image will request
a slightly larger region from it's inputs. A good value for @margin is
(width * height) for the window the operation uses.

This information is used by [method@Image.reorder_prepare_many] to attempt to
reorder computations to minimise recomputation.

::: seealso
    [method@Image.reorder_prepare_many].</doc>
        <source-position filename="libvips/include/vips/image.h" line="609"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/reorder.c"
                 line="354">the image to hint on</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="margin" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/reorder.c"
                 line="355">the size of the margin this operation has added</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="reorder_prepare_many"
              c:identifier="vips_reorder_prepare_many">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/reorder.c"
             line="317">[method@Image.reorder_prepare_many] runs [method@Region.prepare] on each
region in @regions, requesting the pixels in @r.

It tries to request the regions in the order which will cause least
recomputation. This can give a large speedup, in some cases.

::: seealso
    [method@Region.prepare], [method@Image.reorder_margin_hint].</doc>
        <source-position filename="libvips/include/vips/image.h" line="606"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/reorder.c"
               line="332">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/reorder.c"
                 line="319">the image that's being written</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="regions" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/reorder.c"
                 line="320">the set of regions to prepare</doc>
            <array zero-terminated="0" c:type="VipsRegion**">
              <type name="Region" c:type="VipsRegion*"/>
            </array>
          </parameter>
          <parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/reorder.c"
                 line="321">the [struct@Rect] to prepare on each region</doc>
            <type name="Rect" c:type="VipsRect*"/>
          </parameter>
        </parameters>
      </method>
      <method name="replicate"
              c:identifier="vips_replicate"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/replicate.c"
             line="221">Repeats an image many times.

::: seealso
    [method@Image.extract_area].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="190"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/replicate.c"
               line="234">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/replicate.c"
                 line="223">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/replicate.c"
                 line="224">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="across" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/replicate.c"
                 line="225">repeat input this many times across</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="down" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/replicate.c"
                 line="226">repeat input this many times down</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/replicate.c"
                 line="227">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="resize" c:identifier="vips_resize" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/resample/resize.c"
             line="398">Resize an image.

Set @gap to speed up downsizing by having [method@Image.shrink] to shrink
with a box filter first. The bigger @gap, the closer the result
to the fair resampling. The smaller @gap, the faster resizing.
The default value is 2.0 (very close to fair resampling
while still being faster in many cases).

[method@Image.resize] normally uses [enum@Vips.Kernel.LANCZOS3] for the final
reduce, you can change this with @kernel. Downsizing is done with centre
convention.

When upsizing (@scale &gt; 1), the operation uses [method@Image.affine] with
a [class@Interpolate] selected depending on @kernel. It will use
[class@Interpolate] "bicubic" for [enum@Vips.Kernel.CUBIC] and above. It
adds a 0.5 pixel displacement to the input pixels to get centre convention
scaling.

[method@Image.resize] normally maintains the image aspect ratio. If you set
@vscale, that factor is used for the vertical scale and @scale for the
horizontal.

If either axis would drop below 1px in size, the shrink in that dimension
is limited. This breaks the image aspect ratio, but prevents errors due to
fractional pixel sizes.

This operation does not change xres or yres. The image resolution needs to
be updated by the application.

This operation does not premultiply alpha. If your image has an alpha
channel, you should use [method@Image.premultiply] on it first.

::: tip "optional arguments"
    * @vscale: `gdouble`, vertical scale factor
    * @kernel: [enum@Kernel], kernel to reduce with
      (default: [enum@Vips.Kernel.LANCZOS3])
    * @gap: `gdouble`, reducing gap to use (default: 2.0)

::: seealso
    [method@Image.premultiply], [method@Image.shrink], [method@Image.reduce].</doc>
        <source-position filename="libvips/include/vips/resample.h"
                         line="110"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/resample/resize.c"
               line="446">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/resize.c"
                 line="400">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/resample/resize.c"
                 line="401">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="scale" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/resize.c"
                 line="402">scale factor</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/resize.c"
                 line="403">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="rint" c:identifier="vips_rint" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/round.c"
             line="281">Round to an integral value with [enum@Vips.OperationRound.RINT]. See
[method@Image.round].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="255"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/round.c"
               line="290">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/round.c"
                 line="283">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/round.c"
                 line="284">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/round.c"
                 line="285">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="rot" c:identifier="vips_rot" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/rot.c"
             line="391">Rotate @in by a multiple of 90 degrees.

Use [method@Image.similarity] to rotate by an arbitrary angle.
[method@Image.rot45] is useful for rotating convolution masks by 45 degrees.

::: seealso
    [method@Image.flip], [method@Image.similarity], [method@Image.rot45].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="203"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/rot.c"
               line="406">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/rot.c"
                 line="393">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/rot.c"
                 line="394">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="angle" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/rot.c"
                 line="395">rotation angle</doc>
            <type name="Angle" c:type="VipsAngle"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/rot.c"
                 line="396">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="rot180" c:identifier="vips_rot180" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/rot.c"
             line="447">Rotate @in by 180 degrees. A convenience function over [method@Image.rot].

::: seealso
    [method@Image.rot].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="209"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/rot.c"
               line="458">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/rot.c"
                 line="449">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/rot.c"
                 line="450">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/rot.c"
                 line="451">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="rot270" c:identifier="vips_rot270" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/rot.c"
             line="473">Rotate @in by 270 degrees clockwise. A convenience function over [method@Image.rot].

::: seealso
    [method@Image.rot].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="212"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/rot.c"
               line="484">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/rot.c"
                 line="475">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/rot.c"
                 line="476">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/rot.c"
                 line="477">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="rot45" c:identifier="vips_rot45" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/rot45.c"
             line="287">Rotate @in by a multiple of 45 degrees. Odd-length sides and square images
only.

This operation is useful for rotating convolution masks. Use
[method@Image.similarity] to rotate images by arbitrary angles.

::: tip "Optional arguments"
    * @angle: [enum@Angle45], rotation angle

::: seealso
    [method@Image.rot], [method@Image.similarity].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="215"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/rot45.c"
               line="305">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/rot45.c"
                 line="289">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/rot45.c"
                 line="290">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/rot45.c"
                 line="291">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="rot90" c:identifier="vips_rot90" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/rot.c"
             line="421">Rotate @in by 90 degrees clockwise. A convenience function over [method@Image.rot].

::: seealso
    [method@Image.rot].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="206"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/rot.c"
               line="432">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/rot.c"
                 line="423">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/rot.c"
                 line="424">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/rot.c"
                 line="425">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="rotate" c:identifier="vips_rotate" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/resample/similarity.c"
             line="288">This operator calls [method@Image.affine] for you, calculating the matrix
for the affine transform from @scale and @angle.

Other parameters are passed on to [method@Image.affine] unaltered.

::: tip "Optional arguments"
    * @interpolate: [class@Interpolate], interpolate pixels with this
    * @background: [struct@ArrayDouble], colour for new pixels
    * @idx: `gdouble`, input horizontal offset
    * @idy: `gdouble`, input vertical offset
    * @odx: `gdouble`, output horizontal offset
    * @ody: `gdouble`, output vertical offset

::: seealso
    [method@Image.affine], [class@Interpolate].</doc>
        <source-position filename="libvips/include/vips/resample.h"
                         line="102"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/resample/similarity.c"
               line="311">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/similarity.c"
                 line="290">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/resample/similarity.c"
                 line="291">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="angle" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/similarity.c"
                 line="292">`gdouble`, rotate by this many degrees clockwise</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/similarity.c"
                 line="293">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="round" c:identifier="vips_round" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/round.c"
             line="200">Round to an integral value.

Copy for integer types, round float and
complex types.

The format of @out is always the same as @in, so you may wish to cast to an
integer format afterwards.

::: seealso
    [method@Image.cast]</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="246"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/round.c"
               line="218">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/round.c"
                 line="202">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/round.c"
                 line="203">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="round" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/round.c"
                 line="204">[class@Operation]Round rounding operation to perform</doc>
            <type name="OperationRound" c:type="VipsOperationRound"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/round.c"
                 line="205">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="rshift" c:identifier="vips_rshift" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/boolean.c"
             line="442">Perform [enum@Vips.OperationBoolean.RSHIFT] on a pair of images. See
[method@Image.boolean].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="438"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/boolean.c"
               line="452">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="444">left-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="445">right-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="446">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="447">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="rshift_const"
              c:identifier="vips_rshift_const"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/boolean.c"
             line="767">Perform [enum@Vips.OperationBoolean.LSHIFT] on an image and an array of constants.
See [method@Image.boolean_const].

::: seealso
    [method@Image.boolean], [method@Image.boolean_const1].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="462"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/boolean.c"
               line="781">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="769">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="770">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="771">array of constants</doc>
            <array length="2" zero-terminated="0" c:type="const double*">
              <type name="gdouble" c:type="double"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="772">number of constants in @c</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="773">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="rshift_const1"
              c:identifier="vips_rshift_const1"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/boolean.c"
             line="942">Perform [enum@Vips.OperationBoolean.RSHIFT] on an image and a constant.
See [method@Image.boolean_const1].

::: seealso
    [method@Image.boolean], [method@Image.boolean_const].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="482"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/boolean.c"
               line="955">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="944">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="945">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="946">constant</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/boolean.c"
                 line="947">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="sRGB2HSV" c:identifier="vips_sRGB2HSV" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/colour/sRGB2HSV.c"
             line="154">Convert to HSV.

HSV is a crude polar coordinate system for RGB images. It is provided for
compatibility with other image processing systems. See [method@Image.Lab2LCh] for a
much better colour space.

::: seealso
    [method@Image.HSV2sRGB], [method@Image.Lab2LCh].</doc>
        <source-position filename="libvips/include/vips/colour.h" line="177"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/sRGB2HSV.c"
               line="169">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/sRGB2HSV.c"
                 line="156">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/colour/sRGB2HSV.c"
                 line="157">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/sRGB2HSV.c"
                 line="158">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="sRGB2scRGB"
              c:identifier="vips_sRGB2scRGB"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/colour/sRGB2scRGB.c"
             line="152">Convert an sRGB image to scRGB.

RGB16 images are also handled.

::: seealso
    [method@Image.scRGB2XYZ], [method@Image.scRGB2sRGB],
    [method@Image.rad2float].</doc>
        <source-position filename="libvips/include/vips/colour.h" line="168"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/sRGB2scRGB.c"
               line="166">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/sRGB2scRGB.c"
                 line="154">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/colour/sRGB2scRGB.c"
                 line="155">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/sRGB2scRGB.c"
                 line="156">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="scRGB2BW" c:identifier="vips_scRGB2BW" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/colour/scRGB2BW.c"
             line="173">Convert an scRGB image to greyscale. Set @depth to 16 to get 16-bit output.

::: tip "Optional arguments"
    * @depth: `gint`, depth of output image in bits

::: seealso
    [method@Image.LabS2LabQ], [method@Image.sRGB2scRGB],
    [method@Image.rad2float].</doc>
        <source-position filename="libvips/include/vips/colour.h" line="165"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/scRGB2BW.c"
               line="188">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/scRGB2BW.c"
                 line="175">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/colour/scRGB2BW.c"
                 line="176">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/scRGB2BW.c"
                 line="177">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="scRGB2XYZ"
              c:identifier="vips_scRGB2XYZ"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/colour/scRGB2XYZ.c"
             line="101">Turn XYZ to scRGB.</doc>
        <source-position filename="libvips/include/vips/colour.h" line="171"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/scRGB2XYZ.c"
               line="109">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/scRGB2XYZ.c"
                 line="103">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/colour/scRGB2XYZ.c"
                 line="104">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/scRGB2XYZ.c"
                 line="105">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="scRGB2sRGB"
              c:identifier="vips_scRGB2sRGB"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/colour/scRGB2sRGB.c"
             line="200">Convert an scRGB image to sRGB. Set @depth to 16 to get 16-bit output.

::: tip "Optional arguments"
    * @depth: `gint`, depth of output image in bits

::: seealso
    [method@Image.LabS2LabQ], [method@Image.sRGB2scRGB],
    [method@Image.rad2float].</doc>
        <source-position filename="libvips/include/vips/colour.h" line="162"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/scRGB2sRGB.c"
               line="215">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/scRGB2sRGB.c"
                 line="202">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/colour/scRGB2sRGB.c"
                 line="203">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/scRGB2sRGB.c"
                 line="204">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="scale" c:identifier="vips_scale" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/scale.c"
             line="181">Search the image for the maximum and minimum value, then return the image
as unsigned 8-bit, scaled so that the maximum value is 255 and the
minimum is zero.

If @log is set, transform with log10(1.0 + pow(x, @exp)) + .5,
then scale so max == 255. By default, @exp is 0.25.

::: tip "Optional arguments"
    * @log: `gboolean`, log scale pixels
    * @exp: `gdouble`, exponent for log scale

::: seealso
    [method@Image.cast].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="263"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/scale.c"
               line="201">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/scale.c"
                 line="183">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/scale.c"
                 line="184">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/scale.c"
                 line="185">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="scharr" c:identifier="vips_scharr" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/convolution/edge.c"
             line="363">Scharr edge detector.

uchar images are computed using a fast, low-precision path. Cast to float
for a high-precision implementation.

::: seealso
    [method@Image.canny], [method@Image.sobel], [method@Image.prewitt],
    [method@Image.scharr].</doc>
        <source-position filename="libvips/include/vips/convolution.h"
                         line="88"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/convolution/edge.c"
               line="378">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/convolution/edge.c"
                 line="365">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/convolution/edge.c"
                 line="366">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/convolution/edge.c"
                 line="367">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="sequential"
              c:identifier="vips_sequential"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/sequential.c"
             line="279">This operation behaves rather like [method@Image.copy] between images
@in and @out, except that it checks that pixels on @in are only requested
top-to-bottom. This operation is useful for loading file formats which are
strictly top-to-bottom, like PNG.

@tile_height can be used to set the size of the tiles that
[method@Image.sequential] uses. The default value is 1.

::: tip "Optional arguments"
    * @tile_height: `gint`, height of cache strips

::: seealso
    [method@Image.linecache], [method@Image.tilecache].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="147"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/sequential.c"
               line="299">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/sequential.c"
                 line="281">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/sequential.c"
                 line="282">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/sequential.c"
                 line="283">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="set" c:identifier="vips_image_set">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="1257">Set a piece of metadata on @image. Any old metadata with that name is
destroyed. The [struct@GObject.Value] is copied into the image, so you need to unset the
value when you're done with it.

For example, to set an integer on an image (though you would use the
convenience function [method@Image.set_int] in practice), you would do:

```c
GValue value = G_VALUE_INIT;

g_value_init(&amp;value, G_TYPE_INT);
g_value_set_int(&amp;value, 42);
vips_image_set(image, name, &amp;value);
g_value_unset(&amp;value);
```

::: seealso
    [method@Image.get].</doc>
        <source-position filename="libvips/include/vips/header.h" line="268"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1259">image to set the metadata on</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1260">the name to give the metadata</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1261">the [struct@GObject.Value] to copy into the image</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_area" c:identifier="vips_image_set_area">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="1649">Attaches @data as a metadata item on @image under the name @name. When
VIPS no longer needs the metadata, it will be freed with @free_fn.

::: seealso
    [method@Image.get_double], [method@Image.set].</doc>
        <source-position filename="libvips/include/vips/header.h" line="287"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1651">image to attach the metadata to</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1652">metadata name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="free_fn"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1653">free function for @data</doc>
            <type name="CallbackFn" c:type="VipsCallbackFn"/>
          </parameter>
          <parameter name="data"
                     transfer-ownership="full"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1654">pointer to area of memory</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_array_double"
              c:identifier="vips_image_set_array_double">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="2218">Attaches @array as a metadata item on @image as @name.
A convenience function over [method@Image.set].

::: seealso
    [method@Image.get_image], [method@Image.set].</doc>
        <source-position filename="libvips/include/vips/header.h" line="335"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="2220">image to attach the metadata to</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="2221">metadata name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="array"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="2222">array of doubles</doc>
            <array length="2" zero-terminated="0" c:type="const double*">
              <type name="gdouble" c:type="double"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="2223">the number of elements</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_array_int" c:identifier="vips_image_set_array_int">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="2159">Attaches @array as a metadata item on @image as @name.
A convenience function over [method@Image.set].

::: seealso
    [method@Image.get_image], [method@Image.set].</doc>
        <source-position filename="libvips/include/vips/header.h" line="326"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="2161">image to attach the metadata to</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="2162">metadata name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="array"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="2163">array of ints</doc>
            <array length="2" zero-terminated="0" c:type="const int*">
              <type name="gint" c:type="int"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="2164">the number of elements</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blob" c:identifier="vips_image_set_blob">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="1725">Attaches @data as a metadata item on @image under the name @name.

::: seealso
    [method@Image.get_blob], [method@Image.set].</doc>
        <source-position filename="libvips/include/vips/header.h" line="293"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1727">image to attach the metadata to</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1728">metadata name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="free_fn"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1729">free function for @data</doc>
            <type name="CallbackFn" c:type="VipsCallbackFn"/>
          </parameter>
          <parameter name="data" transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1730">pointer to area of
  memory</doc>
            <array length="3" zero-terminated="0" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1732">length of memory area</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blob_copy" c:identifier="vips_image_set_blob_copy">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="1751">Attaches @data as a metadata item on @image under the name @name, taking
a copy of the memory area.

::: seealso
    [method@Image.get_blob], [method@Image.set].</doc>
        <source-position filename="libvips/include/vips/header.h" line="297"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1753">image to attach the metadata to</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1754">metadata name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1755">pointer to area of memory</doc>
            <array length="2" zero-terminated="0" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1756">length of memory area</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_delete_on_close"
              c:identifier="vips_image_set_delete_on_close">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="2474">Sets the delete_on_close flag for the image. If this flag is set, when
@image is finalized, the filename held in @image-&gt;filename at the time of
this call is deleted.

This function is clearly extremely dangerous, use with great caution.

::: seealso
    [ctor@Image.new_temp_file].</doc>
        <source-position filename="libvips/include/vips/image.h" line="511"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2476">image to set</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="delete_on_close" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2477">format of file</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_double" c:identifier="vips_image_set_double">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="1900">Attaches @d as a metadata item on @image as @name. A
convenience function over [method@Image.set].

::: seealso
    [method@Image.get_double], [method@Image.set].</doc>
        <source-position filename="libvips/include/vips/header.h" line="311"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1902">image to attach the metadata to</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1903">metadata name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="d" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1904">metadata value</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_image" c:identifier="vips_image_set_image">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="2102">Attaches @im as a metadata item on @image as @name.
A convenience function over [method@Image.set].

::: seealso
    [method@Image.get_image], [method@Image.set].</doc>
        <source-position filename="libvips/include/vips/header.h" line="324"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="2104">image to attach the metadata to</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="2105">metadata name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="im" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="2106">metadata value</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_int" c:identifier="vips_image_set_int">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="1850">Attaches @i as a metadata item on @image under the name @name. A
convenience function over [method@Image.set].

::: seealso
    [method@Image.get_int], [method@Image.set].</doc>
        <source-position filename="libvips/include/vips/header.h" line="306"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1852">image to attach the metadata to</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1853">metadata name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1854">metadata value</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_kill"
              c:identifier="vips_image_set_kill"
              glib:set-property="kill">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="1651">Set the [class@Image].kill flag on an image. Handy for stopping sets of
threads.

::: seealso
    [method@Image.iskilled].</doc>
        <source-position filename="libvips/include/vips/image.h" line="460"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="1653">image to test</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="kill" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="1654">the kill state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_progress" c:identifier="vips_image_set_progress">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="1585">vips signals evaluation progress via the [signal@Image::preeval],
[signal@Image::eval] and [signal@Image::posteval]
signals. Progress is signalled on the most-downstream image for which
[method@Image.set_progress] was called.</doc>
        <source-position filename="libvips/include/vips/image.h" line="456"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="1587">image to signal progress on</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="progress" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="1588">turn progress reporting on or off</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_string" c:identifier="vips_image_set_string">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="1974">Attaches @str as a metadata item on @image as @name.
A convenience
function over [method@Image.set] using `VIPS_TYPE_REF_STRING`.

::: seealso
    [method@Image.get_double], [method@Image.set].</doc>
        <source-position filename="libvips/include/vips/header.h" line="316"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1976">image to attach the metadata to</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1977">metadata name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="str" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="1978">metadata value</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="sharpen" c:identifier="vips_sharpen" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/convolution/sharpen.c"
             line="396">Selectively sharpen the L channel of a LAB image. The input image is
transformed to [enum@Vips.Interpretation.LABS].

The operation performs a gaussian blur and subtracts from @in to generate a
high-frequency signal. This signal is passed through a lookup table formed
from the five parameters and added back to @in.

The lookup table is formed like this:

```
                    ^
                 y2 |- - - - - -----------
                    |         /
                    |        / slope m2
                    |    .../
            -x1     | ...   |
-------------------...----------------------&gt;
            |   ... |      x1
            |... slope m1
            /       |
           / m2     |
          /         |
         /          |
        /           |
       /            |
______/ _ _ _ _ _ _ | -y3
                    |
```

For screen output, we suggest the following settings (the defaults):

```
sigma == 0.5
x1 == 2
y2 == 10         (don't brighten by more than 10 L*)
y3 == 20         (can darken by up to 20 L*)
m1 == 0          (no sharpening in flat areas)
m2 == 3          (some sharpening in jaggy areas)
```

If you want more or less sharpening, we suggest you just change the
m2 parameter.

The @sigma parameter changes the width of the fringe and can be
adjusted according to the output printing resolution. As an approximate
guideline, use 0.5 for 4 pixels/mm (display resolution),
1.0 for 12 pixels/mm and 1.5 for 16 pixels/mm (300 dpi == 12
pixels/mm). These figures refer to the image raster, not the half-tone
resolution.

::: tip "Optional arguments"
    * @sigma: `gdouble`, sigma of gaussian
    * @x1: `gdouble`, flat/jaggy threshold
    * @y2: `gdouble`, maximum amount of brightening
    * @y3: `gdouble`, maximum amount of darkening
    * @m1: `gdouble`, slope for flat areas
    * @m2: `gdouble`, slope for jaggy areas

::: seealso
    [method@Image.conv].</doc>
        <source-position filename="libvips/include/vips/convolution.h"
                         line="74"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/convolution/sharpen.c"
               line="463">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/convolution/sharpen.c"
                 line="398">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/convolution/sharpen.c"
                 line="399">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/convolution/sharpen.c"
                 line="400">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="shrink" c:identifier="vips_shrink" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/resample/shrink.c"
             line="181">Shrink @in by a pair of factors with a simple box filter.

For non-integer factors, [method@Image.shrink] will first shrink by the
integer part with a box filter, then use [method@Image.reduce] to shrink
by the remaining fractional part.

This is a very low-level operation: see [method@Image.resize] for a more
convenient way to resize images.

This operation does not change xres or yres. The image resolution needs to
be updated by the application.

::: tip "Optional arguments"
    * @ceil: `gboolean`, round-up output dimensions

::: seealso
    [method@Image.resize], [method@Image.reduce].</doc>
        <source-position filename="libvips/include/vips/resample.h" line="62"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/resample/shrink.c"
               line="207">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/shrink.c"
                 line="183">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/resample/shrink.c"
                 line="184">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="hshrink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/shrink.c"
                 line="185">horizontal shrink</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="vshrink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/shrink.c"
                 line="186">vertical shrink</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/shrink.c"
                 line="187">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="shrinkh" c:identifier="vips_shrinkh" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/resample/shrinkh.c"
             line="464">Shrink @in horizontally by an integer factor.
Each pixel in the output is
the average of the corresponding line of @hshrink pixels in the input.

This is a very low-level operation: see [method@Image.resize] for a more
convenient way to resize images.

This operation does not change xres or yres. The image resolution needs to
be updated by the application.

::: tip "Optional arguments"
    * @ceil: `gboolean`, round-up output dimensions

::: seealso
    [method@Image.shrinkv], [method@Image.shrink], [method@Image.resize],
    [method@Image.affine].</doc>
        <source-position filename="libvips/include/vips/resample.h" line="66"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/resample/shrinkh.c"
               line="488">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/shrinkh.c"
                 line="466">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/resample/shrinkh.c"
                 line="467">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="hshrink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/shrinkh.c"
                 line="468">horizontal shrink</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/shrinkh.c"
                 line="469">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="shrinkv" c:identifier="vips_shrinkv" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/resample/shrinkv.c"
             line="653">Shrink @in vertically by an integer factor.

Each pixel in the output is
the average of the corresponding column of @vshrink pixels in the input.

This is a very low-level operation: see [method@Image.resize] for a more
convenient way to resize images.

This operation does not change xres or yres. The image resolution needs to
be updated by the application.

::: tip "Optional arguments"
    * @ceil: `gboolean`, round-up output dimensions

::: seealso
    [method@Image.shrinkh], [method@Image.shrink], [method@Image.resize],
    [method@Image.affine].</doc>
        <source-position filename="libvips/include/vips/resample.h" line="69"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/resample/shrinkv.c"
               line="678">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/shrinkv.c"
                 line="655">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/resample/shrinkv.c"
                 line="656">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="vshrink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/shrinkv.c"
                 line="657">vertical shrink</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/shrinkv.c"
                 line="658">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="sign" c:identifier="vips_sign" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/sign.c"
             line="186">Finds the unit vector in the direction of the pixel value. For non-complex
images, it returns a signed char image with values -1, 0, and 1 for negative,
zero and positive pixels. For complex images, it returns a
complex normalised to length 1.

::: seealso
    [method@Image.abs].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="234"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/sign.c"
               line="200">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/sign.c"
                 line="188">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/sign.c"
                 line="189">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/sign.c"
                 line="190">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="similarity"
              c:identifier="vips_similarity"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/resample/similarity.c"
             line="219">This operator calls [method@Image.affine] for you, calculating the matrix
for the affine transform from @scale and @angle. Other parameters are
passed on to [method@Image.affine] unaltered.

::: tip "Optional arguments"
    * @scale: `gdouble`, scale by this factor
    * @angle: `gdouble`, rotate by this many degrees clockwise
    * @interpolate: [class@Interpolate], interpolate pixels with this
    * @background: [struct@ArrayDouble] colour for new pixels
    * @idx: `gdouble`, input horizontal offset
    * @idy: `gdouble`, input vertical offset
    * @odx: `gdouble`, output horizontal offset
    * @ody: `gdouble`, output vertical offset

::: seealso
    [method@Image.affine], [class@Interpolate].</doc>
        <source-position filename="libvips/include/vips/resample.h" line="99"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/resample/similarity.c"
               line="242">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/similarity.c"
                 line="221">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/resample/similarity.c"
                 line="222">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/similarity.c"
                 line="223">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="sin" c:identifier="vips_sin" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/math.c"
             line="311">Perform [enum@Vips.OperationMath.SIN] on an image. See [method@Image.math].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="263"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/math.c"
               line="319">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="313">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="314">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="315">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="sinh" c:identifier="vips_sinh" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/math.c"
             line="449">Perform [enum@Vips.OperationMath.SINH] on an image. See [method@Image.math].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="293"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/math.c"
               line="457">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="451">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="452">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="453">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="sink" c:identifier="vips_sink">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/sink.c"
             line="515">Loops over an image. @generate_fn is called for every pixel in
the image, with the @reg argument being a region of calculated pixels.
[method@Image.sink] is used to implement operations like
[method@Image.avg] which have no image output.

Each set of pixels is sized according to the requirements of the image
pipeline that generated @im.

::: seealso
    [method@Image.generate], [ctor@Image.new].</doc>
        <source-position filename="libvips/include/vips/generate.h" line="45"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/sink.c"
               line="535">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="im" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/sink.c"
                 line="517">scan over this image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="start_fn" transfer-ownership="none" scope="async">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/sink.c"
                 line="518">start sequences with this function</doc>
            <type name="StartFn" c:type="VipsStartFn"/>
          </parameter>
          <parameter name="generate_fn"
                     transfer-ownership="none"
                     scope="async">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/sink.c"
                 line="519">generate pixels with this function</doc>
            <type name="GenerateFn" c:type="VipsGenerateFn"/>
          </parameter>
          <parameter name="stop_fn" transfer-ownership="none" scope="async">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/sink.c"
                 line="520">stop sequences with this function</doc>
            <type name="StopFn" c:type="VipsStopFn"/>
          </parameter>
          <parameter name="a"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/sink.c"
                 line="521">user data</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="b"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/sink.c"
                 line="522">user data</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
      <method name="sink_disc" c:identifier="vips_sink_disc">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/sinkdisc.c"
             line="485">[method@Image.sink_disc] loops over @im, top-to-bottom, generating it in sections.
As each section is produced, @write_fn is called.

@write_fn is always called single-threaded (though not always from the same
thread), it's always given image
sections in top-to-bottom order, and there are never any gaps.

This operation is handy for making image sinks which output to things like
disc files. Things like [method@Image.jpegsave], for example, use this to write
images to files in JPEG format.

::: seealso
    [func@concurrency_set].</doc>
        <source-position filename="libvips/include/vips/generate.h" line="42"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/sinkdisc.c"
               line="505">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="im" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/sinkdisc.c"
                 line="487">image to process</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="write_fn"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/sinkdisc.c"
                 line="488">called for every batch of pixels</doc>
            <type name="RegionWrite" c:type="VipsRegionWrite"/>
          </parameter>
          <parameter name="a"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/sinkdisc.c"
                 line="489">client data</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
      <method name="sink_screen" c:identifier="vips_sink_screen">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/sinkscreen.c"
             line="1155">This operation renders @in in the background, making pixels available
on @out as they are calculated. The @notify_fn callback is run every
time a new set of pixels are available. Calculated pixels are kept in
a cache with tiles sized @tile_width by @tile_height pixels and with at
most @max_tiles tiles.  If @max_tiles is -1, the cache is of unlimited
size (up to the maximum image * size). The @mask image is a one-band
uchar image and has 255 for pixels which are currently in cache and 0
for uncalculated pixels.

Renders with a positive priority are assumed to be large, high-priority,
foreground images. Although there can be many of these, only one is ever
active, to avoid overcommitting threads.

Renders with a negative priority are assumed to be small, thumbnail images,
consisting of a single tile. Single tile images are effectively
single-threaded, so all these renders are evaluated together.

Calls to [method@Region.prepare] on @out return immediately and hold
whatever is currently in cache for that [struct@Rect] (check @mask to see
which parts of the [struct@Rect] are valid). Any pixels in the [struct@Rect]
which are not in cache are added to a queue, and the @notify_fn
callback will trigger when those pixels are ready.

The @notify_fn callback is run from one of the background threads. In the
callback you need to somehow send a message to the main thread that the
pixels are ready. In a glib-based application, this is easily done with
[func@GLib.idle_add].

If @notify_fn is `NULL` then [method@Image.sink_screen] runs synchronously.
[method@Region.prepare] on @out will always block until the pixels have been
calculated.

::: seealso
    [method@Image.tilecache], [method@Region.prepare],
    [method@Image.sink_disc], [method@Image.sink].</doc>
        <source-position filename="libvips/include/vips/generate.h" line="56"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/sinkscreen.c"
               line="1203">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/sinkscreen.c"
                 line="1157">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/sinkscreen.c"
                 line="1158">output image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="mask" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/sinkscreen.c"
                 line="1159">mask image indicating valid pixels</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="tile_width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/sinkscreen.c"
                 line="1160">tile width</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="tile_height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/sinkscreen.c"
                 line="1161">tile height</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="max_tiles" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/sinkscreen.c"
                 line="1162">maximum tiles to cache</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="priority" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/sinkscreen.c"
                 line="1163">rendering priority</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="notify_fn"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="call"
                     closure="7">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/sinkscreen.c"
                 line="1164">pixels are ready notification callback</doc>
            <type name="SinkNotify" c:type="VipsSinkNotify"/>
          </parameter>
          <parameter name="a"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/sinkscreen.c"
                 line="1165">client data for callback</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
      <method name="sink_tile" c:identifier="vips_sink_tile">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/sink.c"
             line="444">Loops over an image. @generate_fn is called for every
pixel in the image, with
the @reg argument being a region of calculated pixels.

Each set of pixels is @tile_width by @tile_height pixels (less at the
image edges). This is handy for things like writing a tiled TIFF image,
where tiles have to be generated with a certain size.

::: seealso
    [method@Image.sink], [method@Image.get_tile_size].</doc>
        <source-position filename="libvips/include/vips/generate.h" line="49"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/sink.c"
               line="466">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="im" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/sink.c"
                 line="446">scan over this image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="tile_width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/sink.c"
                 line="447">tile width</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="tile_height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/sink.c"
                 line="448">tile height</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="start_fn" transfer-ownership="none" scope="async">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/sink.c"
                 line="449">start sequences with this function</doc>
            <type name="StartFn" c:type="VipsStartFn"/>
          </parameter>
          <parameter name="generate_fn"
                     transfer-ownership="none"
                     scope="async">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/sink.c"
                 line="450">generate pixels with this function</doc>
            <type name="GenerateFn" c:type="VipsGenerateFn"/>
          </parameter>
          <parameter name="stop_fn" transfer-ownership="none" scope="async">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/sink.c"
                 line="451">stop sequences with this function</doc>
            <type name="StopFn" c:type="VipsStopFn"/>
          </parameter>
          <parameter name="a"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/sink.c"
                 line="452">user data</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="b"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/sink.c"
                 line="453">user data</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
      <method name="smartcrop"
              c:identifier="vips_smartcrop"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/smartcrop.c"
             line="488">Crop an image down to a specified width and height by removing boring parts.

Use @interesting to pick the method vips uses to decide which bits of the
image should be kept.

You can test xoffset / yoffset on @out to find the location of the crop
within the input image.

::: tip "Optional arguments"
    * @interesting: [enum@Interesting] to use to find interesting areas
      (default: [enum@Vips.Interesting.ATTENTION])
    * @premultiplied: `gboolean`, input image already has premultiplied alpha
    * @attention_x: `gint`, output, horizontal position of attention centre when
      using attention based cropping
    * @attention_y: `gint`, output, vertical position of attention centre when
      using attention based cropping

::: seealso
    [method@Image.extract_area].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="184"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/smartcrop.c"
               line="516">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/smartcrop.c"
                 line="490">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/smartcrop.c"
                 line="491">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/smartcrop.c"
                 line="492">width of area to extract</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/smartcrop.c"
                 line="493">height of area to extract</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/smartcrop.c"
                 line="494">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="sobel" c:identifier="vips_sobel" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/convolution/edge.c"
             line="333">Sobel edge detector.

uchar images are computed using a fast, low-precision path. Cast to float
for a high-precision implementation.

::: seealso
    [method@Image.canny], [method@Image.sobel], [method@Image.prewitt],
    [method@Image.scharr].</doc>
        <source-position filename="libvips/include/vips/convolution.h"
                         line="85"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/convolution/edge.c"
               line="348">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/convolution/edge.c"
                 line="335">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/convolution/edge.c"
                 line="336">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/convolution/edge.c"
                 line="337">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="spcor" c:identifier="vips_spcor" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/convolution/spcor.c"
             line="329">Calculate a correlation surface.

@ref is placed at every position in @in and the correlation coefficient
calculated. The output
image is always float.

The output
image is the same size as the input. Extra input edge pixels are made by
copying the existing edges outwards.

The correlation coefficient is calculated as:

```
         sumij (ref(i,j)-mean(ref))(inkl(i,j)-mean(inkl))
c(k,l) = ------------------------------------------------
         sqrt(sumij (ref(i,j)-mean(ref))^2) *
                     sqrt(sumij (inkl(i,j)-mean(inkl))^2)
```

where inkl is the area of @in centred at position (k,l).

from Niblack "An Introduction to Digital Image Processing",
Prentice/Hall, pp 138.

If the number of bands differs, one of the images
must have one band. In this case, an n-band image is formed from the
one-band image by joining n copies of the one-band image together, and then
the two n-band images are operated upon.

The output image is always float, unless either of the two inputs is
double, in which case the output is also double.

::: seealso
    [method@Image.fastcor].</doc>
        <source-position filename="libvips/include/vips/convolution.h"
                         line="78"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/convolution/spcor.c"
               line="371">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/convolution/spcor.c"
                 line="331">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="ref" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/convolution/spcor.c"
                 line="332">reference image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/convolution/spcor.c"
                 line="333">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/convolution/spcor.c"
                 line="334">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="spectrum" c:identifier="vips_spectrum" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/freqfilt/spectrum.c"
             line="109">Make a displayable (ie. 8-bit unsigned int) power spectrum.

If @in is non-complex, it is transformed to Fourier space. Then the
absolute value is passed through [method@Image.scale] in log mode, and
[method@Image.wrap].

::: seealso
    [method@Image.fwfft], [method@Image.scale], [method@Image.wrap].</doc>
        <source-position filename="libvips/include/vips/freqfilt.h" line="53"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/freqfilt/spectrum.c"
               line="124">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/freqfilt/spectrum.c"
                 line="111">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/freqfilt/spectrum.c"
                 line="112">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/freqfilt/spectrum.c"
                 line="113">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="stats" c:identifier="vips_stats" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/stats.c"
             line="453">Find many image statistics in a single pass through the data. @out is a
one-band [enum@Vips.BandFormat.DOUBLE] image of at least 10 columns by n + 1
(where n is number of bands in image @in)
rows. Columns are statistics, and are, in order: minimum, maximum, sum,
sum of squares, mean, standard deviation, x coordinate of minimum, y
coordinate of minimum, x coordinate of maximum, y coordinate of maximum.
Later versions of [method@Image.stats] may add more columns.

Row 0 has statistics for all
bands together, row 1 has stats for band 1, and so on.

If there is more than one maxima or minima, one of them will be chosen at
random.

::: seealso
    [method@Image.avg], [method@Image.min].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="541"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/stats.c"
               line="476">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/stats.c"
                 line="455">image to scan</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/stats.c"
                 line="456">image of statistics</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/stats.c"
                 line="457">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="stdif" c:identifier="vips_stdif" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/histogram/stdif.c"
             line="361">[method@Image.stdif] performs statistical differencing according to the
formula given in page 45 of the book "An Introduction to Digital Image
Processing" by Wayne Niblack.

This transformation emphasises the way in
which a pel differs statistically from its neighbours. It is useful for
enhancing low-contrast images with lots of detail, such as X-ray plates.

At point (i,j) the output is given by the equation:

```
vout(i,j) = @a * @m0 + (1 - @a) * meanv +
      (vin(i,j) - meanv) * (@b * @s0) / (@s0 + @b * stdv)
```

Values @a, @m0, @b and @s0 are entered, while meanv and stdv are the values
calculated over a moving window of size @width, @height centred on pixel
(i,j). @m0 is the new mean, @a is the weight given to it. @s0 is the new
standard deviation, @b is the weight given to it.

Try:

```
vips stdif $VIPSHOME/pics/huysum.v fred.v 0.5 128 0.5 50 11 11
```

The operation works on one-band uchar images only, and writes a one-band
uchar image as its result. The output image has the same size as the
input.

::: tip "Optional arguments"
    * @a: `gdouble`, weight of new mean
    * @m0: `gdouble`, target mean
    * @b: `gdouble`, weight of new deviation
    * @s0: `gdouble`, target deviation

::: seealso
    [method@Image.hist_local].</doc>
        <source-position filename="libvips/include/vips/histogram.h"
                         line="48"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/histogram/stdif.c"
               line="408">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/histogram/stdif.c"
                 line="363">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/histogram/stdif.c"
                 line="364">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/histogram/stdif.c"
                 line="365">width of region</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/histogram/stdif.c"
                 line="366">height of region</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/histogram/stdif.c"
                 line="367">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="subsample"
              c:identifier="vips_subsample"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/subsample.c"
             line="300">Subsample an image by an integer fraction. This is fast, nearest-neighbour
shrink.

For small horizontal shrinks, this operation will fetch lines of pixels
from @in and then subsample that line. For large shrinks it will fetch
single pixels.

If @point is set, @in will always be sampled in points. This can be faster
if the previous operations in the pipeline are very slow.

::: tip "Optional arguments"
    * @point: `gboolean`, turn on point sample mode

::: seealso
    [method@Image.affine], [method@Image.shrink], [method@Image.zoom].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="226"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/subsample.c"
               line="324">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/subsample.c"
                 line="302">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/subsample.c"
                 line="303">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="xfac" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/subsample.c"
                 line="304">horizontal shrink factor</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="yfac" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/subsample.c"
                 line="305">vertical shrink factor</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/subsample.c"
                 line="306">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="subtract" c:identifier="vips_subtract" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/subtract.c"
             line="186">This operation calculates @in1 - @in2 and writes the result to @out.

If the images differ in size, the smaller image is enlarged to match the
larger by adding zero pixels along the bottom and right.

If the number of bands differs, one of the images
must have one band. In this case, an n-band image is formed from the
one-band image by joining n copies of the one-band image together, and then
the two n-band images are operated upon.

The two input images are cast up to the smallest common format (see table
Smallest common format in
[arithmetic](libvips-arithmetic.html)), then the
following table is used to determine the output type:

## [method@Image.subtract] type promotion

| input type     | output type    |
|----------------|----------------|
| uchar          | short          |
| char           | short          |
| ushort         | int            |
| short          | int            |
| uint           | int            |
| int            | int            |
| float          | float          |
| double         | double         |
| complex        | complex        |
| double complex | double complex |

In other words, the output type is just large enough to hold the whole
range of possible values.

::: seealso
    [method@Image.add], [method@Image.linear].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="201"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/subtract.c"
               line="229">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/subtract.c"
                 line="188">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="in2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/subtract.c"
                 line="189">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/subtract.c"
                 line="190">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/subtract.c"
                 line="191">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="tan" c:identifier="vips_tan" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/math.c"
             line="357">Perform [enum@Vips.OperationMath.TAN] on an image. See [method@Image.math].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="269"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/math.c"
               line="365">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="359">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="360">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="361">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="tanh" c:identifier="vips_tanh" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/math.c"
             line="495">Perform [enum@Vips.OperationMath.TANH] on an image. See [method@Image.math].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="299"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/math.c"
               line="503">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="497">input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="498">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math.c"
                 line="499">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="thumbnail_image"
              c:identifier="vips_thumbnail_image"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/resample/thumbnail.c"
             line="1890">Exactly as [ctor@Image.thumbnail], but read from an existing image.

This operation
is not able to exploit shrink-on-load features of image load libraries, so
it can be much slower than [ctor@Image.thumbnail] and produce poorer quality
output. Only use this operation if you really have to.

::: tip "Optional arguments"
    * @height: `gint`, target height in pixels
    * @size: [enum@Size], upsize, downsize, both or force
    * @no_rotate: `gboolean`, don't rotate upright using orientation tag
    * @crop: [enum@Interesting], shrink and crop to fill target
    * @linear: `gboolean`, perform shrink in linear light
    * @input_profile: `gchararray`, fallback input ICC profile
    * @output_profile: `gchararray`, output ICC profile
    * @intent: [enum@Intent], rendering intent
    * @fail_on: [enum@FailOn], load error types to fail on

::: seealso
    [ctor@Image.thumbnail].</doc>
        <source-position filename="libvips/include/vips/resample.h" line="91"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/resample/thumbnail.c"
               line="1918">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/thumbnail.c"
                 line="1892">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/resample/thumbnail.c"
                 line="1893">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/thumbnail.c"
                 line="1894">target width in pixels</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/thumbnail.c"
                 line="1895">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="tiffsave" c:identifier="vips_tiffsave" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/tiffsave.c"
             line="596">Write a VIPS image to a file as TIFF.

If @in has the [const@META_PAGE_HEIGHT] metadata item, this is assumed to
be a "toilet roll" image. It will be written as series of pages, each
[const@META_PAGE_HEIGHT] pixels high.

Use @compression to set the tiff compression. Currently jpeg, packbits,
fax4, lzw, none, deflate, webp and zstd are supported. The default is no
compression. JPEG compression is a good lossy compressor for photographs,
packbits is good for 1-bit images, and deflate is the best lossless
compression TIFF can do.

XYZ images are automatically saved as libtiff LOGLUV with SGILOG compression.
Float LAB images are saved as float CIELAB. Set @bitdepth to save as 8-bit
CIELAB.

Use @Q to set the JPEG compression factor. Default 75.

User @level to set the ZSTD (1-22) or Deflate (1-9) compression level.
Use @lossless to set WEBP lossless mode on. Use @Q to set the WEBP
compression level.

Use @predictor to set the predictor for lzw, deflate and zstd compression.
It defaults to [enum@Vips.ForeignTiffPredictor.HORIZONTAL], meaning horizontal
differencing. Please refer to the libtiff
specifications for further discussion of various predictors.

Set @tile to `TRUE` to write a tiled tiff.  By default tiff are written in
strips. Use @tile_width and @tile_height to set the tile size. The defaiult
is 128 by 128.

Set @pyramid to write the image as a set of images, one per page, of
decreasing size. Use @region_shrink to set how images will be shrunk: by
default each 2x2 block is just averaged, but you can set MODE or MEDIAN as
well.

By default, the pyramid stops when the image is small enough to fit in one
tile. Use @depth to stop when the image fits in one pixel, or to only write
a single layer.

Set @bitdepth to save 8-bit uchar images as 1, 2 or 4-bit TIFFs.

In case of depth 1: Values &gt;128 are written as white, values &lt;=128 as black.
Normally vips will write MINISBLACK TIFFs where black is a 0 bit, but if you
set @miniswhite, it will use 0 for a white bit. Many pre-press applications
only work with images which use this sense. @miniswhite only affects one-bit
images, it does nothing for greyscale images.

In case of depth 2: The same holds but values &lt; 64 are written as black.
For 64 &lt;= values &lt; 128 they are written as dark grey, for 128 &lt;= values &lt; 192
they are written as light gray and values above are written as white.
In case @miniswhite is set to true this behavior is inverted.
In case of depth 4: values &lt; 16 are written as black, and so on for the
lighter shades. In case @miniswhite is set to true this behavior is inverted.

Use @resunit to override the default resolution unit. The default
resolution unit is taken from the header field [const@META_RESOLUTION_UNIT].
If this field is not set, then VIPS defaults to cm.

Use @xres and @yres to override the default horizontal and vertical
resolutions. By default these values are taken from the VIPS image header.
libvips resolution is always in pixels per millimetre.

Set @bigtiff to attempt to write a bigtiff. Bigtiff is a variant of the TIFF
format that allows more than 4GB in a file.

Set @properties to write all vips metadata to the IMAGEDESCRIPTION tag as
xml. If @properties is not set, the value of [const@META_IMAGEDESCRIPTION] is
used instead.

The value of [const@META_XMP_NAME] is written to the XMP tag.
[const@META_ORIENTATION] (if set) is used to set the value of the
orientation tag. [const@META_IPTC_NAME] (if set) is used to set the
value of the IPTC tag. [const@META_PHOTOSHOP_NAME] (if set) is used to
set the value of the PHOTOSHOP tag.

By default, pyramid layers are saved as consecutive pages.
Set @subifd to save pyramid layers as sub-directories of the main image.
Setting this option can improve compatibility with formats like OME.

Set @premultiply to save with premultiplied alpha. Some programs, such as
InDesign, will only work with premultiplied alpha.

::: tip "Optional arguments"
    * @compression: [enum@ForeignTiffCompression], write with this
      compression
    * @Q: `gint`, quality factor
    * @predictor: [enum@ForeignTiffPredictor], use this predictor
    * @tile: `gboolean`, set `TRUE` to write a tiled tiff
    * @tile_width: `gint`, for tile size
    * @tile_height: `gint`, for tile size
    * @pyramid: `gboolean`, write an image pyramid
    * @bitdepth: `gint`, change bit depth to 1,2, or 4 bit
    * @miniswhite: `gboolean`, write 1-bit images as MINISWHITE
    * @resunit: [enum@ForeignTiffResunit] for resolution unit
    * @xres: `gdouble`, horizontal resolution in pixels/mm
    * @yres: `gdouble`, vertical resolution in pixels/mm
    * @bigtiff: `gboolean`, write a BigTiff file
    * @properties: `gboolean`, set `TRUE` to write an IMAGEDESCRIPTION tag
    * @region_shrink: [enum@RegionShrink] How to shrink each 2x2 region.
    * @level: `gint`, Zstd or Deflate (zlib) compression level
    * @lossless: `gboolean`, WebP lossless mode
    * @depth: [enum@ForeignDzDepth] how deep to make the pyramid
    * @subifd: `gboolean`, write pyr layers as sub-ifds
    * @premultiply: `gboolean`, write premultiplied alpha

::: seealso
    [ctor@Image.tiffload], [method@Image.write_to_file].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="645"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/tiffsave.c"
               line="711">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/tiffsave.c"
                 line="598">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/tiffsave.c"
                 line="599">file to write to</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/tiffsave.c"
                 line="600">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="tiffsave_buffer"
              c:identifier="vips_tiffsave_buffer"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/tiffsave.c"
             line="726">As [method@Image.tiffsave], but save to a memory buffer.

The address of the buffer is returned in @buf, the length of the buffer in
@len. You are responsible for freeing the buffer with [func@GLib.free] when you
are done with it.

::: tip "Optional arguments"
    * @compression: [enum@ForeignTiffCompression], write with this
      compression
    * @Q: `gint`, quality factor
    * @predictor: [enum@ForeignTiffPredictor], use this predictor
    * @tile: `gboolean`, set `TRUE` to write a tiled tiff
    * @tile_width: `gint`, for tile size
    * @tile_height: `gint`, for tile size
    * @pyramid: `gboolean`, write an image pyramid
    * @bitdepth: `gint`, change bit depth to 1,2, or 4 bit
    * @miniswhite: `gboolean`, write 1-bit images as MINISWHITE
    * @resunit: [enum@ForeignTiffResunit] for resolution unit
    * @xres: `gdouble`, horizontal resolution in pixels/mm
    * @yres: `gdouble`, vertical resolution in pixels/mm
    * @bigtiff: `gboolean`, write a BigTiff file
    * @properties: `gboolean`, set `TRUE` to write an IMAGEDESCRIPTION tag
    * @region_shrink: [enum@RegionShrink] How to shrink each 2x2 region.
    * @level: `gint`, Zstd or Deflate (zlib) compression level
    * @lossless: `gboolean`, WebP lossless mode
    * @depth: [enum@ForeignDzDepth] how deep to make the pyramid
    * @subifd: `gboolean`, write pyr layers as sub-ifds
    * @premultiply: `gboolean`, write premultiplied alpha

::: seealso
    [method@Image.tiffsave], [method@Image.write_to_file].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="648"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/tiffsave.c"
               line="765">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/tiffsave.c"
                 line="728">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/tiffsave.c"
                 line="729">return output buffer here</doc>
            <array length="1" zero-terminated="0" c:type="void**">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/tiffsave.c"
                 line="730">return output length here</doc>
            <type name="gsize" c:type="size_t*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/tiffsave.c"
                 line="731">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="tiffsave_target"
              c:identifier="vips_tiffsave_target"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/tiffsave.c"
             line="795">As [method@Image.tiffsave], but save to a target.

::: tip "Optional arguments"
    * @compression: [enum@ForeignTiffCompression], write with this
      compression
    * @Q: `gint`, quality factor
    * @predictor: [enum@ForeignTiffPredictor], use this predictor
    * @tile: `gboolean`, set `TRUE` to write a tiled tiff
    * @tile_width: `gint`, for tile size
    * @tile_height: `gint`, for tile size
    * @pyramid: `gboolean`, write an image pyramid
    * @bitdepth: `gint`, change bit depth to 1,2, or 4 bit
    * @miniswhite: `gboolean`, write 1-bit images as MINISWHITE
    * @resunit: [enum@ForeignTiffResunit] for resolution unit
    * @xres: `gdouble`, horizontal resolution in pixels/mm
    * @yres: `gdouble`, vertical resolution in pixels/mm
    * @bigtiff: `gboolean`, write a BigTiff file
    * @properties: `gboolean`, set `TRUE` to write an IMAGEDESCRIPTION tag
    * @region_shrink: [enum@RegionShrink] How to shrink each 2x2 region.
    * @level: `gint`, Zstd or Deflate (zlib) compression level
    * @lossless: `gboolean`, WebP lossless mode
    * @depth: [enum@ForeignDzDepth] how deep to make the pyramid
    * @subifd: `gboolean`, write pyr layers as sub-ifds
    * @premultiply: `gboolean`, write premultiplied alpha

::: seealso
    [method@Image.tiffsave], [method@Image.write_to_target].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="651"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/tiffsave.c"
               line="829">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/tiffsave.c"
                 line="797">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/tiffsave.c"
                 line="798">save image to this target</doc>
            <type name="Target" c:type="VipsTarget*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/tiffsave.c"
                 line="799">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="tilecache"
              c:identifier="vips_tilecache"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/tilecache.c"
             line="834">This operation behaves rather like [method@Image.copy] between images
@in and @out, except that it keeps a cache of computed pixels.
This cache is made of up to @max_tiles tiles (a value of -1
means any number of tiles), and each tile is of size @tile_width
by @tile_height pixels.

Each cache tile is made with a single call to
[method@Region.prepare].

When the cache fills, a tile is chosen for reuse. If @access is
[enum@Vips.Access.RANDOM], then the least-recently-used tile is reused. If
@access is [enum@Vips.Access.SEQUENTIAL]
the top-most tile is reused.

By default, @tile_width and @tile_height are 128 pixels, and the operation
will cache up to 1,000 tiles. @access defaults to [enum@Vips.Access.RANDOM].

Normally, only a single thread at once is allowed to calculate tiles. If
you set @threaded to `TRUE`, [method@Image.tilecache] will allow many
threads to calculate tiles at once, and share the cache between them.

Normally the cache is dropped when computation finishes. Set @persistent to
`TRUE` to keep the cache between computations.

::: tip "Optional arguments"
    * @tile_width: `gint`, width of tiles in cache
    * @tile_height: `gint`, height of tiles in cache
    * @max_tiles: `gint`, maximum number of tiles to cache
    * @access: [enum@Access], hint expected access pattern
    * @threaded: `gboolean`, allow many threads
    * @persistent: `gboolean`, don't drop cache at end of computation

::: seealso
    [method@Image.linecache].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="141"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/tilecache.c"
               line="876">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/tilecache.c"
                 line="836">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/tilecache.c"
                 line="837">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/tilecache.c"
                 line="838">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="transpose3d"
              c:identifier="vips_transpose3d"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/transpose3d.c"
             line="185">Transpose a volumetric image.

Volumetric images are very tall, thin images, with the metadata item
[const@META_PAGE_HEIGHT] set to the height of each sub-image.

This operation swaps the two major dimensions, so that page N in the
output contains the Nth scanline, in order, from each input page.

You can override the [const@META_PAGE_HEIGHT] metadata item with the optional
@page_height parameter.

[const@META_PAGE_HEIGHT] in the output image is the number of pages in the
input image.

::: tip "Optional arguments"
    * @page_height: `gint`, size of each input page

::: seealso
    [method@Image.grid].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="197"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/transpose3d.c"
               line="211">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/transpose3d.c"
                 line="187">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/transpose3d.c"
                 line="188">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/transpose3d.c"
                 line="189">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="uhdr2scRGB"
              c:identifier="vips_uhdr2scRGB"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/colour/uhdr2scRGB.c"
             line="287">Transform a uhdr image (three band sRGB with an attached gainmap) to
scRGB.</doc>
        <source-position filename="libvips/include/vips/colour.h" line="220"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/uhdr2scRGB.c"
               line="296">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/uhdr2scRGB.c"
                 line="289">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/colour/uhdr2scRGB.c"
                 line="290">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/colour/uhdr2scRGB.c"
                 line="291">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="uhdrsave" c:identifier="vips_uhdrsave" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/uhdrsave.c"
             line="731">Save an image as UltraHDR.

If an image is sRGB and has a gainmap, it will be saved as UltraHDR with no
gainmap recomputation.

If the image is scRGB and has a gainmap, a base image will be computed
and it will be saved as UltraHDR.

If the image is scRGB and has no gainmap, one will be computed.
This is slow and takes a lot of memory.

::: seealso
    [method@Image.write_to_file], [ctor@Image.uhdrload].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="928"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/uhdrsave.c"
               line="751">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/uhdrsave.c"
                 line="733">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/uhdrsave.c"
                 line="734">file to write to</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/uhdrsave.c"
                 line="735">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="uhdrsave_buffer"
              c:identifier="vips_uhdrsave_buffer"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/uhdrsave.c"
             line="766">As [method@Image.uhdrsave], but save to a memory buffer.

::: seealso
    [method@Image.uhdrsave], [method@Image.write_to_file].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="931"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/uhdrsave.c"
               line="778">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/uhdrsave.c"
                 line="768">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/uhdrsave.c"
                 line="769">return output buffer here</doc>
            <array length="1" zero-terminated="0" c:type="void**">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/uhdrsave.c"
                 line="770">return output length here</doc>
            <type name="gsize" c:type="size_t*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/uhdrsave.c"
                 line="771">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="uhdrsave_target"
              c:identifier="vips_uhdrsave_target"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/uhdrsave.c"
             line="808">As [method@Image.uhdrsave], but save to a target.

::: seealso
    [method@Image.uhdrsave], [method@Image.write_to_target].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="934"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/uhdrsave.c"
               line="819">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/uhdrsave.c"
                 line="810">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/uhdrsave.c"
                 line="811">save image to this target</doc>
            <type name="Target" c:type="VipsTarget*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/uhdrsave.c"
                 line="812">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="unpremultiply"
              c:identifier="vips_unpremultiply"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/unpremultiply.c"
             line="349">Unpremultiplies any alpha channel.

Band @alpha_band (by default the final band) contains the alpha and all
other bands are transformed as:

```
alpha = (int) clip(0, in[in.bands - 1], max_alpha);
norm = (double) alpha / max_alpha
if (alpha == 0)
    out = [0, ..., 0, alpha]
else
    out = [in[0] / norm, ..., in[in.bands - 1] / norm, alpha]
```

So for an N-band image, the first N - 1 bands are divided by the clipped
and normalised final band, the final band is clipped.
If there is only a single band, the image is passed through unaltered.

The result is [enum@Vips.BandFormat.FLOAT] unless the input format is
[enum@Vips.BandFormat.DOUBLE], in which case the output is double as well.

@max_alpha has the default value 255, or 65535 for images tagged as
[enum@Vips.Interpretation.RGB16] or [enum@Vips.Interpretation.GREY16], and
1.0 for images tagged as  [enum@Vips.Interpretation.scRGB.

Non-complex images only.

::: tip "Optional arguments"
    * @max_alpha: `gdouble`, maximum value for alpha
    * @alpha_band: `gint`, band containing alpha data

::: seealso
    [method@Image.premultiply], [method@Image.flatten].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="333"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/unpremultiply.c"
               line="389">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/unpremultiply.c"
                 line="351">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/unpremultiply.c"
                 line="352">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/unpremultiply.c"
                 line="353">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="vipssave" c:identifier="vips_vipssave" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/vipssave.c"
             line="256">Write @in to @filename in VIPS format.

::: seealso
    [ctor@Image.vipsload].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="476"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/vipssave.c"
               line="267">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/vipssave.c"
                 line="258">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/vipssave.c"
                 line="259">file to write to</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/vipssave.c"
                 line="260">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="vipssave_target"
              c:identifier="vips_vipssave_target"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/vipssave.c"
             line="282">As [method@Image.vipssave], but save to a target.</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="479"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/vipssave.c"
               line="290">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/vipssave.c"
                 line="284">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/vipssave.c"
                 line="285">save image to this target</doc>
            <type name="Target" c:type="VipsTarget*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/vipssave.c"
                 line="286">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="webpsave" c:identifier="vips_webpsave" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/webpsave.c"
             line="1175">Write an image to a file in WebP format.

By default, images are saved in lossy format, with
@Q giving the WebP quality factor. It has the range 0 - 100, with the
default 75.

Use @preset to hint the image type to the lossy compressor. The default is
[enum@Vips.ForeignWebpPreset.DEFAULT].

Set @smart_subsample to enable high quality chroma subsampling.

Set @smart_deblock to enable auto-adjusting of the deblocking filter. This
can improve image quality, especially on low-contrast edges, but encoding
can take significantly longer.

Use @alpha_q to set the quality for the alpha channel in lossy mode. It has
the range 1 - 100, with the default 100.

Use @effort to control how much CPU time to spend attempting to
reduce file size. A higher value means more effort and therefore CPU time
should be spent. It has the range 0-6 and a default value of 4.

Use @target_size to set the desired target size in bytes.

Use @passes to set the number of entropy-analysis passes, by default 1,
unless @target_size is set, in which case the default is 3. It is not
recommended to set @passes unless you set @target_size. Doing so will
result in longer encoding times for no benefit.

Set @lossless to use lossless compression, or combine @near_lossless
with @Q 80, 60, 40 or 20 to apply increasing amounts of preprocessing
which improves the near-lossless compression ratio by up to 50%.

Set @exact to preserve the color data in transparent pixels. This can
reduce compression efficiency, but is generally required when working with
images as data.

For animated webp output, @min_size will try to optimize for minimum size.

For animated webp output, @kmax sets the maximum number of frames between
keyframes. Setting 0 means only keyframes. @kmin sets the minimum number of
frames between frames. Setting 0 means no keyframes. By default, keyframes
are disabled.

For animated webp output, @mixed tries to improve the file size by mixing
both lossy and lossless encoding.

Use the metadata items `loop` and `delay` to set the number of
loops for the animation and the frame delays.

::: tip "Optional arguments"
    * @Q: `gint`, quality factor
    * @lossless: `gboolean`, enables lossless compression
    * @exact: `gboolean`, preserves color values from transparent pixels
    * @preset: [enum@ForeignWebpPreset], choose lossy compression preset
    * @smart_subsample: `gboolean`, enables high quality chroma subsampling
    * @smart_deblock: `gboolean`, enables auto-adjusting of the deblocking
      filter
    * @near_lossless: `gboolean`, preprocess in lossless mode (controlled
      by Q)
    * @alpha_q: `gint`, set alpha quality in lossless mode
    * @effort: `gint`, level of CPU effort to reduce file size
    * @target_size: `gint`, desired target size in bytes
    * @passes: `gint`, number of entropy-analysis passes
    * @min_size: `gboolean`, minimise size
    * @mixed: `gboolean`, allow both lossy and lossless encoding
    * @kmin: `gint`, minimum number of frames between keyframes
    * @kmax: `gint`, maximum number of frames between keyframes

::: seealso
    [ctor@Image.webpload], [method@Image.write_to_file].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="562"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/webpsave.c"
               line="1253">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/webpsave.c"
                 line="1177">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/webpsave.c"
                 line="1178">file to write to</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/webpsave.c"
                 line="1179">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="webpsave_buffer"
              c:identifier="vips_webpsave_buffer"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/webpsave.c"
             line="1268">As [method@Image.webpsave], but save to a memory buffer.

The address of the buffer is returned in @buf, the length of the buffer in
@len. You are responsible for freeing the buffer with [func@GLib.free] when you
are done with it.

::: tip "Optional arguments"
    * @Q: `gint`, quality factor
    * @lossless: `gboolean`, enables lossless compression
    * @preset: [enum@ForeignWebpPreset], choose lossy compression preset
    * @exact: `gboolean`, preserves color values from transparent pixels
    * @smart_subsample: `gboolean`, enables high quality chroma subsampling
    * @smart_deblock: `gboolean`, enables auto-adjusting of the deblocking
      filter
    * @near_lossless: `gboolean`, preprocess in lossless mode (controlled
      by Q)
    * @alpha_q: `gint`, set alpha quality in lossless mode
    * @effort: `gint`, level of CPU effort to reduce file size
    * @target_size: `gint`, desired target size in bytes
    * @passes: `gint`, number of entropy-analysis passes
    * @min_size: `gboolean`, minimise size
    * @mixed: `gboolean`, allow both lossy and lossless encoding
    * @kmin: `gint`, minimum number of frames between keyframes
    * @kmax: `gint`, maximum number of frames between keyframes

::: seealso
    [method@Image.webpsave].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="565"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/webpsave.c"
               line="1303">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/webpsave.c"
                 line="1270">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="buf"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/foreign/webpsave.c"
                 line="1271">return output buffer here</doc>
            <array length="1" zero-terminated="0" c:type="void**">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="len"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/foreign/webpsave.c"
                 line="1272">return output length here</doc>
            <type name="gsize" c:type="size_t*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/webpsave.c"
                 line="1273">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="webpsave_mime"
              c:identifier="vips_webpsave_mime"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/webpsave.c"
             line="1333">As [method@Image.webpsave], but save as a mime webp on stdout.

::: tip "Optional arguments"
    * @Q: `gint`, quality factor
    * @lossless: `gboolean`, enables lossless compression
    * @exact: `gboolean`, preserves color values from transparent pixels
    * @preset: [enum@ForeignWebpPreset], choose lossy compression preset
    * @smart_subsample: `gboolean`, enables high quality chroma subsampling
    * @smart_deblock: `gboolean`, enables auto-adjusting of the deblocking
      filter
    * @near_lossless: `gboolean`, preprocess in lossless mode (controlled
      by Q)
    * @alpha_q: `gint`, set alpha quality in lossless mode
    * @effort: `gint`, level of CPU effort to reduce file size
    * @target_size: `gint`, desired target size in bytes
    * @passes: `gint`, number of entropy-analysis passes
    * @min_size: `gboolean`, minimise size
    * @mixed: `gboolean`, allow both lossy and lossless encoding
    * @kmin: `gint`, minimum number of frames between keyframes
    * @kmax: `gint`, maximum number of frames between keyframes

::: seealso
    [method@Image.webpsave], [method@Image.write_to_file].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="568"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/webpsave.c"
               line="1362">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/webpsave.c"
                 line="1335">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/webpsave.c"
                 line="1336">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="webpsave_target"
              c:identifier="vips_webpsave_target"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/foreign/webpsave.c"
             line="1377">As [method@Image.webpsave], but save to a target.

::: tip "Optional arguments"
    * @Q: `gint`, quality factor
    * @lossless: `gboolean`, enables lossless compression
    * @preset: [enum@ForeignWebpPreset], choose lossy compression preset
    * @smart_subsample: `gboolean`, enables high quality chroma subsampling
    * @smart_deblock: `gboolean`, enables auto-adjusting of the deblocking
      filter
    * @near_lossless: `gboolean`, preprocess in lossless mode (controlled
      by Q)
    * @alpha_q: `gint`, set alpha quality in lossless mode
    * @effort: `gint`, level of CPU effort to reduce file size
    * @target_size: `gint`, desired target size in bytes
    * @passes: `gint`, number of entropy-analysis passes
    * @min_size: `gboolean`, minimise size
    * @mixed: `gboolean`, allow both lossy and lossless encoding
    * @kmin: `gint`, minimum number of frames between keyframes
    * @kmax: `gint`, maximum number of frames between keyframes

::: seealso
    [method@Image.webpsave].</doc>
        <source-position filename="libvips/include/vips/foreign.h" line="559"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/webpsave.c"
               line="1406">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/webpsave.c"
                 line="1379">image to save</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/webpsave.c"
                 line="1380">save image to this target</doc>
            <type name="Target" c:type="VipsTarget*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/foreign/webpsave.c"
                 line="1381">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="wio_input" c:identifier="vips_image_wio_input">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="3355">Check that an image is readable via the [func@IMAGE_ADDR] macro, that is,
that the entire image is in memory and all pixels can be read with
[func@IMAGE_ADDR].  If it
isn't, try to transform it so that [func@IMAGE_ADDR] can work.

Since this function modifies @image, it is not thread-safe. Only call it on
images which you are sure have not been shared with another thread. If the
image might have been shared, use the less efficient
[method@Image.copy_memory] instead.

::: seealso
    [method@Image.copy_memory], [method@Image.pio_input],
    [method@Image.inplace], [func@IMAGE_ADDR].</doc>
        <source-position filename="libvips/include/vips/image.h" line="554"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="3373">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="3357">image to transform</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="wop" c:identifier="vips_wop" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/math2.c"
             line="333">Perform [enum@Vips.OperationMath2.WOP] on a pair of images. See
[method@Image.math2].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="493"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/math2.c"
               line="343">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="335">left-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="336">right-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="337">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="338">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="wop_const"
              c:identifier="vips_wop_const"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/math2.c"
             line="576">Perform [enum@Vips.OperationMath2.WOP] on an image and a constant. See
[method@Image.math2_const].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="507"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/math2.c"
               line="587">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="578">left-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="579">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="580">array of constants</doc>
            <array length="2" zero-terminated="0" c:type="const double*">
              <type name="gdouble" c:type="double"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="581">number of constants in @c</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="582">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="wop_const1"
              c:identifier="vips_wop_const1"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/math2.c"
             line="683">Perform [enum@Vips.OperationMath2.WOP] on an image and a constant. See
[method@Image.math2_const].</doc>
        <source-position filename="libvips/include/vips/arithmetic.h"
                         line="522"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/math2.c"
               line="693">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="685">left-hand input [class@Image]</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="686">output [class@Image]</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="687">constant</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/arithmetic/math2.c"
                 line="688">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="wrap" c:identifier="vips_wrap" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/wrap.c"
             line="144">Slice an image up and move the segments about so that the pixel that was
at 0, 0 is now at @x, @y.

If @x and @y are not set, they default to the centre of the image.

::: tip "Optional arguments"
    * @x: `gint`, horizontal displacement
    * @y: `gint`, vertical displacement

::: seealso
    [method@Image.embed], [method@Image.replicate].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="200"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/wrap.c"
               line="162">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/wrap.c"
                 line="146">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/wrap.c"
                 line="147">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/wrap.c"
                 line="148">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="write" c:identifier="vips_image_write">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="2607">Write @image to @out. Use [ctor@Image.new] and friends to create the
[class@Image] you want to write to.

::: seealso
    [ctor@Image.new], [method@Image.copy], [method@Image.write_to_file].</doc>
        <source-position filename="libvips/include/vips/image.h" line="519"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="2618">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2609">image to write</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2610">write to this image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="write_line" c:identifier="vips_image_write_line">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="3161">Write a line of pixels to an image. This function must be called repeatedly
with @ypos increasing from 0 to [property@Image:height].
@linebuffer must be [func@IMAGE_SIZEOF_LINE] bytes long.

::: seealso
    [method@Image.generate].</doc>
        <source-position filename="libvips/include/vips/image.h" line="565"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="3174">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="3163">image to write to</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="ypos" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="3164">vertical position of scan-line to write</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="linebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="3165">scanline of pixels</doc>
            <type name="Pel" c:type="VipsPel*"/>
          </parameter>
        </parameters>
      </method>
      <method name="write_prepare" c:identifier="vips_image_write_prepare">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="3096">Call this after setting header fields (width, height, and so on) to
allocate resources ready for writing.

Normally this function is called for you by [method@Image.generate] or
[method@Image.write_line]. You will need to call it yourself if you plan to
write directly to the -&gt;data member of a memory image.</doc>
        <source-position filename="libvips/include/vips/image.h" line="562"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="3107">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="3098">image to prepare</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="write_to_buffer"
              c:identifier="vips_image_write_to_buffer"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="2724">Writes @in to a memory buffer in a format specified by @suffix.

Save options may be appended to @suffix as `[name=value,...]` or given as
a `NULL`-terminated list of name-value pairs at the end of the arguments.
Options given in the function call override options given in the filename.

Currently only TIFF, JPEG and PNG formats are supported.

You can call the various save operations directly if you wish, see
[method@Image.jpegsave_buffer], for example.

::: seealso
    [method@Image.write_to_memory], [ctor@Image.new_from_buffer].</doc>
        <source-position filename="libvips/include/vips/image.h" line="524"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="2746">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2726">image to write</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="suffix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2727">format to write</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="buf" transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2728">return buffer start here</doc>
            <array length="2" zero-terminated="0" c:type="void**">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2729">return buffer length here</doc>
            <type name="gsize" c:type="size_t*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2730">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="write_to_file"
              c:identifier="vips_image_write_to_file"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="2661">Writes @in to @name using the saver recommended by
[func@Foreign.find_save].

Save options may be appended to @filename as `[name=value,...]` or given as
a `NULL`-terminated list of name-value pairs at the end of the arguments.
Options given in the function call override options given in the filename.

::: seealso
    [ctor@Image.new_from_file].</doc>
        <source-position filename="libvips/include/vips/image.h" line="521"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="2677">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2663">image to write</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2664">write to this file</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2665">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="write_to_memory" c:identifier="vips_image_write_to_memory">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="2861">Writes @in to memory as a simple, unformatted C-style array.

The caller is responsible for freeing this memory with [func@GLib.free].

::: seealso
    [method@Image.write_to_buffer].</doc>
        <source-position filename="libvips/include/vips/image.h" line="532"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="2873">return buffer start here</doc>
          <array length="0" zero-terminated="0" c:type="void*">
            <type name="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2863">image to write</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="size"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2864">return buffer length here</doc>
            <type name="gsize" c:type="size_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="write_to_target"
              c:identifier="vips_image_write_to_target"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="2815">Writes @in to @output in format @suffix.

Save options may be appended to @suffix as `[name=value,...]` or given as
a `NULL`-terminated list of name-value pairs at the end of the arguments.
Options given in the function call override options given in the filename.

You can call the various save operations directly if you wish, see
[method@Image.jpegsave_target], for example.

::: seealso
    [method@Image.write_to_file].</doc>
        <source-position filename="libvips/include/vips/image.h" line="528"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="2834">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2817">image to write</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="suffix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2818">format to write</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2819">target to write to</doc>
            <type name="Target" c:type="VipsTarget*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="2820">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="zoom" c:identifier="vips_zoom" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/conversion/zoom.c"
             line="398">Zoom an image by repeating pixels. This is fast nearest-neighbour
zoom.

::: seealso
    [method@Image.affine], [method@Image.subsample].</doc>
        <source-position filename="libvips/include/vips/conversion.h"
                         line="223"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/zoom.c"
               line="412">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/zoom.c"
                 line="400">input image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/conversion/zoom.c"
                 line="401">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter name="xfac" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/zoom.c"
                 line="402">horizontal scale factor</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="yfac" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/zoom.c"
                 line="403">vertical scale factor</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/conversion/zoom.c"
                 line="404">`NULL`-terminated list of optional named arguments</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <property name="bands"
                writable="1"
                transfer-ownership="none"
                getter="get_bands"
                default-value="1">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="coding"
                writable="1"
                transfer-ownership="none"
                getter="get_coding"
                default-value="VIPS_CODING_NONE">
        <type name="Coding"/>
      </property>
      <property name="demand"
                writable="1"
                transfer-ownership="none"
                default-value="VIPS_DEMAND_STYLE_SMALLTILE">
        <type name="DemandStyle"/>
      </property>
      <property name="filename"
                writable="1"
                transfer-ownership="none"
                getter="get_filename"
                default-value="NULL">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="foreign-buffer" writable="1" transfer-ownership="none">
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="format"
                writable="1"
                transfer-ownership="none"
                getter="get_format"
                default-value="VIPS_FORMAT_UCHAR">
        <type name="BandFormat"/>
      </property>
      <property name="height"
                writable="1"
                transfer-ownership="none"
                getter="get_height"
                default-value="1">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="interpretation"
                writable="1"
                transfer-ownership="none"
                getter="get_interpretation"
                default-value="VIPS_INTERPRETATION_MULTIBAND">
        <type name="Interpretation"/>
      </property>
      <property name="kill"
                writable="1"
                transfer-ownership="none"
                setter="set_kill"
                default-value="FALSE">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="mode"
                writable="1"
                transfer-ownership="none"
                getter="get_mode"
                default-value="p">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="sizeof-header"
                writable="1"
                transfer-ownership="none"
                default-value="64">
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="width"
                writable="1"
                transfer-ownership="none"
                getter="get_width"
                default-value="1">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="xoffset"
                writable="1"
                transfer-ownership="none"
                getter="get_xoffset"
                default-value="0">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="xres"
                writable="1"
                transfer-ownership="none"
                getter="get_xres"
                default-value="0.000000">
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <property name="yoffset"
                writable="1"
                transfer-ownership="none"
                getter="get_yoffset"
                default-value="0">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="yres"
                writable="1"
                transfer-ownership="none"
                getter="get_yres"
                default-value="0.000000">
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <field name="parent_instance">
        <type name="Object" c:type="VipsObject"/>
      </field>
      <field name="Xsize" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="Ysize" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="Bands" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="BandFmt" readable="0" private="1">
        <type name="BandFormat" c:type="VipsBandFormat"/>
      </field>
      <field name="Coding" readable="0" private="1">
        <type name="Coding" c:type="VipsCoding"/>
      </field>
      <field name="Type" readable="0" private="1">
        <type name="Interpretation" c:type="VipsInterpretation"/>
      </field>
      <field name="Xres" readable="0" private="1">
        <type name="gdouble" c:type="double"/>
      </field>
      <field name="Yres" readable="0" private="1">
        <type name="gdouble" c:type="double"/>
      </field>
      <field name="Xoffset" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="Yoffset" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="Length" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="Compression" readable="0" private="1">
        <type name="gshort" c:type="short"/>
      </field>
      <field name="Level" readable="0" private="1">
        <type name="gshort" c:type="short"/>
      </field>
      <field name="Bbits" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="time" readable="0" private="1">
        <type name="Progress" c:type="VipsProgress*"/>
      </field>
      <field name="Hist" readable="0" private="1">
        <type name="utf8" c:type="char*"/>
      </field>
      <field name="filename" readable="0" private="1">
        <type name="utf8" c:type="char*"/>
      </field>
      <field name="data" readable="0" private="1">
        <type name="Pel" c:type="VipsPel*"/>
      </field>
      <field name="kill" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="Xres_float" readable="0" private="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="Yres_float" readable="0" private="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="mode" readable="0" private="1">
        <type name="utf8" c:type="char*"/>
      </field>
      <field name="dtype" readable="0" private="1">
        <type name="ImageType" c:type="VipsImageType"/>
      </field>
      <field name="fd" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="baseaddr" readable="0" private="1">
        <type name="gpointer" c:type="void*"/>
      </field>
      <field name="length" readable="0" private="1">
        <type name="gsize" c:type="size_t"/>
      </field>
      <field name="magic" readable="0" private="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="start_fn" readable="0" private="1">
        <type name="StartFn" c:type="VipsStartFn"/>
      </field>
      <field name="generate_fn" readable="0" private="1">
        <type name="GenerateFn" c:type="VipsGenerateFn"/>
      </field>
      <field name="stop_fn" readable="0" private="1">
        <type name="StopFn" c:type="VipsStopFn"/>
      </field>
      <field name="client1" readable="0" private="1">
        <type name="gpointer" c:type="void*"/>
      </field>
      <field name="client2" readable="0" private="1">
        <type name="gpointer" c:type="void*"/>
      </field>
      <field name="sslock" readable="0" private="1">
        <type name="GLib.Mutex" c:type="GMutex"/>
      </field>
      <field name="regions" readable="0" private="1">
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="dhint" readable="0" private="1">
        <type name="DemandStyle" c:type="VipsDemandStyle"/>
      </field>
      <field name="meta" readable="0" private="1">
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="gpointer" c:type="gpointer"/>
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="meta_traverse" readable="0" private="1">
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="sizeof_header" readable="0" private="1">
        <type name="gint64" c:type="gint64"/>
      </field>
      <field name="windows" readable="0" private="1">
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="upstream" readable="0" private="1">
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="downstream" readable="0" private="1">
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="serial" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="history_list" readable="0" private="1">
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="progress_signal" readable="0" private="1">
        <type name="Image" c:type="VipsImage*"/>
      </field>
      <field name="file_length" readable="0" private="1">
        <type name="gint64" c:type="gint64"/>
      </field>
      <field name="hint_set" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="delete_on_close" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="delete_on_close_filename" readable="0" private="1">
        <type name="utf8" c:type="char*"/>
      </field>
      <glib:signal name="eval" when="last">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="1211">This signal is emitted once per work unit (typically a 128 x
128 area of pixels) during image computation.

You can use this signal to update user-interfaces with progress
feedback. Beware of updating too frequently: you will usually
need some throttling mechanism.

Use [method@Image.set_progress] to turn on progress reporting for an
image.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="progress" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="1214">[struct@Progress] for this image</doc>
            <type name="Progress" c:type="gpointer"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="invalidate" when="last" action="1">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="1274">This signal is emitted when an image or one of it's
upstream data sources has been destructively modified. See
[method@Image.invalidate_all].</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="minimise" when="last" action="1">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="1290">This signal is emitted when an image has been asked to
minimise memory usage. All non-essential caches are dropped.
See [method@Image.minimise_all].</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="posteval" when="last">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="1235">This signal is emitted once at the end of the computation
of @image. It's a good place to shut down evaluation feedback.

Use [method@Image.set_progress] to turn on progress reporting for an
image.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="progress" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="1238">[struct@Progress] for this image</doc>
            <type name="Progress" c:type="gpointer"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="preeval" when="last">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="1191">This signal is emitted once before computation of @image
starts. It's a good place to set up evaluation feedback.

Use [method@Image.set_progress] to turn on progress reporting for an
image.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="progress" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="1194">[struct@Progress] for this image</doc>
            <type name="Progress" c:type="gpointer"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="written" when="last" action="1">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="1255">This signal is emitted just after an image has been
written to. It is
used by vips to implement things like write to foreign file
formats.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="result"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="1258">set to non-zero to indicate error</doc>
            <type name="gint" c:type="gpointer"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ImageClass"
            c:type="VipsImageClass"
            glib:is-gtype-struct-for="Image">
      <source-position filename="libvips/include/vips/image.h" line="371"/>
      <field name="parent_class">
        <type name="ObjectClass" c:type="VipsObjectClass"/>
      </field>
      <field name="preeval">
        <callback name="preeval">
          <source-position filename="libvips/include/vips/image.h" line="339"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="image" transfer-ownership="none">
              <type name="Image" c:type="VipsImage*"/>
            </parameter>
            <parameter name="progress" transfer-ownership="none">
              <type name="Progress" c:type="VipsProgress*"/>
            </parameter>
            <parameter name="data"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <type name="gpointer" c:type="void*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="eval">
        <callback name="eval">
          <source-position filename="libvips/include/vips/image.h" line="343"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="image" transfer-ownership="none">
              <type name="Image" c:type="VipsImage*"/>
            </parameter>
            <parameter name="progress" transfer-ownership="none">
              <type name="Progress" c:type="VipsProgress*"/>
            </parameter>
            <parameter name="data"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <type name="gpointer" c:type="void*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="posteval">
        <callback name="posteval">
          <source-position filename="libvips/include/vips/image.h" line="347"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="image" transfer-ownership="none">
              <type name="Image" c:type="VipsImage*"/>
            </parameter>
            <parameter name="progress" transfer-ownership="none">
              <type name="Progress" c:type="VipsProgress*"/>
            </parameter>
            <parameter name="data"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <type name="gpointer" c:type="void*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="written">
        <callback name="written">
          <source-position filename="libvips/include/vips/image.h" line="354"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="image" transfer-ownership="none">
              <type name="Image" c:type="VipsImage*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <type name="gint" c:type="int*"/>
            </parameter>
            <parameter name="data"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <type name="gpointer" c:type="void*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="invalidate">
        <callback name="invalidate">
          <source-position filename="libvips/include/vips/image.h" line="359"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="image" transfer-ownership="none">
              <type name="Image" c:type="VipsImage*"/>
            </parameter>
            <parameter name="data"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <type name="gpointer" c:type="void*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="minimise">
        <callback name="minimise">
          <source-position filename="libvips/include/vips/image.h" line="369"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="image" transfer-ownership="none">
              <type name="Image" c:type="VipsImage*"/>
            </parameter>
            <parameter name="data"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <type name="gpointer" c:type="void*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <callback name="ImageMapFn" c:type="VipsImageMapFn">
      <source-position filename="libvips/include/vips/header.h" line="279"/>
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="image" transfer-ownership="none">
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="ImageType"
                 glib:type-name="VipsImageType"
                 glib:get-type="vips_image_type_get_type"
                 c:type="VipsImageType">
      <member name="error"
              value="-1"
              c:identifier="VIPS_IMAGE_ERROR"
              glib:nick="error"
              glib:name="VIPS_IMAGE_ERROR">
      </member>
      <member name="none"
              value="0"
              c:identifier="VIPS_IMAGE_NONE"
              glib:nick="none"
              glib:name="VIPS_IMAGE_NONE">
      </member>
      <member name="setbuf"
              value="1"
              c:identifier="VIPS_IMAGE_SETBUF"
              glib:nick="setbuf"
              glib:name="VIPS_IMAGE_SETBUF">
      </member>
      <member name="setbuf_foreign"
              value="2"
              c:identifier="VIPS_IMAGE_SETBUF_FOREIGN"
              glib:nick="setbuf-foreign"
              glib:name="VIPS_IMAGE_SETBUF_FOREIGN">
      </member>
      <member name="openin"
              value="3"
              c:identifier="VIPS_IMAGE_OPENIN"
              glib:nick="openin"
              glib:name="VIPS_IMAGE_OPENIN">
      </member>
      <member name="mmapin"
              value="4"
              c:identifier="VIPS_IMAGE_MMAPIN"
              glib:nick="mmapin"
              glib:name="VIPS_IMAGE_MMAPIN">
      </member>
      <member name="mmapinrw"
              value="5"
              c:identifier="VIPS_IMAGE_MMAPINRW"
              glib:nick="mmapinrw"
              glib:name="VIPS_IMAGE_MMAPINRW">
      </member>
      <member name="openout"
              value="6"
              c:identifier="VIPS_IMAGE_OPENOUT"
              glib:nick="openout"
              glib:name="VIPS_IMAGE_OPENOUT">
      </member>
      <member name="partial"
              value="7"
              c:identifier="VIPS_IMAGE_PARTIAL"
              glib:nick="partial"
              glib:name="VIPS_IMAGE_PARTIAL">
      </member>
    </enumeration>
    <enumeration name="Intent"
                 glib:type-name="VipsIntent"
                 glib:get-type="vips_intent_get_type"
                 c:type="VipsIntent">
      <doc xml:space="preserve"
           filename="libvips/colour/icc_transform.c"
           line="103">The rendering intent. [enum@Vips.Intent.ABSOLUTE] is best for
scientific work, [enum@Vips.Intent.RELATIVE] is usually best for
accurate communication with other imaging libraries.</doc>
      <member name="perceptual"
              value="0"
              c:identifier="VIPS_INTENT_PERCEPTUAL"
              glib:nick="perceptual"
              glib:name="VIPS_INTENT_PERCEPTUAL">
        <doc xml:space="preserve"
             filename="libvips/colour/icc_transform.c"
             line="105">perceptual rendering intent</doc>
      </member>
      <member name="relative"
              value="1"
              c:identifier="VIPS_INTENT_RELATIVE"
              glib:nick="relative"
              glib:name="VIPS_INTENT_RELATIVE">
        <doc xml:space="preserve"
             filename="libvips/colour/icc_transform.c"
             line="106">relative colorimetric rendering intent</doc>
      </member>
      <member name="saturation"
              value="2"
              c:identifier="VIPS_INTENT_SATURATION"
              glib:nick="saturation"
              glib:name="VIPS_INTENT_SATURATION">
        <doc xml:space="preserve"
             filename="libvips/colour/icc_transform.c"
             line="107">saturation rendering intent</doc>
      </member>
      <member name="absolute"
              value="3"
              c:identifier="VIPS_INTENT_ABSOLUTE"
              glib:nick="absolute"
              glib:name="VIPS_INTENT_ABSOLUTE">
        <doc xml:space="preserve"
             filename="libvips/colour/icc_transform.c"
             line="108">absolute colorimetric rendering intent</doc>
      </member>
      <member name="auto"
              value="32"
              c:identifier="VIPS_INTENT_AUTO"
              glib:nick="auto"
              glib:name="VIPS_INTENT_AUTO">
        <doc xml:space="preserve"
             filename="libvips/colour/icc_transform.c"
             line="109">the rendering intent that the profile suggests</doc>
      </member>
    </enumeration>
    <enumeration name="Interesting"
                 glib:type-name="VipsInteresting"
                 glib:get-type="vips_interesting_get_type"
                 c:type="VipsInteresting">
      <doc xml:space="preserve"
           filename="libvips/conversion/conversion.c"
           line="192">Pick the algorithm vips uses to decide image "interestingness". This is used
by [method@Image.smartcrop], for example, to decide what parts of the image to
keep.

[enum@Vips.Interesting.NONE] and [enum@Vips.Interesting.LOW] mean the same -- the
crop is positioned at the top or left. [enum@Vips.Interesting.HIGH] positions at
the bottom or right.

::: seealso
    [method@Image.smartcrop].</doc>
      <member name="none"
              value="0"
              c:identifier="VIPS_INTERESTING_NONE"
              glib:nick="none"
              glib:name="VIPS_INTERESTING_NONE">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="194">do nothing</doc>
      </member>
      <member name="centre"
              value="1"
              c:identifier="VIPS_INTERESTING_CENTRE"
              glib:nick="centre"
              glib:name="VIPS_INTERESTING_CENTRE">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="195">just take the centre</doc>
      </member>
      <member name="entropy"
              value="2"
              c:identifier="VIPS_INTERESTING_ENTROPY"
              glib:nick="entropy"
              glib:name="VIPS_INTERESTING_ENTROPY">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="196">use an entropy measure</doc>
      </member>
      <member name="attention"
              value="3"
              c:identifier="VIPS_INTERESTING_ATTENTION"
              glib:nick="attention"
              glib:name="VIPS_INTERESTING_ATTENTION">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="197">look for features likely to draw human attention</doc>
      </member>
      <member name="low"
              value="4"
              c:identifier="VIPS_INTERESTING_LOW"
              glib:nick="low"
              glib:name="VIPS_INTERESTING_LOW">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="198">position the crop towards the low coordinate</doc>
      </member>
      <member name="high"
              value="5"
              c:identifier="VIPS_INTERESTING_HIGH"
              glib:nick="high"
              glib:name="VIPS_INTERESTING_HIGH">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="199">position the crop towards the high coordinate</doc>
      </member>
      <member name="all"
              value="6"
              c:identifier="VIPS_INTERESTING_ALL"
              glib:nick="all"
              glib:name="VIPS_INTERESTING_ALL">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="200">everything is interesting</doc>
      </member>
    </enumeration>
    <class name="Interpolate"
           c:symbol-prefix="interpolate"
           c:type="VipsInterpolate"
           parent="Object"
           abstract="1"
           glib:type-name="VipsInterpolate"
           glib:get-type="vips_interpolate_get_type"
           glib:type-struct="InterpolateClass">
      <doc xml:space="preserve"
           filename="libvips/resample/interpolate.c"
           line="65">An abstract base class for the various interpolation functions.

Use `vips --list classes` to see all the interpolators available.

An interpolator consists of a function to perform the interpolation, plus
some extra data fields which tells libvips how to call the function and
what data it needs.</doc>
      <source-position filename="libvips/include/vips/interpolate.h"
                       line="92"/>
      <constructor name="new" c:identifier="vips_interpolate_new">
        <doc xml:space="preserve"
             filename="libvips/resample/interpolate.c"
             line="639">Look up an interpolator from a nickname and make one. You need to free the
result with [method@GObject.Object.unref] when you're done with it.

::: seealso
    [func@type_find].</doc>
        <source-position filename="libvips/include/vips/interpolate.h"
                         line="131"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/resample/interpolate.c"
               line="649">an interpolator, or `NULL` on error.</doc>
          <type name="Interpolate" c:type="VipsInterpolate*"/>
        </return-value>
        <parameters>
          <parameter name="nickname" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/interpolate.c"
                 line="641">nickname for interpolator</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="bilinear_static"
                c:identifier="vips_interpolate_bilinear_static">
        <doc xml:space="preserve"
             filename="libvips/resample/interpolate.c"
             line="599">A convenience function that returns a bilinear interpolator you
don't need to free.</doc>
        <source-position filename="libvips/include/vips/interpolate.h"
                         line="125"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/resample/interpolate.c"
               line="605">a bilinear interpolator</doc>
          <type name="Interpolate" c:type="VipsInterpolate*"/>
        </return-value>
      </function>
      <function name="nearest_static"
                c:identifier="vips_interpolate_nearest_static">
        <doc xml:space="preserve"
             filename="libvips/resample/interpolate.c"
             line="381">A convenience function that returns a nearest-neighbour interpolator you
don't need to free.</doc>
        <source-position filename="libvips/include/vips/interpolate.h"
                         line="123"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/resample/interpolate.c"
               line="387">a nearest-neighbour interpolator</doc>
          <type name="Interpolate" c:type="VipsInterpolate*"/>
        </return-value>
      </function>
      <virtual-method name="get_window_offset" invoker="get_window_offset">
        <doc xml:space="preserve"
             filename="libvips/resample/interpolate.c"
             line="263">Look up an interpolators desired window offset.</doc>
        <source-position filename="libvips/include/vips/interpolate.h"
                         line="90"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/resample/interpolate.c"
               line="269">the interpolators required window offset</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="interpolate" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/interpolate.c"
                 line="265">interpolator to use</doc>
            <type name="Interpolate" c:type="VipsInterpolate*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_window_size" invoker="get_window_size">
        <doc xml:space="preserve"
             filename="libvips/resample/interpolate.c"
             line="245">Look up an interpolators desired window size.</doc>
        <source-position filename="libvips/include/vips/interpolate.h"
                         line="81"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/resample/interpolate.c"
               line="251">the interpolators required window size</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="interpolate" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/interpolate.c"
                 line="247">interpolator to use</doc>
            <type name="Interpolate" c:type="VipsInterpolate*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="interpolate">
        <doc xml:space="preserve"
             filename="libvips/resample/interpolate.c"
             line="99">the interpolation method</doc>
        <source-position filename="libvips/include/vips/interpolate.h"
                         line="68"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="interpolate" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/interpolate.c"
                 line="81">the interpolator</doc>
            <type name="Interpolate" c:type="VipsInterpolate*"/>
          </instance-parameter>
          <parameter name="out"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/resample/interpolate.c"
                 line="82">write the interpolated pixel here</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/interpolate.c"
                 line="83">read source pixels from here</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/interpolate.c"
                 line="84">interpolate value at this position</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/interpolate.c"
                 line="85">interpolate value at this position</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name=""
              c:identifier="vips_interpolate"
              moved-to="interpolate"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/resample/interpolate.c"
             line="201">Look up the @interpolate method in the class and call it. Use
[method@Interpolate.get_method] to get a direct pointer to the function and
avoid the lookup overhead.

You need to set @in and @out up correctly.</doc>
        <source-position filename="libvips/include/vips/interpolate.h"
                         line="97"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="interpolate" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/interpolate.c"
                 line="203">interpolator to use</doc>
            <type name="Interpolate" c:type="VipsInterpolate*"/>
          </instance-parameter>
          <parameter name="out"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/resample/interpolate.c"
                 line="204">write result here</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/interpolate.c"
                 line="205">read source data from here</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/interpolate.c"
                 line="206">interpolate value at this position</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/interpolate.c"
                 line="207">interpolate value at this position</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_method"
              c:identifier="vips_interpolate_get_method"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/resample/interpolate.c"
             line="226">Look up the @interpolate method in the class and return it. Use this
instead of [func@interpolate] to cache method dispatch.</doc>
        <source-position filename="libvips/include/vips/interpolate.h"
                         line="100"/>
        <return-value>
          <doc xml:space="preserve"
               filename="libvips/resample/interpolate.c"
               line="233">a pointer to the interpolation function</doc>
          <type name="InterpolateMethod" c:type="VipsInterpolateMethod"/>
        </return-value>
        <parameters>
          <instance-parameter name="interpolate" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/interpolate.c"
                 line="228">interpolator to use</doc>
            <type name="Interpolate" c:type="VipsInterpolate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_window_offset"
              c:identifier="vips_interpolate_get_window_offset">
        <doc xml:space="preserve"
             filename="libvips/resample/interpolate.c"
             line="263">Look up an interpolators desired window offset.</doc>
        <source-position filename="libvips/include/vips/interpolate.h"
                         line="104"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/resample/interpolate.c"
               line="269">the interpolators required window offset</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="interpolate" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/interpolate.c"
                 line="265">interpolator to use</doc>
            <type name="Interpolate" c:type="VipsInterpolate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_window_size"
              c:identifier="vips_interpolate_get_window_size">
        <doc xml:space="preserve"
             filename="libvips/resample/interpolate.c"
             line="245">Look up an interpolators desired window size.</doc>
        <source-position filename="libvips/include/vips/interpolate.h"
                         line="102"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/resample/interpolate.c"
               line="251">the interpolators required window size</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="interpolate" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/interpolate.c"
                 line="247">interpolator to use</doc>
            <type name="Interpolate" c:type="VipsInterpolate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent_object">
        <type name="Object" c:type="VipsObject"/>
      </field>
    </class>
    <record name="InterpolateClass"
            c:type="VipsInterpolateClass"
            glib:is-gtype-struct-for="Interpolate">
      <doc xml:space="preserve"
           filename="libvips/resample/interpolate.c"
           line="97">@window_size is the size of the window that the interpolator needs. For
example, a bicubic interpolator needs to see a window of 4x4 pixels to be
able to interpolate a value.

You can either have a function in @get_window_size which returns the window
that a specific interpolator needs, or you can leave @get_window_size `NULL`
and set a constant value in @window_size.

@window_offset is how much to offset the window up and left of (x, y). For
example, a bicubic interpolator will want an @window_offset of 1.

You can either have a function in @get_window_offset which returns the
offset that a specific interpolator needs, or you can leave
@get_window_offset `NULL` and set a constant value in @window_offset.

You also need to set [property@Object:nickname] and
[property@Object:description] in [class@Object].

::: seealso
    [callback@InterpolateMethod], [class@Object] or
    [func@Interpolate.bilinear_static].</doc>
      <source-position filename="libvips/include/vips/interpolate.h"
                       line="92"/>
      <field name="parent_class">
        <type name="ObjectClass" c:type="VipsObjectClass"/>
      </field>
      <field name="interpolate">
        <doc xml:space="preserve"
             filename="libvips/resample/interpolate.c"
             line="99">the interpolation method</doc>
        <type name="InterpolateMethod" c:type="VipsInterpolateMethod"/>
      </field>
      <field name="get_window_size">
        <doc xml:space="preserve"
             filename="libvips/resample/interpolate.c"
             line="100">return the size of the window needed by this method</doc>
        <callback name="get_window_size">
          <source-position filename="libvips/include/vips/interpolate.h"
                           line="81"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/interpolate.c"
                 line="251">the interpolators required window size</doc>
            <type name="gint" c:type="int"/>
          </return-value>
          <parameters>
            <parameter name="interpolate" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="libvips/resample/interpolate.c"
                   line="247">interpolator to use</doc>
              <type name="Interpolate" c:type="VipsInterpolate*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="window_size">
        <doc xml:space="preserve"
             filename="libvips/resample/interpolate.c"
             line="101">or just set this for a constant window size</doc>
        <type name="gint" c:type="int"/>
      </field>
      <field name="get_window_offset">
        <doc xml:space="preserve"
             filename="libvips/resample/interpolate.c"
             line="102">return the window offset for this method</doc>
        <callback name="get_window_offset">
          <source-position filename="libvips/include/vips/interpolate.h"
                           line="90"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/resample/interpolate.c"
                 line="269">the interpolators required window offset</doc>
            <type name="gint" c:type="int"/>
          </return-value>
          <parameters>
            <parameter name="interpolate" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="libvips/resample/interpolate.c"
                   line="265">interpolator to use</doc>
              <type name="Interpolate" c:type="VipsInterpolate*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="window_offset">
        <doc xml:space="preserve"
             filename="libvips/resample/interpolate.c"
             line="103">or just set this for a constant window offset</doc>
        <type name="gint" c:type="int"/>
      </field>
    </record>
    <callback name="InterpolateMethod" c:type="VipsInterpolateMethod">
      <doc xml:space="preserve"
           filename="libvips/resample/interpolate.c"
           line="79">An interpolation function. It should read source pixels from @in with
[func@REGION_ADDR], it can look left and up from (x, y) by @window_offset
pixels and it can access pixels in a window of size @window_size.

The interpolated value should be written to the pixel pointed to by @out.

::: seealso
    [struct@InterpolateClass].</doc>
      <source-position filename="libvips/include/vips/interpolate.h"
                       line="68"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="interpolate" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/resample/interpolate.c"
               line="81">the interpolator</doc>
          <type name="Interpolate" c:type="VipsInterpolate*"/>
        </parameter>
        <parameter name="out"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/resample/interpolate.c"
               line="82">write the interpolated pixel here</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/resample/interpolate.c"
               line="83">read source pixels from here</doc>
          <type name="Region" c:type="VipsRegion*"/>
        </parameter>
        <parameter name="x" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/resample/interpolate.c"
               line="84">interpolate value at this position</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/resample/interpolate.c"
               line="85">interpolate value at this position</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="Interpretation"
                 glib:type-name="VipsInterpretation"
                 glib:get-type="vips_interpretation_get_type"
                 c:type="VipsInterpretation">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/image.c"
           line="201">How the values in an image should be interpreted. For example, a
three-band float image of type [enum@Vips.Interpretation.LAB] should have its
pixels interpreted as coordinates in CIE Lab space.

RGB and sRGB are treated in the same way. Use the colourspace functions if
you want some other behaviour.

The gaps in numbering are historical and must be maintained. Allocate
new numbers from the end.</doc>
      <member name="error"
              value="-1"
              c:identifier="VIPS_INTERPRETATION_ERROR"
              glib:nick="error"
              glib:name="VIPS_INTERPRETATION_ERROR">
      </member>
      <member name="multiband"
              value="0"
              c:identifier="VIPS_INTERPRETATION_MULTIBAND"
              glib:nick="multiband"
              glib:name="VIPS_INTERPRETATION_MULTIBAND">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="203">generic many-band image</doc>
      </member>
      <member name="b_w"
              value="1"
              c:identifier="VIPS_INTERPRETATION_B_W"
              glib:nick="b-w"
              glib:name="VIPS_INTERPRETATION_B_W">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="204">some kind of single-band image</doc>
      </member>
      <member name="histogram"
              value="10"
              c:identifier="VIPS_INTERPRETATION_HISTOGRAM"
              glib:nick="histogram"
              glib:name="VIPS_INTERPRETATION_HISTOGRAM">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="205">a 1D image, eg. histogram or lookup table</doc>
      </member>
      <member name="xyz"
              value="12"
              c:identifier="VIPS_INTERPRETATION_XYZ"
              glib:nick="xyz"
              glib:name="VIPS_INTERPRETATION_XYZ">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="207">the first three bands are CIE XYZ</doc>
      </member>
      <member name="lab"
              value="13"
              c:identifier="VIPS_INTERPRETATION_LAB"
              glib:nick="lab"
              glib:name="VIPS_INTERPRETATION_LAB">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="208">pixels are in CIE Lab space</doc>
      </member>
      <member name="cmyk"
              value="15"
              c:identifier="VIPS_INTERPRETATION_CMYK"
              glib:nick="cmyk"
              glib:name="VIPS_INTERPRETATION_CMYK">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="211">the first four bands are in CMYK space</doc>
      </member>
      <member name="labq"
              value="16"
              c:identifier="VIPS_INTERPRETATION_LABQ"
              glib:nick="labq"
              glib:name="VIPS_INTERPRETATION_LABQ">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="212">implies [enum@Vips.Coding.LABQ]</doc>
      </member>
      <member name="rgb"
              value="17"
              c:identifier="VIPS_INTERPRETATION_RGB"
              glib:nick="rgb"
              glib:name="VIPS_INTERPRETATION_RGB">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="213">generic RGB space</doc>
      </member>
      <member name="cmc"
              value="18"
              c:identifier="VIPS_INTERPRETATION_CMC"
              glib:nick="cmc"
              glib:name="VIPS_INTERPRETATION_CMC">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="214">a uniform colourspace based on CMC(1:1)</doc>
      </member>
      <member name="lch"
              value="19"
              c:identifier="VIPS_INTERPRETATION_LCH"
              glib:nick="lch"
              glib:name="VIPS_INTERPRETATION_LCH">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="215">pixels are in CIE LCh space</doc>
      </member>
      <member name="labs"
              value="21"
              c:identifier="VIPS_INTERPRETATION_LABS"
              glib:nick="labs"
              glib:name="VIPS_INTERPRETATION_LABS">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="216">CIE LAB coded as three signed 16-bit values</doc>
      </member>
      <member name="srgb"
              value="22"
              c:identifier="VIPS_INTERPRETATION_sRGB"
              glib:nick="srgb"
              glib:name="VIPS_INTERPRETATION_sRGB">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="217">pixels are sRGB</doc>
      </member>
      <member name="yxy"
              value="23"
              c:identifier="VIPS_INTERPRETATION_YXY"
              glib:nick="yxy"
              glib:name="VIPS_INTERPRETATION_YXY">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="220">pixels are CIE Yxy</doc>
      </member>
      <member name="fourier"
              value="24"
              c:identifier="VIPS_INTERPRETATION_FOURIER"
              glib:nick="fourier"
              glib:name="VIPS_INTERPRETATION_FOURIER">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="206">image is in fourier space</doc>
      </member>
      <member name="rgb16"
              value="25"
              c:identifier="VIPS_INTERPRETATION_RGB16"
              glib:nick="rgb16"
              glib:name="VIPS_INTERPRETATION_RGB16">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="221">generic 16-bit RGB</doc>
      </member>
      <member name="grey16"
              value="26"
              c:identifier="VIPS_INTERPRETATION_GREY16"
              glib:nick="grey16"
              glib:name="VIPS_INTERPRETATION_GREY16">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="222">generic 16-bit mono</doc>
      </member>
      <member name="matrix"
              value="27"
              c:identifier="VIPS_INTERPRETATION_MATRIX"
              glib:nick="matrix"
              glib:name="VIPS_INTERPRETATION_MATRIX">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="223">a matrix</doc>
      </member>
      <member name="scrgb"
              value="28"
              c:identifier="VIPS_INTERPRETATION_scRGB"
              glib:nick="scrgb"
              glib:name="VIPS_INTERPRETATION_scRGB">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="219">pixels are scRGB</doc>
      </member>
      <member name="hsv"
              value="29"
              c:identifier="VIPS_INTERPRETATION_HSV"
              glib:nick="hsv"
              glib:name="VIPS_INTERPRETATION_HSV">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="218">pixels are HSV</doc>
      </member>
      <member name="oklab"
              value="30"
              c:identifier="VIPS_INTERPRETATION_OKLAB"
              glib:nick="oklab"
              glib:name="VIPS_INTERPRETATION_OKLAB">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="209">pixels are in Oklab colourspace</doc>
      </member>
      <member name="oklch"
              value="31"
              c:identifier="VIPS_INTERPRETATION_OKLCH"
              glib:nick="oklch"
              glib:name="VIPS_INTERPRETATION_OKLCH">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="210">pixels are in Oklch colourspace</doc>
      </member>
      <function name="bands" c:identifier="vips_interpretation_bands">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="208">The number of "real" bands we expect for this interpretation. If we've no
idea (eg. MULTIBAND), return 0.</doc>
        <source-position filename="libvips/include/vips/header.h" line="203"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="215">the number of bands implied by this interpretation, or 0.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter name="interpretation" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="210">image to check</doc>
            <type name="Interpretation" c:type="VipsInterpretation"/>
          </parameter>
        </parameters>
      </function>
      <function name="max_alpha" c:identifier="vips_interpretation_max_alpha">
        <source-position filename="libvips/include/vips/header.h" line="201"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="192">the maximum alpha value for an interpretation.</doc>
          <type name="gdouble" c:type="double"/>
        </return-value>
        <parameters>
          <parameter name="interpretation" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/header.c"
                 line="190">image interpretation</doc>
            <type name="Interpretation" c:type="VipsInterpretation"/>
          </parameter>
        </parameters>
      </function>
    </enumeration>
    <enumeration name="Kernel"
                 glib:type-name="VipsKernel"
                 glib:get-type="vips_kernel_get_type"
                 c:type="VipsKernel">
      <doc xml:space="preserve"
           filename="libvips/resample/reduce.c"
           line="61">The resampling kernels vips supports. See [method@Image.reduce], for example.</doc>
      <member name="nearest"
              value="0"
              c:identifier="VIPS_KERNEL_NEAREST"
              glib:nick="nearest"
              glib:name="VIPS_KERNEL_NEAREST">
        <doc xml:space="preserve"
             filename="libvips/resample/reduce.c"
             line="63">the nearest pixel to the point</doc>
      </member>
      <member name="linear"
              value="1"
              c:identifier="VIPS_KERNEL_LINEAR"
              glib:nick="linear"
              glib:name="VIPS_KERNEL_LINEAR">
        <doc xml:space="preserve"
             filename="libvips/resample/reduce.c"
             line="64">convolve with a triangle filter</doc>
      </member>
      <member name="cubic"
              value="2"
              c:identifier="VIPS_KERNEL_CUBIC"
              glib:nick="cubic"
              glib:name="VIPS_KERNEL_CUBIC">
        <doc xml:space="preserve"
             filename="libvips/resample/reduce.c"
             line="65">convolve with a cubic filter</doc>
      </member>
      <member name="mitchell"
              value="3"
              c:identifier="VIPS_KERNEL_MITCHELL"
              glib:nick="mitchell"
              glib:name="VIPS_KERNEL_MITCHELL">
        <doc xml:space="preserve"
             filename="libvips/resample/reduce.c"
             line="66">convolve with a Mitchell kernel</doc>
      </member>
      <member name="lanczos2"
              value="4"
              c:identifier="VIPS_KERNEL_LANCZOS2"
              glib:nick="lanczos2"
              glib:name="VIPS_KERNEL_LANCZOS2">
        <doc xml:space="preserve"
             filename="libvips/resample/reduce.c"
             line="67">convolve with a two-lobe Lanczos kernel</doc>
      </member>
      <member name="lanczos3"
              value="5"
              c:identifier="VIPS_KERNEL_LANCZOS3"
              glib:nick="lanczos3"
              glib:name="VIPS_KERNEL_LANCZOS3">
        <doc xml:space="preserve"
             filename="libvips/resample/reduce.c"
             line="68">convolve with a three-lobe Lanczos kernel</doc>
      </member>
      <member name="mks2013"
              value="6"
              c:identifier="VIPS_KERNEL_MKS2013"
              glib:nick="mks2013"
              glib:name="VIPS_KERNEL_MKS2013">
        <doc xml:space="preserve"
             filename="libvips/resample/reduce.c"
             line="69">convolve with Magic Kernel Sharp 2013</doc>
      </member>
      <member name="mks2021"
              value="7"
              c:identifier="VIPS_KERNEL_MKS2021"
              glib:nick="mks2021"
              glib:name="VIPS_KERNEL_MKS2021">
        <doc xml:space="preserve"
             filename="libvips/resample/reduce.c"
             line="70">convolve with Magic Kernel Sharp 2021</doc>
      </member>
    </enumeration>
    <constant name="LIBRARY_AGE" value="20" c:type="VIPS_LIBRARY_AGE">
      <source-position filename="libvips/include/vips/version.h" line="17"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="LIBRARY_CURRENT" value="62" c:type="VIPS_LIBRARY_CURRENT">
      <source-position filename="libvips/include/vips/version.h" line="15"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="LIBRARY_REVISION" value="0" c:type="VIPS_LIBRARY_REVISION">
      <source-position filename="libvips/include/vips/version.h" line="16"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MAGIC_INTEL" value="3064394248" c:type="VIPS_MAGIC_INTEL">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/image.c"
           line="136">The first four bytes of a VIPS file in Intel byte ordering.</doc>
      <source-position filename="libvips/include/vips/image.h" line="54"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MAGIC_SPARC" value="150120118" c:type="VIPS_MAGIC_SPARC">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/image.c"
           line="142">The first four bytes of a VIPS file in SPARC byte ordering.</doc>
      <source-position filename="libvips/include/vips/image.h" line="55"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MAJOR_VERSION" value="8" c:type="VIPS_MAJOR_VERSION">
      <source-position filename="libvips/include/vips/version.h" line="9"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="MALLOC"
                    c:identifier="VIPS_MALLOC"
                    introspectable="0">
      <source-position filename="libvips/include/vips/memory.h" line="67"/>
      <parameters>
        <parameter name="OBJ">
        </parameter>
        <parameter name="S">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="MATRIX"
                    c:identifier="VIPS_MATRIX"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/image.c"
           line="338">This macro returns a pointer to a pixel in an image, cast to a double*. The
image must have a single band, be [enum@Vips.BandFormat.DOUBLE] and be
fully available in memory, so memory buffers and small
mapped images only.

If `VIPS_DEBUG` is defined, you get a version that checks bounds and image
type for you.

::: seealso
    [method@Image.wio_input], [method@Image.inplace], [func@check_matrix].</doc>
      <source-position filename="libvips/include/vips/image.h" line="425"/>
      <parameters>
        <parameter name="I">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="340">a [class@Image]</doc>
        </parameter>
        <parameter name="X">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="341">x coordinate</doc>
        </parameter>
        <parameter name="Y">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="342">y coordinate</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="MAX" c:identifier="VIPS_MAX" introspectable="0">
      <source-position filename="libvips/include/vips/util.h" line="53"/>
      <parameters>
        <parameter name="A">
        </parameter>
        <parameter name="B">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="META_BITS_PER_SAMPLE"
              value="bits-per-sample"
              c:type="VIPS_META_BITS_PER_SAMPLE">
      <doc xml:space="preserve"
           filename="libvips/include/vips/header.h"
           line="95">The bits per sample for each channel.</doc>
      <source-position filename="libvips/include/vips/header.h" line="100"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="META_CONCURRENCY"
              value="concurrency"
              c:type="VIPS_META_CONCURRENCY">
      <doc xml:space="preserve"
           filename="libvips/include/vips/header.h"
           line="174">If set, the suggested concurrency for this image.</doc>
      <source-position filename="libvips/include/vips/header.h" line="179"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="META_EXIF_NAME"
              value="exif-data"
              c:type="VIPS_META_EXIF_NAME">
      <doc xml:space="preserve"
           filename="libvips/include/vips/header.h"
           line="41">The name that read and write operations use for the image's EXIF data.</doc>
      <source-position filename="libvips/include/vips/header.h" line="46"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="META_ICC_NAME"
              value="icc-profile-data"
              c:type="VIPS_META_ICC_NAME">
      <doc xml:space="preserve"
           filename="libvips/include/vips/header.h"
           line="70">The name we use to attach an ICC profile. The file read and write
operations for TIFF, JPEG, PNG and others use this item of metadata to
attach and save ICC profiles. The profile is updated by the
[method@Image.icc_transform] operations.</doc>
      <source-position filename="libvips/include/vips/header.h" line="78"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="META_IMAGEDESCRIPTION"
              value="image-description"
              c:type="VIPS_META_IMAGEDESCRIPTION">
      <doc xml:space="preserve"
           filename="libvips/include/vips/header.h"
           line="80">The IMAGEDESCRIPTION tag. Often has useful metadata.</doc>
      <source-position filename="libvips/include/vips/header.h" line="85"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="META_IPTC_NAME"
              value="iptc-data"
              c:type="VIPS_META_IPTC_NAME">
      <doc xml:space="preserve"
           filename="libvips/include/vips/header.h"
           line="55">The name that read and write operations use for the image's IPTC data.</doc>
      <source-position filename="libvips/include/vips/header.h" line="60"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="META_LOADER" value="vips-loader" c:type="VIPS_META_LOADER">
      <doc xml:space="preserve"
           filename="libvips/include/vips/header.h"
           line="109">Record the name of the original loader here. Handy for hinting file formats
and for debugging.</doc>
      <source-position filename="libvips/include/vips/header.h" line="115"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="META_N_PAGES" value="n-pages" c:type="VIPS_META_N_PAGES">
      <doc xml:space="preserve"
           filename="libvips/include/vips/header.h"
           line="160">If set, the number of pages in the original file.</doc>
      <source-position filename="libvips/include/vips/header.h" line="165"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="META_N_SUBIFDS"
              value="n-subifds"
              c:type="VIPS_META_N_SUBIFDS">
      <doc xml:space="preserve"
           filename="libvips/include/vips/header.h"
           line="167">If set, the number of subifds in the first page of the file.</doc>
      <source-position filename="libvips/include/vips/header.h" line="172"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="META_ORIENTATION"
              value="orientation"
              c:type="VIPS_META_ORIENTATION">
      <doc xml:space="preserve"
           filename="libvips/include/vips/header.h"
           line="126">The orientation tag for this image. An int from 1 - 8 using the standard
exif/tiff meanings.

- 1 - The 0th row represents the visual top of the image, and the 0th column
  represents the visual left-hand side.
- 2 - The 0th row represents the visual top of the image, and the 0th column
  represents the visual right-hand side.
- 3 - The 0th row represents the visual bottom of the image, and the 0th
  column represents the visual right-hand side.
- 4 - The 0th row represents the visual bottom of the image, and the 0th
  column represents the visual left-hand side.
- 5 - The 0th row represents the visual left-hand side of the image, and the
  0th column represents the visual top.
- 6 - The 0th row represents the visual right-hand side of the image, and the
  0th column represents the visual top.
- 7 - The 0th row represents the visual right-hand side of the image, and the
  0th column represents the visual bottom.
- 8 - The 0th row represents the visual left-hand side of the image, and the
  0th column represents the visual bottom.</doc>
      <source-position filename="libvips/include/vips/header.h" line="149"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="META_PAGE_HEIGHT"
              value="page-height"
              c:type="VIPS_META_PAGE_HEIGHT">
      <doc xml:space="preserve"
           filename="libvips/include/vips/header.h"
           line="151">If set, the height of each page when this image was loaded. If you save an
image with "page-height" set to a format that supports multiple pages, such
as tiff, the image will be saved as a series of pages.</doc>
      <source-position filename="libvips/include/vips/header.h" line="158"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="META_PALETTE" value="palette" c:type="VIPS_META_PALETTE">
      <doc xml:space="preserve"
           filename="libvips/include/vips/header.h"
           line="102">Does this image have a palette?</doc>
      <source-position filename="libvips/include/vips/header.h" line="107"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="META_PHOTOSHOP_NAME"
              value="photoshop-data"
              c:type="VIPS_META_PHOTOSHOP_NAME">
      <doc xml:space="preserve"
           filename="libvips/include/vips/header.h"
           line="62">The name that TIFF read and write operations use for the image's
TIFFTAG_PHOTOSHOP data.</doc>
      <source-position filename="libvips/include/vips/header.h" line="68"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="META_RESOLUTION_UNIT"
              value="resolution-unit"
              c:type="VIPS_META_RESOLUTION_UNIT">
      <doc xml:space="preserve"
           filename="libvips/include/vips/header.h"
           line="87">The JPEG and TIFF read and write operations use this to record the
file's preferred unit for resolution.</doc>
      <source-position filename="libvips/include/vips/header.h" line="93"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="META_SEQUENTIAL"
              value="vips-sequential"
              c:type="VIPS_META_SEQUENTIAL">
      <doc xml:space="preserve"
           filename="libvips/include/vips/header.h"
           line="117">Images loaded via [method@Image.sequential] have this int field defined. Some
operations (eg. [method@Image.shrinkv]) add extra caches if they see it on their
input.</doc>
      <source-position filename="libvips/include/vips/header.h" line="124"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="META_TILE_HEIGHT"
              value="tile-height"
              c:type="VIPS_META_TILE_HEIGHT">
      <doc xml:space="preserve"
           filename="libvips/include/vips/header.h"
           line="188">If set, the height of the tiles for this image.</doc>
      <source-position filename="libvips/include/vips/header.h" line="193"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="META_TILE_WIDTH"
              value="tile-width"
              c:type="VIPS_META_TILE_WIDTH">
      <doc xml:space="preserve"
           filename="libvips/include/vips/header.h"
           line="181">If set, the width of the tiles for this image.</doc>
      <source-position filename="libvips/include/vips/header.h" line="186"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="META_XMP_NAME"
              value="xmp-data"
              c:type="VIPS_META_XMP_NAME">
      <doc xml:space="preserve"
           filename="libvips/include/vips/header.h"
           line="48">The name that read and write operations use for the image's XMP data.</doc>
      <source-position filename="libvips/include/vips/header.h" line="53"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="MICRO_VERSION" value="0" c:type="VIPS_MICRO_VERSION">
      <source-position filename="libvips/include/vips/version.h" line="11"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="MIN" c:identifier="VIPS_MIN" introspectable="0">
      <source-position filename="libvips/include/vips/util.h" line="54"/>
      <parameters>
        <parameter name="A">
        </parameter>
        <parameter name="B">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="MINOR_VERSION" value="18" c:type="VIPS_MINOR_VERSION">
      <source-position filename="libvips/include/vips/version.h" line="10"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="NEW" c:identifier="VIPS_NEW" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/memory.c"
           line="97">Allocate memory for a thing of type @T. The memory is not
cleared.

This macro cannot fail. See [func@tracked_malloc] if you are
allocating large amounts of memory.

::: seealso
    [func@malloc].</doc>
      <source-position filename="libvips/include/vips/memory.h" line="69"/>
      <parameters>
        <parameter name="OBJ">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/memory.c"
               line="99">allocate memory local to @OBJ, or `NULL` for no auto-free</doc>
        </parameter>
        <parameter name="T">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/memory.c"
               line="100">type of thing to allocate</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="NUMBER"
                    c:identifier="VIPS_NUMBER"
                    introspectable="0">
      <source-position filename="libvips/include/vips/util.h" line="62"/>
      <parameters>
        <parameter name="R">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="OBJECT"
                    c:identifier="VIPS_OBJECT"
                    introspectable="0">
      <source-position filename="libvips/include/vips/object.h" line="417"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="OBJECT_CLASS"
                    c:identifier="VIPS_OBJECT_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/object.h" line="419"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="OBJECT_GET_CLASS"
                    c:identifier="VIPS_OBJECT_GET_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/object.h" line="425"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ONCE" c:identifier="VIPS_ONCE" introspectable="0">
      <source-position filename="libvips/include/vips/util.h" line="78"/>
      <parameters>
        <parameter name="ONCE">
        </parameter>
        <parameter name="FUNC">
        </parameter>
        <parameter name="CLIENT">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="OPERATION"
                    c:identifier="VIPS_OPERATION"
                    introspectable="0">
      <source-position filename="libvips/include/vips/operation.h" line="57"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="OPERATION_CLASS"
                    c:identifier="VIPS_OPERATION_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/operation.h" line="60"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="OPERATION_GET_CLASS"
                    c:identifier="VIPS_OPERATION_GET_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/operation.h" line="67"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <class name="Object"
           c:symbol-prefix="object"
           c:type="VipsObject"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="VipsObject"
           glib:get-type="vips_object_get_type"
           glib:type-struct="ObjectClass">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/object.c"
           line="63">An abstract base class for all objects in libvips.

It has the following major features:

- **Functional class creation**: libvips objects have a very regular
  lifecycle: initialise, build, use, destroy. They behave rather like
  function calls and are free of side-effects.

- **Run-time introspection**: libvips objects can be fully introspected
  at run-time. There is no need for separate source-code analysis.

- **Command-line interface**: Any vips object can be run from the
  command-line with the `vips` driver program.

## The [class@Object] lifecycle

[class@Object]'s have a strictly defined lifecycle, split broadly as
construct and then use. In detail, the stages are:

1. [ctor@GObject.Object.new]. The [class@Object] is created with
  [ctor@GObject.Object.new]. Objects in this state are blank slates and
  need to have their various parameters set.

2. [method@GObject.Object.set]. You loop over the [struct@Argument] that
  the object has defined with [func@Argument.map]. Arguments have a set of
  flags attached to them for required, optional, input, output, type, and
  so on. You must set all required arguments.

3. [method@Object.build]. Call this to construct the object and get it
  ready for use. Building an object happens in four stages, see below.

4. [method@GObject.Object.get]. The object has now been built. You can
  read out any computed values.

5. [method@GObject.Object.unref]. When you are done with an object, you
  can unref it. See the section on reference counting for an explanation
  of the convention that [class@Object] uses. When the last ref to an
  object is released, the object is closed. Objects close in three stages,
  see below.

The stages inside [method@Object.build] are:

1. Chain up through the object's `build` class methods. At each stage,
  each class does any initial setup and checking, then chains up to its
  superclass.

2. The innermost `build` method inside [class@Object] itself checks that
  all input arguments have been set and then returns.

3. All object `build` methods now finish executing, from innermost to
  outermost. They know all input arguments have been checked and supplied,
  so now they set all output arguments.

4. [method@Object.build] finishes the process by checking that all output
  objects have been set, and then triggering the [signal@Object::postbuild]
  signal. [signal@Object::postbuild] only runs if the object has constructed
  successfully.

[class@Operation] has a cache of recent operation objects, see that class for
an explanation of [func@cache_operation_build].

Finally, the stages inside close are:

1. [signal@Object::preclose]. This is emitted at the start of the
  [class@Object] dispose. The object is still functioning.

2. [signal@Object::close]. This runs just after all [struct@Argument] held
  by the object have been released.

3. [signal@Object::postclose]. This runs right at the end. The object
  pointer is still valid, but nothing else is.

## The [class@Object] reference counting convention

[class@Object] has a set of conventions to simplify reference counting.

1. All input [class@GObject.Object] have a ref added to them, owned by the
  object. When a [class@Object] is unreffed, all of these refs to input
  objects are automatically dropped.

2. All output [class@GObject.Object] hold a ref to the object. When a
  [class@GObject.Object] which is an output of a [class@Object] is
  disposed, it must drop this reference. [class@Object] which are outputs
  of other [class@Object]'s will do this automatically.

See [class@Operation] for an example of [class@Object] reference counting.</doc>
      <source-position filename="libvips/include/vips/object.h" line="592"/>
      <constructor name="new"
                   c:identifier="vips_object_new"
                   introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="2342">[ctor@GObject.Object.new] the object, set any arguments with @set, call
[method@Object.build] and return the complete object.</doc>
        <source-position filename="libvips/include/vips/object.h" line="648"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/object.c"
               line="2352">the new object</doc>
          <type name="Object" c:type="VipsObject*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="2344">object to create</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="set" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="2345">set arguments with this</doc>
            <type name="ObjectSetArguments" c:type="VipsObjectSetArguments"/>
          </parameter>
          <parameter name="a"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="2346">client data</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="b"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="2347">client data</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_string"
                   c:identifier="vips_object_new_from_string">
        <source-position filename="libvips/include/vips/object.h" line="660"/>
        <return-value transfer-ownership="full">
          <type name="Object" c:type="VipsObject*"/>
        </return-value>
        <parameters>
          <parameter name="object_class" transfer-ownership="none">
            <type name="ObjectClass" c:type="VipsObjectClass*"/>
          </parameter>
          <parameter name="p" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="get_property" c:identifier="vips_object_get_property">
        <source-position filename="libvips/include/vips/object.h" line="600"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="gobject" transfer-ownership="none">
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="property_id" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
          <parameter name="pspec" transfer-ownership="none">
            <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
          </parameter>
        </parameters>
      </function>
      <function name="map" c:identifier="vips_object_map" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="2715">Call a function for all alive objects.
Stop when @fn returns non-`NULL` and return that value.</doc>
        <source-position filename="libvips/include/vips/object.h" line="666"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/object.c"
               line="2724">`NULL` if @fn returns `NULL` for all arguments, otherwise the first
non-`NULL` value from @fn.</doc>
          <type name="gpointer" c:type="void*"/>
        </return-value>
        <parameters>
          <parameter name="fn" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="2717">function to call for all objects</doc>
            <type name="SListMap2Fn" c:type="VipsSListMap2Fn"/>
          </parameter>
          <parameter name="a"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="2718">client data</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="b"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="2719">client data</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </function>
      <function name="print_all" c:identifier="vips_object_print_all">
        <source-position filename="libvips/include/vips/object.h" line="699"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <function name="print_summary_class"
                c:identifier="vips_object_print_summary_class">
        <source-position filename="libvips/include/vips/object.h" line="616"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="klass" transfer-ownership="none">
            <type name="ObjectClass" c:type="VipsObjectClass*"/>
          </parameter>
        </parameters>
      </function>
      <function name="sanity_all" c:identifier="vips_object_sanity_all">
        <source-position filename="libvips/include/vips/object.h" line="701"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <function name="set_property" c:identifier="vips_object_set_property">
        <source-position filename="libvips/include/vips/object.h" line="597"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="gobject" transfer-ownership="none">
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="property_id" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
          <parameter name="pspec" transfer-ownership="none">
            <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
          </parameter>
        </parameters>
      </function>
      <function name="summary_class"
                c:identifier="vips_object_summary_class"
                introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="394">Generate a human-readable summary for a class.</doc>
        <source-position filename="libvips/include/vips/object.h" line="609"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="klass" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="396">class to summarise</doc>
            <type name="ObjectClass" c:type="VipsObjectClass*"/>
          </parameter>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="397">write summary here</doc>
            <type name="Buf" c:type="VipsBuf*"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="build" invoker="build">
        <source-position filename="libvips/include/vips/object.h" line="482"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="close">
        <source-position filename="libvips/include/vips/object.h" line="519"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="dump" invoker="dump" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="422">Dump everything that vips knows about an object to a string.</doc>
        <source-position filename="libvips/include/vips/object.h" line="501"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="424">object to dump</doc>
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="425">write dump here</doc>
            <type name="Buf" c:type="VipsBuf*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="output_to_arg">
        <source-position filename="libvips/include/vips/object.h" line="551"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="string" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="postbuild">
        <source-position filename="libvips/include/vips/object.h" line="486"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="postclose">
        <source-position filename="libvips/include/vips/object.h" line="524"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="preclose" invoker="preclose">
        <source-position filename="libvips/include/vips/object.h" line="515"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="rewind" invoker="rewind">
        <source-position filename="libvips/include/vips/object.h" line="511"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="sanity">
        <source-position filename="libvips/include/vips/object.h" line="506"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="buf" transfer-ownership="none">
            <type name="Buf" c:type="VipsBuf*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="summary" invoker="summary" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="407">Generate a human-readable summary for an object.</doc>
        <source-position filename="libvips/include/vips/object.h" line="497"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="409">object to summarise</doc>
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="410">write summary here</doc>
            <type name="Buf" c:type="VipsBuf*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="to_string" invoker="to_string">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="2670">The inverse of [ctor@Object.new_from_string]: turn @object into eg.
`"VipsInterpolateSnohalo1(blur=.333333)"`.</doc>
        <source-position filename="libvips/include/vips/object.h" line="540"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="2672">object to stringify</doc>
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="2673">write string here</doc>
            <type name="Buf" c:type="VipsBuf*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="argument_isset" c:identifier="vips_object_argument_isset">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="796">Convenience: has an argument been assigned. Useful for bindings.</doc>
        <source-position filename="libvips/include/vips/object.h" line="344"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/object.c"
               line="803">`TRUE` if the argument has been assigned.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="798">the object to fetch the args from</doc>
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="799">arg to fetch</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="argument_needsstring"
              c:identifier="vips_object_argument_needsstring">
        <source-position filename="libvips/include/vips/object.h" line="638"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="build" c:identifier="vips_object_build">
        <source-position filename="libvips/include/vips/object.h" line="606"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dump" c:identifier="vips_object_dump" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="422">Dump everything that vips knows about an object to a string.</doc>
        <source-position filename="libvips/include/vips/object.h" line="613"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="424">object to dump</doc>
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="425">write dump here</doc>
            <type name="Buf" c:type="VipsBuf*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_args"
              c:identifier="vips_object_get_args"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="2298">Get all [class@GObject.ParamSpec] names and [flags@ArgumentFlags] for an object.

This is handy for language bindings. From C, it's usually more convenient to
use [func@Argument.map].</doc>
        <source-position filename="libvips/include/vips/object.h" line="328"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/object.c"
               line="2310">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="2300">object whose args should be retrieved</doc>
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="names"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="2301">output array of [class@GObject.ParamSpec] names</doc>
            <array length="2" zero-terminated="0" c:type="const char***">
              <type name="utf8" c:type="char**"/>
            </array>
          </parameter>
          <parameter name="flags"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="2302">output array of [flags@ArgumentFlags]</doc>
            <array length="2" zero-terminated="0" c:type="int**">
              <type name="gint" c:type="int*"/>
            </array>
          </parameter>
          <parameter name="n_args"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="2303">length of output arrays</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_argument"
              c:identifier="vips_object_get_argument"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="756">Look up the three things you need to work with a vips argument.</doc>
        <source-position filename="libvips/include/vips/object.h" line="339"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/object.c"
               line="766">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="758">the object to fetch the args from</doc>
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="759">arg to fetch</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="pspec" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="760">the pspec for this arg</doc>
            <type name="GObject.ParamSpec" c:type="GParamSpec**"/>
          </parameter>
          <parameter name="argument_class" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="761">the argument_class for this arg</doc>
            <type name="ArgumentClass" c:type="VipsArgumentClass**"/>
          </parameter>
          <parameter name="argument_instance" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="762">the argument_instance for this arg</doc>
            <type name="ArgumentInstance" c:type="VipsArgumentInstance**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_argument_flags"
              c:identifier="vips_object_get_argument_flags">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="819">Convenience: get the flags for an argument. Useful for bindings.</doc>
        <source-position filename="libvips/include/vips/object.h" line="346"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/object.c"
               line="826">The [flags@ArgumentFlags] for this argument.</doc>
          <type name="ArgumentFlags" c:type="VipsArgumentFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="821">the object to fetch the args from</doc>
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="822">arg to fetch</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_argument_priority"
              c:identifier="vips_object_get_argument_priority">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="842">Convenience: get the priority for an argument. Useful for bindings.</doc>
        <source-position filename="libvips/include/vips/object.h" line="349"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/object.c"
               line="849">The priority of this argument.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="844">the object to fetch the args from</doc>
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="845">arg to fetch</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_argument_to_string"
              c:identifier="vips_object_get_argument_to_string">
        <source-position filename="libvips/include/vips/object.h" line="641"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="arg" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_description"
              c:identifier="vips_object_get_description"
              glib:get-property="description">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="3236">Fetch the object description. Useful for language bindings.

[property@Object:description] is only available after `_build()`, which can be too
late. This function fetches from the instance, if possible, but falls back
to the class description if we are too early.</doc>
        <source-position filename="libvips/include/vips/object.h" line="710"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/object.c"
               line="3246">the object description</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="3238">object to fetch description from</doc>
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="local_array"
              c:identifier="vips_object_local_array"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="3050">Make an array of `NULL` [class@Object] pointers. When @parent closes, every
non-`NULL` pointer in the array will be unreffed and the array will be
freed. Handy for creating a set of temporary images for a function.

The array is `NULL`-terminated, ie. contains an extra `NULL` element at the
end.

Example:

```c
VipsObject **t;

t = vips_object_local_array(parent, 5);
if (vips_add(a, b, &amp;t[0], NULL) ||
    vips_invert(t[0], &amp;t[1], NULL) ||
    vips_add(t[1], t[0], &amp;t[2], NULL) ||
    vips_costra(t[2], out, NULL))
    return -1;
```</doc>
        <source-position filename="libvips/include/vips/object.h" line="689"/>
        <return-value>
          <doc xml:space="preserve"
               filename="libvips/iofuncs/object.c"
               line="3075">an array of `NULL` pointers of length @n</doc>
          <type name="Object" c:type="VipsObject**"/>
        </return-value>
        <parameters>
          <instance-parameter name="parent" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="3052">objects unref when this object unrefs</doc>
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="3053">array size</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="local_cb" c:identifier="vips_object_local_cb">
        <source-position filename="libvips/include/vips/object.h" line="692"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="vobject" transfer-ownership="none">
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="gobject" transfer-ownership="none">
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="preclose" c:identifier="vips_object_preclose">
        <source-position filename="libvips/include/vips/object.h" line="604"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="print_dump" c:identifier="vips_object_print_dump">
        <source-position filename="libvips/include/vips/object.h" line="620"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="print_name" c:identifier="vips_object_print_name">
        <source-position filename="libvips/include/vips/object.h" line="622"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="print_summary" c:identifier="vips_object_print_summary">
        <source-position filename="libvips/include/vips/object.h" line="618"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="rewind" c:identifier="vips_object_rewind">
        <source-position filename="libvips/include/vips/object.h" line="704"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="sanity" c:identifier="vips_object_sanity">
        <source-position filename="libvips/include/vips/object.h" line="625"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set" c:identifier="vips_object_set" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="2415">Set a list of vips object arguments. For example:

```c
vips_object_set(operation,
    "input", in,
    "output", &amp;out,
    NULL);
```

Input arguments are given in-line, output arguments are given as pointers
to where the output value should be written.

::: seealso
    [method@Object.set_valist], [method@Object.set_from_string].</doc>
        <source-position filename="libvips/include/vips/object.h" line="654"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/object.c"
               line="2435">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="2417">object to set arguments on</doc>
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="2418">`NULL`-terminated list of argument/value pairs</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="set_argument_from_string"
              c:identifier="vips_object_set_argument_from_string">
        <source-position filename="libvips/include/vips/object.h" line="635"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_from_string"
              c:identifier="vips_object_set_from_string">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="2547">Set object arguments from a string. The string can be something like
"a=12", or "a = 12, b = 13", or "fred". The string can optionally be
enclosed in brackets.

You'd typically use this between creating the object and building it.

::: seealso
    [method@Object.set], [method@Object.build],
    [func@cache_operation_buildp].</doc>
        <source-position filename="libvips/include/vips/object.h" line="657"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/object.c"
               line="2562">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="2549">object to set arguments on</doc>
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="2550">arguments as a string</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_required" c:identifier="vips_object_set_required">
        <source-position filename="libvips/include/vips/object.h" line="644"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_static" c:identifier="vips_object_set_static">
        <source-position filename="libvips/include/vips/object.h" line="697"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="static_object" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_valist"
              c:identifier="vips_object_set_valist"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="2376">See [method@Object.set].</doc>
        <source-position filename="libvips/include/vips/object.h" line="652"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/object.c"
               line="2383">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="2378">object to set arguments on</doc>
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="ap" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="2379">`NULL`-terminated list of argument/value pairs</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="summary"
              c:identifier="vips_object_summary"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="407">Generate a human-readable summary for an object.</doc>
        <source-position filename="libvips/include/vips/object.h" line="611"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="409">object to summarise</doc>
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="410">write summary here</doc>
            <type name="Buf" c:type="VipsBuf*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_string" c:identifier="vips_object_to_string">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="2670">The inverse of [ctor@Object.new_from_string]: turn @object into eg.
`"VipsInterpolateSnohalo1(blur=.333333)"`.</doc>
        <source-position filename="libvips/include/vips/object.h" line="663"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="2672">object to stringify</doc>
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="2673">write string here</doc>
            <type name="Buf" c:type="VipsBuf*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref_outputs" c:identifier="vips_object_unref_outputs">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="3215">Unref all assigned output objects. Useful for language bindings.

After an object is built, all output args are owned by the caller. If
something goes wrong before then, we have to unref the outputs that have
been made so far. This function can also be useful for callers when
they've finished processing outputs themselves.

::: seealso
    [func@cache_operation_build].</doc>
        <source-position filename="libvips/include/vips/object.h" line="707"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/object.c"
                 line="3217">object to drop output refs from</doc>
            <type name="Object" c:type="VipsObject*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="description"
                writable="1"
                transfer-ownership="none"
                getter="get_description">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="nickname" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="constructed">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="static_object">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="argument_table">
        <type name="ArgumentTable" c:type="VipsArgumentTable*"/>
      </field>
      <field name="nickname">
        <type name="utf8" c:type="char*"/>
      </field>
      <field name="description">
        <type name="utf8" c:type="char*"/>
      </field>
      <field name="preclose">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="close">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="postclose">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="local_memory">
        <type name="gsize" c:type="size_t"/>
      </field>
      <glib:signal name="close" when="last">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="1637">The ::close signal is emitted once during object close. The object
is dying and may not work.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="postbuild" when="last">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="1607">The ::postbuild signal is emitted once just after successful object
construction. Return non-zero to cause object construction to fail.</doc>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
      </glib:signal>
      <glib:signal name="postclose" when="last">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="1652">The ::postclose signal is emitted once after object close. The
object pointer is still valid, but nothing else.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="preclose" when="last">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="1622">The ::preclose signal is emitted once just before object close
starts. The object is still alive.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="ObjectClass"
            c:type="VipsObjectClass"
            glib:is-gtype-struct-for="Object">
      <source-position filename="libvips/include/vips/object.h" line="592"/>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="build">
        <callback name="build">
          <source-position filename="libvips/include/vips/object.h"
                           line="482"/>
          <return-value transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="VipsObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="postbuild">
        <callback name="postbuild">
          <source-position filename="libvips/include/vips/object.h"
                           line="486"/>
          <return-value transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="VipsObject*"/>
            </parameter>
            <parameter name="data"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <type name="gpointer" c:type="void*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="summary_class">
        <callback name="summary_class">
          <source-position filename="libvips/include/vips/object.h"
                           line="491"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="cls" transfer-ownership="none">
              <type name="gpointer" c:type="_VipsObjectClass*"/>
            </parameter>
            <parameter name="buf" transfer-ownership="none">
              <type name="Buf" c:type="VipsBuf*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="summary">
        <callback name="summary">
          <source-position filename="libvips/include/vips/object.h"
                           line="497"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="libvips/iofuncs/object.c"
                   line="409">object to summarise</doc>
              <type name="Object" c:type="VipsObject*"/>
            </parameter>
            <parameter name="buf" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="libvips/iofuncs/object.c"
                   line="410">write summary here</doc>
              <type name="Buf" c:type="VipsBuf*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="dump">
        <callback name="dump">
          <source-position filename="libvips/include/vips/object.h"
                           line="501"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="libvips/iofuncs/object.c"
                   line="424">object to dump</doc>
              <type name="Object" c:type="VipsObject*"/>
            </parameter>
            <parameter name="buf" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="libvips/iofuncs/object.c"
                   line="425">write dump here</doc>
              <type name="Buf" c:type="VipsBuf*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="sanity">
        <callback name="sanity">
          <source-position filename="libvips/include/vips/object.h"
                           line="506"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="VipsObject*"/>
            </parameter>
            <parameter name="buf" transfer-ownership="none">
              <type name="Buf" c:type="VipsBuf*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="rewind">
        <callback name="rewind">
          <source-position filename="libvips/include/vips/object.h"
                           line="511"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="VipsObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="preclose">
        <callback name="preclose">
          <source-position filename="libvips/include/vips/object.h"
                           line="515"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="VipsObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close">
        <callback name="close">
          <source-position filename="libvips/include/vips/object.h"
                           line="519"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="VipsObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="postclose">
        <callback name="postclose">
          <source-position filename="libvips/include/vips/object.h"
                           line="524"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="VipsObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="new_from_string" introspectable="0">
        <callback name="new_from_string" introspectable="0">
          <source-position filename="libvips/include/vips/object.h"
                           line="535"/>
          <return-value>
            <type name="Object" c:type="VipsObject*"/>
          </return-value>
          <parameters>
            <parameter name="string" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="to_string">
        <callback name="to_string">
          <source-position filename="libvips/include/vips/object.h"
                           line="540"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="libvips/iofuncs/object.c"
                   line="2672">object to stringify</doc>
              <type name="Object" c:type="VipsObject*"/>
            </parameter>
            <parameter name="buf" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="libvips/iofuncs/object.c"
                   line="2673">write string here</doc>
              <type name="Buf" c:type="VipsBuf*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="output_needs_arg">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="output_to_arg">
        <callback name="output_to_arg">
          <source-position filename="libvips/include/vips/object.h"
                           line="551"/>
          <return-value transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="VipsObject*"/>
            </parameter>
            <parameter name="string" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="nickname">
        <type name="utf8" c:type="const char*"/>
      </field>
      <field name="description">
        <type name="utf8" c:type="const char*"/>
      </field>
      <field name="argument_table">
        <type name="ArgumentTable" c:type="VipsArgumentTable*"/>
      </field>
      <field name="argument_table_traverse">
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="argument_table_traverse_gtype">
        <type name="GType" c:type="GType"/>
      </field>
      <field name="deprecated">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="_vips_reserved1" introspectable="0">
        <callback name="_vips_reserved1">
          <source-position filename="libvips/include/vips/object.h"
                           line="588"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_vips_reserved2" introspectable="0">
        <callback name="_vips_reserved2">
          <source-position filename="libvips/include/vips/object.h"
                           line="589"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_vips_reserved3" introspectable="0">
        <callback name="_vips_reserved3">
          <source-position filename="libvips/include/vips/object.h"
                           line="590"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_vips_reserved4" introspectable="0">
        <callback name="_vips_reserved4">
          <source-position filename="libvips/include/vips/object.h"
                           line="591"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <method name="install_argument"
              c:identifier="vips_object_class_install_argument">
        <source-position filename="libvips/include/vips/object.h" line="631"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cls" transfer-ownership="none">
            <type name="ObjectClass" c:type="VipsObjectClass*"/>
          </instance-parameter>
          <parameter name="pspec" transfer-ownership="none">
            <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <type name="ArgumentFlags" c:type="VipsArgumentFlags"/>
          </parameter>
          <parameter name="priority" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <callback name="ObjectSetArguments" c:type="VipsObjectSetArguments">
      <source-position filename="libvips/include/vips/object.h" line="646"/>
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <type name="Object" c:type="VipsObject*"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <class name="Operation"
           c:symbol-prefix="operation"
           c:type="VipsOperation"
           parent="Object"
           abstract="1"
           glib:type-name="VipsOperation"
           glib:get-type="vips_operation_get_type"
           glib:type-struct="OperationClass">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/operation.c"
           line="54">An abstract base class for all operations in libvips.

It builds on [class@Object] to provide the introspection and
command-line interface to libvips.

It also maintains a cache of recent operations. See below.

[func@call], [func@call_split] and [func@call_split_option_string] are used
by vips to implement the C API. They can execute any [class@Operation],
passing in a set of required and optional arguments. Normally you would not
use these functions directly: every operation has a tiny wrapper function
which provides type-safety for the required arguments. For example,
[method@Image.embed] is defined as:

```c
int
vips_embed(VipsImage *in, VipsImage **out,
    int x, int y, int width, int height, ...)
{
    va_list ap;
    int result;

    va_start(ap, height);
    result = vips_call_split("embed", ap, in, out, x, y, width, height);
    va_end(ap);

    return result;
}
```

Use [func@call_argv] to run any libvips operation from a command-line style
argc/argv array. This is the thing used by the `vips` main program to
implement the command-line interface.

## [class@Operation] and reference counting

After calling a [class@Operation] you are responsible for unreffing any
output objects. For example, consider:

```c
VipsImage *im = ...;
VipsImage *t1;

if (vips_invert(im, &amp;t1, NULL))
    error ..
```

This will invert `im` and return a new [class@Image], `t1`. As the caller
of [method@Image.invert], you are responsible for `t1` and must unref it
when you no longer need it. If [method@Image.invert] fails, no `t1` is
returned and you don't need to do anything.

If you don't need to use `im` for another operation, you can unref `im`
immediately after the call. If `im` is needed to calculate `t1`,
[method@Image.invert] will add a ref to `im` and automatically drop it when
`t1` is unreffed.

Consider running two operations, one after the other. You could write:

```c
VipsImage *im = ...;
VipsImage *t1, *t2;

if (vips_invert(im, &amp;t1, NULL)) {
    g_object_unref(im);
    return -1;
}
g_object_unref(im);

if (vips_flip(t1, &amp;t2, VIPS_DIRECTION_HORIZONTAL, NULL)) {
    g_object_unref(t1);
    return -1;
}
g_object_unref(t1);
```

This is correct, but rather long-winded. libvips provides a handy thing to
make a vector of auto-freeing object references. You can write this as:

```c
VipsObject *parent = ...;
VipsImage *im = ...;
VipsImage *t = (VipsImage **) vips_object_local_array(parent, 2);

if (vips_invert(im, &amp;t[0], NULL) ||
    vips_flip(t[0], &amp;t[1], VIPS_DIRECTION_HORIZONTAL, NULL))
    return -1;
```

where `parent` is some enclosing object which will be unreffed when this
task is complete. [method@Object.local_array] makes an array of
[class@Object] (or [class@Image], in this case) where when `parent` is
freed, all non-`NULL` [class@Object] in the array are also unreffed.

## The [class@Operation] cache

Because all [class@Object] are immutable, they can be cached. The cache is
very simple to use: instead of calling [method@Object.build], call
[func@cache_operation_build]. This function calculates a hash from the
operations' input arguments and looks it up in table of all recent
operations. If there's a hit, the new operation is unreffed, the old
operation reffed, and the old operation returned in place of the new one.

The cache size is controlled with [func@cache_set_max] and friends.</doc>
      <source-position filename="libvips/include/vips/operation.h" line="102"/>
      <constructor name="new" c:identifier="vips_operation_new">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/operation.c"
             line="723">Return a new [class@Operation] with the specified nickname. Useful for
language bindings.

You'll need to set any arguments and build the operation before you can use
it. See [func@call] for a higher-level way to make new operations.</doc>
        <source-position filename="libvips/include/vips/operation.h"
                         line="117"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/operation.c"
               line="733">the new operation.</doc>
          <type name="Operation" c:type="VipsOperation*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/operation.c"
                 line="725">nickname of operation to create</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="block_set" c:identifier="vips_operation_block_set">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/operation.c"
             line="1512">Set the block state on all operations in the libvips class hierarchy at
@name and below.

For example:

```c
vips_operation_block_set("VipsForeignLoad", TRUE);
vips_operation_block_set("VipsForeignLoadJpeg", FALSE);
```

Will block all load operations, except JPEG.

Use `vips -l` at the command-line to see the class hierarchy.

This call does nothing if the named operation is not found.

::: seealso
    [func@block_untrusted_set].</doc>
        <source-position filename="libvips/include/vips/operation.h"
                         line="171"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/operation.c"
                 line="1514">set block state at this point and below</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="state" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/operation.c"
                 line="1515">the block state to set</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="get_flags" invoker="get_flags">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/operation.c"
             line="680">Returns the set of flags for this operation.</doc>
        <source-position filename="libvips/include/vips/operation.h"
                         line="95"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/operation.c"
               line="686">0 on success, or -1 on error.</doc>
          <type name="OperationFlags" c:type="VipsOperationFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/operation.c"
                 line="682">operation to fetch flags from</doc>
            <type name="Operation" c:type="VipsOperation*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="invalidate" invoker="invalidate">
        <source-position filename="libvips/include/vips/operation.h"
                         line="101"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation" transfer-ownership="none">
            <type name="Operation" c:type="VipsOperation*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="call_valist"
              c:identifier="vips_operation_call_valist"
              introspectable="0">
        <source-position filename="libvips/include/vips/operation.h"
                         line="115"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation" transfer-ownership="none">
            <type name="Operation" c:type="VipsOperation*"/>
          </instance-parameter>
          <parameter name="ap" transfer-ownership="none">
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_flags" c:identifier="vips_operation_get_flags">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/operation.c"
             line="680">Returns the set of flags for this operation.</doc>
        <source-position filename="libvips/include/vips/operation.h"
                         line="108"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/operation.c"
               line="686">0 on success, or -1 on error.</doc>
          <type name="OperationFlags" c:type="VipsOperationFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/operation.c"
                 line="682">operation to fetch flags from</doc>
            <type name="Operation" c:type="VipsOperation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="invalidate" c:identifier="vips_operation_invalidate">
        <source-position filename="libvips/include/vips/operation.h"
                         line="112"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation" transfer-ownership="none">
            <type name="Operation" c:type="VipsOperation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="Object" c:type="VipsObject"/>
      </field>
      <field name="hash">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="found_hash">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="pixels">
        <type name="gint" c:type="int"/>
      </field>
      <glib:signal name="invalidate" when="last">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <enumeration name="OperationBoolean"
                 glib:type-name="VipsOperationBoolean"
                 glib:get-type="vips_operation_boolean_get_type"
                 c:type="VipsOperationBoolean">
      <doc xml:space="preserve"
           filename="libvips/include/vips/arithmetic.h"
           line="136">See also: [method@Image.boolean].</doc>
      <member name="and"
              value="0"
              c:identifier="VIPS_OPERATION_BOOLEAN_AND"
              glib:nick="and"
              glib:name="VIPS_OPERATION_BOOLEAN_AND">
        <doc xml:space="preserve"
             filename="libvips/include/vips/arithmetic.h"
             line="138">`&amp;`</doc>
      </member>
      <member name="or"
              value="1"
              c:identifier="VIPS_OPERATION_BOOLEAN_OR"
              glib:nick="or"
              glib:name="VIPS_OPERATION_BOOLEAN_OR">
        <doc xml:space="preserve"
             filename="libvips/include/vips/arithmetic.h"
             line="139">`|`</doc>
      </member>
      <member name="eor"
              value="2"
              c:identifier="VIPS_OPERATION_BOOLEAN_EOR"
              glib:nick="eor"
              glib:name="VIPS_OPERATION_BOOLEAN_EOR">
        <doc xml:space="preserve"
             filename="libvips/include/vips/arithmetic.h"
             line="140">`^`</doc>
      </member>
      <member name="lshift"
              value="3"
              c:identifier="VIPS_OPERATION_BOOLEAN_LSHIFT"
              glib:nick="lshift"
              glib:name="VIPS_OPERATION_BOOLEAN_LSHIFT">
        <doc xml:space="preserve"
             filename="libvips/include/vips/arithmetic.h"
             line="141">`&gt;&gt;`</doc>
      </member>
      <member name="rshift"
              value="4"
              c:identifier="VIPS_OPERATION_BOOLEAN_RSHIFT"
              glib:nick="rshift"
              glib:name="VIPS_OPERATION_BOOLEAN_RSHIFT">
        <doc xml:space="preserve"
             filename="libvips/include/vips/arithmetic.h"
             line="142">`&lt;&lt;`</doc>
      </member>
    </enumeration>
    <callback name="OperationBuildFn" c:type="VipsOperationBuildFn">
      <source-position filename="libvips/include/vips/operation.h" line="71"/>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <type name="Object" c:type="VipsObject*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="OperationClass"
            c:type="VipsOperationClass"
            glib:is-gtype-struct-for="Operation">
      <source-position filename="libvips/include/vips/operation.h" line="102"/>
      <field name="parent_class">
        <type name="ObjectClass" c:type="VipsObjectClass"/>
      </field>
      <field name="usage">
        <callback name="usage">
          <source-position filename="libvips/include/vips/operation.h"
                           line="91"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="cls" transfer-ownership="none">
              <type name="gpointer" c:type="_VipsOperationClass*"/>
            </parameter>
            <parameter name="buf" transfer-ownership="none">
              <type name="Buf" c:type="VipsBuf*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_flags">
        <callback name="get_flags">
          <source-position filename="libvips/include/vips/operation.h"
                           line="95"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/operation.c"
                 line="686">0 on success, or -1 on error.</doc>
            <type name="OperationFlags" c:type="VipsOperationFlags"/>
          </return-value>
          <parameters>
            <parameter name="operation" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="libvips/iofuncs/operation.c"
                   line="682">operation to fetch flags from</doc>
              <type name="Operation" c:type="VipsOperation*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="flags">
        <type name="OperationFlags" c:type="VipsOperationFlags"/>
      </field>
      <field name="invalidate">
        <callback name="invalidate">
          <source-position filename="libvips/include/vips/operation.h"
                           line="101"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="operation" transfer-ownership="none">
              <type name="Operation" c:type="VipsOperation*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <method name="print_usage"
              c:identifier="vips_operation_class_print_usage"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/operation.c"
             line="696">Print a usage message for the operation to stdout.</doc>
        <source-position filename="libvips/include/vips/operation.h"
                         line="110"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation_class" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/operation.c"
                 line="698">class to print usage for</doc>
            <type name="OperationClass" c:type="VipsOperationClass*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="OperationComplex"
                 glib:type-name="VipsOperationComplex"
                 glib:get-type="vips_operation_complex_get_type"
                 c:type="VipsOperationComplex">
      <doc xml:space="preserve"
           filename="libvips/include/vips/arithmetic.h"
           line="155">See also: [method@Image.complex].</doc>
      <member name="polar"
              value="0"
              c:identifier="VIPS_OPERATION_COMPLEX_POLAR"
              glib:nick="polar"
              glib:name="VIPS_OPERATION_COMPLEX_POLAR">
        <doc xml:space="preserve"
             filename="libvips/include/vips/arithmetic.h"
             line="157">convert to polar coordinates</doc>
      </member>
      <member name="rect"
              value="1"
              c:identifier="VIPS_OPERATION_COMPLEX_RECT"
              glib:nick="rect"
              glib:name="VIPS_OPERATION_COMPLEX_RECT">
        <doc xml:space="preserve"
             filename="libvips/include/vips/arithmetic.h"
             line="158">convert to rectangular coordinates</doc>
      </member>
      <member name="conj"
              value="2"
              c:identifier="VIPS_OPERATION_COMPLEX_CONJ"
              glib:nick="conj"
              glib:name="VIPS_OPERATION_COMPLEX_CONJ">
        <doc xml:space="preserve"
             filename="libvips/include/vips/arithmetic.h"
             line="159">complex conjugate</doc>
      </member>
    </enumeration>
    <enumeration name="OperationComplex2"
                 glib:type-name="VipsOperationComplex2"
                 glib:get-type="vips_operation_complex2_get_type"
                 c:type="VipsOperationComplex2">
      <doc xml:space="preserve"
           filename="libvips/include/vips/arithmetic.h"
           line="170">See also: [method@Image.complex2].</doc>
      <member name="cross_phase"
              value="0"
              c:identifier="VIPS_OPERATION_COMPLEX2_CROSS_PHASE"
              glib:nick="cross-phase"
              glib:name="VIPS_OPERATION_COMPLEX2_CROSS_PHASE">
        <doc xml:space="preserve"
             filename="libvips/include/vips/arithmetic.h"
             line="172">convert to polar coordinates</doc>
      </member>
    </enumeration>
    <enumeration name="OperationComplexget"
                 glib:type-name="VipsOperationComplexget"
                 glib:get-type="vips_operation_complexget_get_type"
                 c:type="VipsOperationComplexget">
      <doc xml:space="preserve"
           filename="libvips/include/vips/arithmetic.h"
           line="181">See also: [method@Image.complexget].</doc>
      <member name="real"
              value="0"
              c:identifier="VIPS_OPERATION_COMPLEXGET_REAL"
              glib:nick="real"
              glib:name="VIPS_OPERATION_COMPLEXGET_REAL">
        <doc xml:space="preserve"
             filename="libvips/include/vips/arithmetic.h"
             line="183">get real component</doc>
      </member>
      <member name="imag"
              value="1"
              c:identifier="VIPS_OPERATION_COMPLEXGET_IMAG"
              glib:nick="imag"
              glib:name="VIPS_OPERATION_COMPLEXGET_IMAG">
        <doc xml:space="preserve"
             filename="libvips/include/vips/arithmetic.h"
             line="184">get imaginary component</doc>
      </member>
    </enumeration>
    <bitfield name="OperationFlags"
              glib:type-name="VipsOperationFlags"
              glib:get-type="vips_operation_flags_get_type"
              c:type="VipsOperationFlags">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/operation.c"
           line="163">Flags we associate with an operation.

[flags@Vips.OperationFlags.SEQUENTIAL] means that the operation works like
[method@Image.conv]: it can process images top-to-bottom with only small
non-local references.

Every scan-line must be requested, you are not allowed to skip
ahead, but as a special case, the very first request can be for a region
not at the top of the image. In this case, the first part of the image will
be read and discarded

Every scan-line must be requested, you are not allowed to skip
ahead, but as a special case, the very first request can be for a region
not at the top of the image. In this case, the first part of the image will
be read and discarded

[flags@Vips.OperationFlags.NOCACHE] means that the operation must not be
cached by vips.

[flags@Vips.OperationFlags.DEPRECATED] means this is an old operation kept
in vips for compatibility only and should be hidden from users.

[flags@Vips.OperationFlags.UNTRUSTED] means the operation depends on
external libraries which have not been hardened against attack. It should
probably not be used on untrusted input. Use [func@block_untrusted_set]
to block all untrusted operations.

[flags@Vips.OperationFlags.BLOCKED] means the operation is prevented from
executing. Use [func@Operation.block_set] to enable and disable groups of
operations.

[flags@Vips.OperationFlags.REVALIDATE] force the operation to run, updating
the cache with the new value. This is used by eg. VipsForeignLoad to
implement the "revalidate" argument.</doc>
      <member name="none"
              value="0"
              c:identifier="VIPS_OPERATION_NONE"
              glib:nick="none"
              glib:name="VIPS_OPERATION_NONE">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/operation.c"
             line="165">no flags</doc>
      </member>
      <member name="sequential"
              value="1"
              c:identifier="VIPS_OPERATION_SEQUENTIAL"
              glib:nick="sequential"
              glib:name="VIPS_OPERATION_SEQUENTIAL">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/operation.c"
             line="166">can work sequentially with a small buffer</doc>
      </member>
      <member name="sequential_unbuffered"
              value="2"
              c:identifier="VIPS_OPERATION_SEQUENTIAL_UNBUFFERED"
              glib:nick="sequential-unbuffered"
              glib:name="VIPS_OPERATION_SEQUENTIAL_UNBUFFERED">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/operation.c"
             line="167">deprecated, use [flags@Vips.OperationFlags.SEQUENTIAL] instead</doc>
      </member>
      <member name="nocache"
              value="4"
              c:identifier="VIPS_OPERATION_NOCACHE"
              glib:nick="nocache"
              glib:name="VIPS_OPERATION_NOCACHE">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/operation.c"
             line="168">must not be cached</doc>
      </member>
      <member name="deprecated"
              value="8"
              c:identifier="VIPS_OPERATION_DEPRECATED"
              glib:nick="deprecated"
              glib:name="VIPS_OPERATION_DEPRECATED">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/operation.c"
             line="169">a compatibility thing</doc>
      </member>
      <member name="untrusted"
              value="16"
              c:identifier="VIPS_OPERATION_UNTRUSTED"
              glib:nick="untrusted"
              glib:name="VIPS_OPERATION_UNTRUSTED">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/operation.c"
             line="170">not hardened for untrusted input</doc>
      </member>
      <member name="blocked"
              value="32"
              c:identifier="VIPS_OPERATION_BLOCKED"
              glib:nick="blocked"
              glib:name="VIPS_OPERATION_BLOCKED">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/operation.c"
             line="171">prevent this operation from running</doc>
      </member>
      <member name="revalidate"
              value="64"
              c:identifier="VIPS_OPERATION_REVALIDATE"
              glib:nick="revalidate"
              glib:name="VIPS_OPERATION_REVALIDATE">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/operation.c"
             line="172">force the operation to run</doc>
      </member>
    </bitfield>
    <enumeration name="OperationMath"
                 glib:type-name="VipsOperationMath"
                 glib:get-type="vips_operation_math_get_type"
                 c:type="VipsOperationMath">
      <doc xml:space="preserve"
           filename="libvips/include/vips/arithmetic.h"
           line="44">See also: [method@Image.math].</doc>
      <member name="sin"
              value="0"
              c:identifier="VIPS_OPERATION_MATH_SIN"
              glib:nick="sin"
              glib:name="VIPS_OPERATION_MATH_SIN">
        <doc xml:space="preserve"
             filename="libvips/include/vips/arithmetic.h"
             line="46">`sin()`, angles in degrees</doc>
      </member>
      <member name="cos"
              value="1"
              c:identifier="VIPS_OPERATION_MATH_COS"
              glib:nick="cos"
              glib:name="VIPS_OPERATION_MATH_COS">
        <doc xml:space="preserve"
             filename="libvips/include/vips/arithmetic.h"
             line="47">`cos()`, angles in degrees</doc>
      </member>
      <member name="tan"
              value="2"
              c:identifier="VIPS_OPERATION_MATH_TAN"
              glib:nick="tan"
              glib:name="VIPS_OPERATION_MATH_TAN">
        <doc xml:space="preserve"
             filename="libvips/include/vips/arithmetic.h"
             line="48">`tan()`, angles in degrees</doc>
      </member>
      <member name="asin"
              value="3"
              c:identifier="VIPS_OPERATION_MATH_ASIN"
              glib:nick="asin"
              glib:name="VIPS_OPERATION_MATH_ASIN">
        <doc xml:space="preserve"
             filename="libvips/include/vips/arithmetic.h"
             line="49">`asin()`, angles in degrees</doc>
      </member>
      <member name="acos"
              value="4"
              c:identifier="VIPS_OPERATION_MATH_ACOS"
              glib:nick="acos"
              glib:name="VIPS_OPERATION_MATH_ACOS">
        <doc xml:space="preserve"
             filename="libvips/include/vips/arithmetic.h"
             line="50">`acos()`, angles in degrees</doc>
      </member>
      <member name="atan"
              value="5"
              c:identifier="VIPS_OPERATION_MATH_ATAN"
              glib:nick="atan"
              glib:name="VIPS_OPERATION_MATH_ATAN">
        <doc xml:space="preserve"
             filename="libvips/include/vips/arithmetic.h"
             line="51">`atan()`, angles in degrees</doc>
      </member>
      <member name="log"
              value="6"
              c:identifier="VIPS_OPERATION_MATH_LOG"
              glib:nick="log"
              glib:name="VIPS_OPERATION_MATH_LOG">
        <doc xml:space="preserve"
             filename="libvips/include/vips/arithmetic.h"
             line="52">log base e</doc>
      </member>
      <member name="log10"
              value="7"
              c:identifier="VIPS_OPERATION_MATH_LOG10"
              glib:nick="log10"
              glib:name="VIPS_OPERATION_MATH_LOG10">
        <doc xml:space="preserve"
             filename="libvips/include/vips/arithmetic.h"
             line="53">log base 10</doc>
      </member>
      <member name="exp"
              value="8"
              c:identifier="VIPS_OPERATION_MATH_EXP"
              glib:nick="exp"
              glib:name="VIPS_OPERATION_MATH_EXP">
        <doc xml:space="preserve"
             filename="libvips/include/vips/arithmetic.h"
             line="54">e to the something</doc>
      </member>
      <member name="exp10"
              value="9"
              c:identifier="VIPS_OPERATION_MATH_EXP10"
              glib:nick="exp10"
              glib:name="VIPS_OPERATION_MATH_EXP10">
        <doc xml:space="preserve"
             filename="libvips/include/vips/arithmetic.h"
             line="55">10 to the something</doc>
      </member>
      <member name="sinh"
              value="10"
              c:identifier="VIPS_OPERATION_MATH_SINH"
              glib:nick="sinh"
              glib:name="VIPS_OPERATION_MATH_SINH">
        <doc xml:space="preserve"
             filename="libvips/include/vips/arithmetic.h"
             line="56">`sinh()`, angles in radians</doc>
      </member>
      <member name="cosh"
              value="11"
              c:identifier="VIPS_OPERATION_MATH_COSH"
              glib:nick="cosh"
              glib:name="VIPS_OPERATION_MATH_COSH">
        <doc xml:space="preserve"
             filename="libvips/include/vips/arithmetic.h"
             line="57">`cosh()`, angles in radians</doc>
      </member>
      <member name="tanh"
              value="12"
              c:identifier="VIPS_OPERATION_MATH_TANH"
              glib:nick="tanh"
              glib:name="VIPS_OPERATION_MATH_TANH">
        <doc xml:space="preserve"
             filename="libvips/include/vips/arithmetic.h"
             line="58">`tanh()`, angles in radians</doc>
      </member>
      <member name="asinh"
              value="13"
              c:identifier="VIPS_OPERATION_MATH_ASINH"
              glib:nick="asinh"
              glib:name="VIPS_OPERATION_MATH_ASINH">
        <doc xml:space="preserve"
             filename="libvips/include/vips/arithmetic.h"
             line="59">`asinh()`, angles in radians</doc>
      </member>
      <member name="acosh"
              value="14"
              c:identifier="VIPS_OPERATION_MATH_ACOSH"
              glib:nick="acosh"
              glib:name="VIPS_OPERATION_MATH_ACOSH">
        <doc xml:space="preserve"
             filename="libvips/include/vips/arithmetic.h"
             line="60">`acosh()`, angles in radians</doc>
      </member>
      <member name="atanh"
              value="15"
              c:identifier="VIPS_OPERATION_MATH_ATANH"
              glib:nick="atanh"
              glib:name="VIPS_OPERATION_MATH_ATANH">
        <doc xml:space="preserve"
             filename="libvips/include/vips/arithmetic.h"
             line="61">`atanh()`, angles in radians</doc>
      </member>
    </enumeration>
    <enumeration name="OperationMath2"
                 glib:type-name="VipsOperationMath2"
                 glib:get-type="vips_operation_math2_get_type"
                 c:type="VipsOperationMath2">
      <doc xml:space="preserve"
           filename="libvips/include/vips/arithmetic.h"
           line="85">See also: [method@Image.math].</doc>
      <member name="pow"
              value="0"
              c:identifier="VIPS_OPERATION_MATH2_POW"
              glib:nick="pow"
              glib:name="VIPS_OPERATION_MATH2_POW">
        <doc xml:space="preserve"
             filename="libvips/include/vips/arithmetic.h"
             line="87">`pow(left, right)`</doc>
      </member>
      <member name="wop"
              value="1"
              c:identifier="VIPS_OPERATION_MATH2_WOP"
              glib:nick="wop"
              glib:name="VIPS_OPERATION_MATH2_WOP">
        <doc xml:space="preserve"
             filename="libvips/include/vips/arithmetic.h"
             line="88">`pow(right, left)`</doc>
      </member>
      <member name="atan2"
              value="2"
              c:identifier="VIPS_OPERATION_MATH2_ATAN2"
              glib:nick="atan2"
              glib:name="VIPS_OPERATION_MATH2_ATAN2">
        <doc xml:space="preserve"
             filename="libvips/include/vips/arithmetic.h"
             line="89">`atan2(left, right)`</doc>
      </member>
    </enumeration>
    <enumeration name="OperationMorphology"
                 glib:type-name="VipsOperationMorphology"
                 glib:get-type="vips_operation_morphology_get_type"
                 c:type="VipsOperationMorphology">
      <doc xml:space="preserve"
           filename="libvips/morphology/morph.c"
           line="110">More like hit-miss, really.

::: seealso
    [method@Image.morph].</doc>
      <member name="erode"
              value="0"
              c:identifier="VIPS_OPERATION_MORPHOLOGY_ERODE"
              glib:nick="erode"
              glib:name="VIPS_OPERATION_MORPHOLOGY_ERODE">
        <doc xml:space="preserve"
             filename="libvips/morphology/morph.c"
             line="112">true if all set</doc>
      </member>
      <member name="dilate"
              value="1"
              c:identifier="VIPS_OPERATION_MORPHOLOGY_DILATE"
              glib:nick="dilate"
              glib:name="VIPS_OPERATION_MORPHOLOGY_DILATE">
        <doc xml:space="preserve"
             filename="libvips/morphology/morph.c"
             line="113">true if one set</doc>
      </member>
    </enumeration>
    <enumeration name="OperationRelational"
                 glib:type-name="VipsOperationRelational"
                 glib:get-type="vips_operation_relational_get_type"
                 c:type="VipsOperationRelational">
      <doc xml:space="preserve"
           filename="libvips/include/vips/arithmetic.h"
           line="115">See also: [method@Image.relational].</doc>
      <member name="equal"
              value="0"
              c:identifier="VIPS_OPERATION_RELATIONAL_EQUAL"
              glib:nick="equal"
              glib:name="VIPS_OPERATION_RELATIONAL_EQUAL">
        <doc xml:space="preserve"
             filename="libvips/include/vips/arithmetic.h"
             line="117">`==`</doc>
      </member>
      <member name="noteq"
              value="1"
              c:identifier="VIPS_OPERATION_RELATIONAL_NOTEQ"
              glib:nick="noteq"
              glib:name="VIPS_OPERATION_RELATIONAL_NOTEQ">
        <doc xml:space="preserve"
             filename="libvips/include/vips/arithmetic.h"
             line="118">`!=`</doc>
      </member>
      <member name="less"
              value="2"
              c:identifier="VIPS_OPERATION_RELATIONAL_LESS"
              glib:nick="less"
              glib:name="VIPS_OPERATION_RELATIONAL_LESS">
        <doc xml:space="preserve"
             filename="libvips/include/vips/arithmetic.h"
             line="119">`&lt;`</doc>
      </member>
      <member name="lesseq"
              value="3"
              c:identifier="VIPS_OPERATION_RELATIONAL_LESSEQ"
              glib:nick="lesseq"
              glib:name="VIPS_OPERATION_RELATIONAL_LESSEQ">
        <doc xml:space="preserve"
             filename="libvips/include/vips/arithmetic.h"
             line="120">`&lt;=`</doc>
      </member>
      <member name="more"
              value="4"
              c:identifier="VIPS_OPERATION_RELATIONAL_MORE"
              glib:nick="more"
              glib:name="VIPS_OPERATION_RELATIONAL_MORE">
        <doc xml:space="preserve"
             filename="libvips/include/vips/arithmetic.h"
             line="121">`&gt;`</doc>
      </member>
      <member name="moreeq"
              value="5"
              c:identifier="VIPS_OPERATION_RELATIONAL_MOREEQ"
              glib:nick="moreeq"
              glib:name="VIPS_OPERATION_RELATIONAL_MOREEQ">
        <doc xml:space="preserve"
             filename="libvips/include/vips/arithmetic.h"
             line="122">`&gt;=`</doc>
      </member>
    </enumeration>
    <enumeration name="OperationRound"
                 glib:type-name="VipsOperationRound"
                 glib:get-type="vips_operation_round_get_type"
                 c:type="VipsOperationRound">
      <doc xml:space="preserve"
           filename="libvips/include/vips/arithmetic.h"
           line="100">See also: [method@Image.round].</doc>
      <member name="rint"
              value="0"
              c:identifier="VIPS_OPERATION_ROUND_RINT"
              glib:nick="rint"
              glib:name="VIPS_OPERATION_ROUND_RINT">
        <doc xml:space="preserve"
             filename="libvips/include/vips/arithmetic.h"
             line="102">round to nearest</doc>
      </member>
      <member name="ceil"
              value="1"
              c:identifier="VIPS_OPERATION_ROUND_CEIL"
              glib:nick="ceil"
              glib:name="VIPS_OPERATION_ROUND_CEIL">
        <doc xml:space="preserve"
             filename="libvips/include/vips/arithmetic.h"
             line="104">the smallest integral value not less than</doc>
      </member>
      <member name="floor"
              value="2"
              c:identifier="VIPS_OPERATION_ROUND_FLOOR"
              glib:nick="floor"
              glib:name="VIPS_OPERATION_ROUND_FLOOR">
        <doc xml:space="preserve"
             filename="libvips/include/vips/arithmetic.h"
             line="103">largest integral value not greater than</doc>
      </member>
    </enumeration>
    <constant name="PATH_MAX" value="4096" c:type="VIPS_PATH_MAX">
      <source-position filename="libvips/include/vips/util.h" line="231"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <enumeration name="PCS"
                 glib:type-name="VipsPCS"
                 glib:get-type="vips_pcs_get_type"
                 c:type="VipsPCS">
      <doc xml:space="preserve"
           filename="libvips/colour/icc_transform.c"
           line="116">Pick a Profile Connection Space for [method@Image.icc_import] and
[method@Image.icc_export]. LAB is usually best, XYZ can be more convenient in some
cases.</doc>
      <member name="lab"
              value="0"
              c:identifier="VIPS_PCS_LAB"
              glib:nick="lab"
              glib:name="VIPS_PCS_LAB">
        <doc xml:space="preserve"
             filename="libvips/colour/icc_transform.c"
             line="118">use CIELAB D65 as the Profile Connection Space</doc>
      </member>
      <member name="xyz"
              value="1"
              c:identifier="VIPS_PCS_XYZ"
              glib:nick="xyz"
              glib:name="VIPS_PCS_XYZ">
        <doc xml:space="preserve"
             filename="libvips/colour/icc_transform.c"
             line="119">use XYZ as the Profile Connection Space</doc>
      </member>
    </enumeration>
    <constant name="PI" value="3.141593" c:type="VIPS_PI">
      <source-position filename="libvips/include/vips/util.h" line="46"/>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <enumeration name="Precision"
                 glib:type-name="VipsPrecision"
                 glib:get-type="vips_precision_get_type"
                 c:type="VipsPrecision">
      <doc xml:space="preserve"
           filename="libvips/convolution/convolution.c"
           line="54">How accurate an operation should be.</doc>
      <member name="integer"
              value="0"
              c:identifier="VIPS_PRECISION_INTEGER"
              glib:nick="integer"
              glib:name="VIPS_PRECISION_INTEGER">
        <doc xml:space="preserve"
             filename="libvips/convolution/convolution.c"
             line="56">int everywhere</doc>
      </member>
      <member name="float"
              value="1"
              c:identifier="VIPS_PRECISION_FLOAT"
              glib:nick="float"
              glib:name="VIPS_PRECISION_FLOAT">
        <doc xml:space="preserve"
             filename="libvips/convolution/convolution.c"
             line="57">float everywhere</doc>
      </member>
      <member name="approximate"
              value="2"
              c:identifier="VIPS_PRECISION_APPROXIMATE"
              glib:nick="approximate"
              glib:name="VIPS_PRECISION_APPROXIMATE">
        <doc xml:space="preserve"
             filename="libvips/convolution/convolution.c"
             line="58">approximate integer output</doc>
      </member>
    </enumeration>
    <record name="Progress" c:type="VipsProgress">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/image.c"
           line="272">A structure available to eval callbacks giving information on evaluation
progress. See [signal@Image::eval].</doc>
      <source-position filename="libvips/include/vips/image.h" line="170"/>
      <field name="im" readable="0" private="1">
        <type name="Image" c:type="VipsImage*"/>
      </field>
      <field name="run" writable="1">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="274">Time we have been running</doc>
        <type name="gint" c:type="int"/>
      </field>
      <field name="eta" writable="1">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="275">Estimated seconds of computation left</doc>
        <type name="gint" c:type="int"/>
      </field>
      <field name="tpels" writable="1">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="276">Number of pels we expect to calculate</doc>
        <type name="gint64" c:type="gint64"/>
      </field>
      <field name="npels" writable="1">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="277">Number of pels calculated so far</doc>
        <type name="gint64" c:type="gint64"/>
      </field>
      <field name="percent" writable="1">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="278">Percent complete</doc>
        <type name="gint" c:type="int"/>
      </field>
      <field name="start" writable="1">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="279">Start time</doc>
        <type name="GLib.Timer" c:type="GTimer*"/>
      </field>
      <function name="set" c:identifier="vips_progress_set">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="387">If set, vips will print messages about the progress of computation to
stdout. This can also be enabled with the `--vips-progress` option, or by
setting the environment variable `VIPS_PROGRESS`.</doc>
        <source-position filename="libvips/include/vips/image.h" line="437"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="progress" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/image.c"
                 line="389">`TRUE` to enable progress messages</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <function-macro name="RAD" c:identifier="VIPS_RAD" introspectable="0">
      <source-position filename="libvips/include/vips/util.h" line="50"/>
      <parameters>
        <parameter name="R">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="RECT_BOTTOM"
                    c:identifier="VIPS_RECT_BOTTOM"
                    introspectable="0">
      <source-position filename="libvips/include/vips/rect.h" line="49"/>
      <parameters>
        <parameter name="R">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="RECT_HCENTRE"
                    c:identifier="VIPS_RECT_HCENTRE"
                    introspectable="0">
      <source-position filename="libvips/include/vips/rect.h" line="50"/>
      <parameters>
        <parameter name="R">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="RECT_RIGHT"
                    c:identifier="VIPS_RECT_RIGHT"
                    introspectable="0">
      <source-position filename="libvips/include/vips/rect.h" line="48"/>
      <parameters>
        <parameter name="R">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="RECT_VCENTRE"
                    c:identifier="VIPS_RECT_VCENTRE"
                    introspectable="0">
      <source-position filename="libvips/include/vips/rect.h" line="51"/>
      <parameters>
        <parameter name="R">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="REGION"
                    c:identifier="VIPS_REGION"
                    introspectable="0">
      <source-position filename="libvips/include/vips/region.h" line="51"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="REGION_ADDR"
                    c:identifier="VIPS_REGION_ADDR"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/region.c"
           line="148">This macro returns a pointer to a pixel in a region. The (@X, @Y)
coordinates need to be within the [struct@Rect] (@R-&gt;valid).

If DEBUG is defined, you get a version that checks bounds for you.

::: seealso
    [method@Region.prepare].</doc>
      <source-position filename="libvips/include/vips/region.h" line="212"/>
      <parameters>
        <parameter name="R">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/region.c"
               line="150">a [class@Region]</doc>
        </parameter>
        <parameter name="X">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/region.c"
               line="151">x coordinate</doc>
        </parameter>
        <parameter name="Y">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/region.c"
               line="152">y coordinate</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="REGION_ADDR_TOPLEFT"
                    c:identifier="VIPS_REGION_ADDR_TOPLEFT"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/region.c"
           line="165">This macro returns a pointer to the top-left pixel in the [class@Region], that
is, the pixel at (@R-&gt;valid.left, @R-&gt;valid.top).

::: seealso
    [method@Region.prepare].</doc>
      <source-position filename="libvips/include/vips/region.h" line="236"/>
      <parameters>
        <parameter name="R">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/region.c"
               line="167">a [class@Region]</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="REGION_CLASS"
                    c:identifier="VIPS_REGION_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/region.h" line="54"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="REGION_GET_CLASS"
                    c:identifier="VIPS_REGION_GET_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/region.h" line="61"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="REGION_LSKIP"
                    c:identifier="VIPS_REGION_LSKIP"
                    introspectable="0">
      <source-position filename="libvips/include/vips/region.h" line="198"/>
      <parameters>
        <parameter name="R">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/region.c"
               line="129">a [class@Region]</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="REGION_N_ELEMENTS"
                    c:identifier="VIPS_REGION_N_ELEMENTS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/region.h" line="200"/>
      <parameters>
        <parameter name="R">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/region.c"
               line="136">a [class@Region]</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="REGION_SIZEOF_ELEMENT"
                    c:identifier="VIPS_REGION_SIZEOF_ELEMENT"
                    introspectable="0">
      <source-position filename="libvips/include/vips/region.h" line="202"/>
      <parameters>
        <parameter name="R">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="REGION_SIZEOF_LINE"
                    c:identifier="VIPS_REGION_SIZEOF_LINE"
                    introspectable="0">
      <source-position filename="libvips/include/vips/region.h" line="206"/>
      <parameters>
        <parameter name="R">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/region.c"
               line="143">a [class@Region]</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="REGION_SIZEOF_PEL"
                    c:identifier="VIPS_REGION_SIZEOF_PEL"
                    introspectable="0">
      <source-position filename="libvips/include/vips/region.h" line="204"/>
      <parameters>
        <parameter name="R">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="RINT" c:identifier="VIPS_RINT" introspectable="0">
      <source-position filename="libvips/include/vips/util.h" line="73"/>
      <parameters>
        <parameter name="V">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ROUND" c:identifier="VIPS_ROUND" introspectable="0">
      <source-position filename="libvips/include/vips/util.h" line="74"/>
      <parameters>
        <parameter name="V">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ROUND_DOWN"
                    c:identifier="VIPS_ROUND_DOWN"
                    introspectable="0">
      <source-position filename="libvips/include/vips/util.h" line="96"/>
      <parameters>
        <parameter name="N">
        </parameter>
        <parameter name="P">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ROUND_INT"
                    c:identifier="VIPS_ROUND_INT"
                    introspectable="0">
      <source-position filename="libvips/include/vips/util.h" line="91"/>
      <parameters>
        <parameter name="R">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ROUND_UINT"
                    c:identifier="VIPS_ROUND_UINT"
                    introspectable="0">
      <source-position filename="libvips/include/vips/util.h" line="92"/>
      <parameters>
        <parameter name="R">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ROUND_UP"
                    c:identifier="VIPS_ROUND_UP"
                    introspectable="0">
      <source-position filename="libvips/include/vips/util.h" line="97"/>
      <parameters>
        <parameter name="N">
        </parameter>
        <parameter name="P">
        </parameter>
      </parameters>
    </function-macro>
    <record name="Rect" c:type="VipsRect">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/rect.c"
           line="47">A [struct@Rect] is a rectangular area of pixels. This is a struct for
performing simple rectangle algebra.</doc>
      <source-position filename="libvips/include/vips/rect.h" line="46"/>
      <field name="left" writable="1">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/rect.c"
             line="49">left edge of rectangle</doc>
        <type name="gint" c:type="int"/>
      </field>
      <field name="top" writable="1">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/rect.c"
             line="50">top edge of rectangle</doc>
        <type name="gint" c:type="int"/>
      </field>
      <field name="width" writable="1">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/rect.c"
             line="51">width of rectangle</doc>
        <type name="gint" c:type="int"/>
      </field>
      <field name="height" writable="1">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/rect.c"
             line="52">height of rectangle</doc>
        <type name="gint" c:type="int"/>
      </field>
      <method name="dup" c:identifier="vips_rect_dup" introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/rect.c"
             line="216">Duplicate a rect to the heap. You need to free the result with [func@GLib.free].</doc>
        <source-position filename="libvips/include/vips/rect.h" line="72"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/rect.c"
               line="222">a pointer to copy of @r allocated on the heap.</doc>
          <type name="Rect" c:type="VipsRect*"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/rect.c"
                 line="218">rectangle to duplicate</doc>
            <type name="Rect" c:type="const VipsRect*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="equalsrect" c:identifier="vips_rect_equalsrect">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/rect.c"
             line="109">Is @r1 equal to @r2?</doc>
        <source-position filename="libvips/include/vips/rect.h" line="60"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/rect.c"
               line="116">`TRUE` if @r1 is equal to @r2.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="r1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/rect.c"
                 line="111">first rectangle</doc>
            <type name="Rect" c:type="const VipsRect*"/>
          </instance-parameter>
          <parameter name="r2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/rect.c"
                 line="112">second rectangle</doc>
            <type name="Rect" c:type="const VipsRect*"/>
          </parameter>
        </parameters>
      </method>
      <method name="includespoint" c:identifier="vips_rect_includespoint">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/rect.c"
             line="58">Does @r contain point (@x, @y)?</doc>
        <source-position filename="libvips/include/vips/rect.h" line="56"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/rect.c"
               line="66">`TRUE` if @r contains (@x, @y).</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/rect.c"
                 line="60">rectangle to test</doc>
            <type name="Rect" c:type="const VipsRect*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/rect.c"
                 line="61">position to test for</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/rect.c"
                 line="62">position to test for</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="includesrect" c:identifier="vips_rect_includesrect">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/rect.c"
             line="91">Is @r2 a subset of @r1?</doc>
        <source-position filename="libvips/include/vips/rect.h" line="58"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/rect.c"
               line="98">`TRUE` if @r2 is a subset of @r1.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="r1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/rect.c"
                 line="93">outer rectangle</doc>
            <type name="Rect" c:type="const VipsRect*"/>
          </instance-parameter>
          <parameter name="r2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/rect.c"
                 line="94">inner rectangle</doc>
            <type name="Rect" c:type="const VipsRect*"/>
          </parameter>
        </parameters>
      </method>
      <method name="intersectrect" c:identifier="vips_rect_intersectrect">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/rect.c"
             line="160">Fill @out with the intersection of @r1 and @r2. @out can equal @r1 or @r2.</doc>
        <source-position filename="libvips/include/vips/rect.h" line="66"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="r1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/rect.c"
                 line="162">input rectangle 1</doc>
            <type name="Rect" c:type="const VipsRect*"/>
          </instance-parameter>
          <parameter name="r2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/rect.c"
                 line="163">input rectangle 2</doc>
            <type name="Rect" c:type="const VipsRect*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/rect.c"
                 line="164">output rectangle</doc>
            <type name="Rect" c:type="VipsRect*"/>
          </parameter>
        </parameters>
      </method>
      <method name="isempty" c:identifier="vips_rect_isempty">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/rect.c"
             line="77">Is @r empty? ie. zero width or height.</doc>
        <source-position filename="libvips/include/vips/rect.h" line="54"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/rect.c"
               line="83">`TRUE` if @r contains no pixels.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/rect.c"
                 line="79">rectangle to test</doc>
            <type name="Rect" c:type="const VipsRect*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="marginadjust" c:identifier="vips_rect_marginadjust">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/rect.c"
             line="144">Enlarge @r by @n. +1 means out one pixel.</doc>
        <source-position filename="libvips/include/vips/rect.h" line="64"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/rect.c"
                 line="146">rectangle to adjust</doc>
            <type name="Rect" c:type="VipsRect*"/>
          </instance-parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/rect.c"
                 line="147">enlarge by</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="normalise" c:identifier="vips_rect_normalise">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/rect.c"
             line="236">Make sure width and height are &gt;0 by moving the origin and flipping the
rect.</doc>
        <source-position filename="libvips/include/vips/rect.h" line="74"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/rect.c"
                 line="238">rect to normalise</doc>
            <type name="Rect" c:type="VipsRect*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="overlapsrect" c:identifier="vips_rect_overlapsrect">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/rect.c"
             line="125">Do @r1 and @r2 have a non-empty intersection?</doc>
        <source-position filename="libvips/include/vips/rect.h" line="62"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/rect.c"
               line="132">`TRUE` if @r2 and @r1 overlap.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="r1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/rect.c"
                 line="127">first rectangle</doc>
            <type name="Rect" c:type="const VipsRect*"/>
          </instance-parameter>
          <parameter name="r2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/rect.c"
                 line="128">second rectangle</doc>
            <type name="Rect" c:type="const VipsRect*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unionrect" c:identifier="vips_rect_unionrect">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/rect.c"
             line="184">Fill @out with the bounding box of @r1 and @r2. @out can equal @r1 or @r2.</doc>
        <source-position filename="libvips/include/vips/rect.h" line="69"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="r1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/rect.c"
                 line="186">input rectangle 1</doc>
            <type name="Rect" c:type="const VipsRect*"/>
          </instance-parameter>
          <parameter name="r2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/rect.c"
                 line="187">input rectangle 2</doc>
            <type name="Rect" c:type="const VipsRect*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/rect.c"
                 line="188">output rectangle</doc>
            <type name="Rect" c:type="VipsRect*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <record name="RefString"
            c:type="VipsRefString"
            glib:type-name="VipsRefString"
            glib:get-type="vips_ref_string_get_type"
            c:symbol-prefix="ref_string">
      <source-position filename="libvips/include/vips/type.h" line="167"/>
      <field name="area" writable="1">
        <type name="Area" c:type="VipsArea"/>
      </field>
      <constructor name="new" c:identifier="vips_ref_string_new">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/type.c"
             line="544">Create a new refstring. These are reference-counted immutable strings, used
to store string data in vips image metadata.

Strings must be valid utf-8; use blob for binary data.

::: seealso
    [method@Area.unref].</doc>
        <source-position filename="libvips/include/vips/type.h" line="170"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="556">the new [struct@RefString], or `NULL` on
error.</doc>
          <type name="RefString" c:type="VipsRefString*"/>
        </return-value>
        <parameters>
          <parameter name="str" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="546">string to store</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get" c:identifier="vips_ref_string_get">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/type.c"
             line="575">Get a pointer to the private string inside a refstr. Handy for language
bindings.

::: seealso
    [func@value_get_ref_string].</doc>
        <source-position filename="libvips/include/vips/type.h" line="172"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="586">The C string held by @refstr.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="refstr" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="577">the [struct@RefString] to fetch from</doc>
            <type name="RefString" c:type="VipsRefString*"/>
          </instance-parameter>
          <parameter name="length"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/type.c"
                 line="578">return length here, optionally</doc>
            <type name="gsize" c:type="size_t*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <class name="Region"
           c:symbol-prefix="region"
           c:type="VipsRegion"
           parent="Object"
           glib:type-name="VipsRegion"
           glib:get-type="vips_region_get_type"
           glib:type-struct="RegionClass">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/region.c"
           line="107">A [class@Region] represents a small, rectangular part of an image.

You use regions to read pixels out of images without having to have the
whole image in memory at once.

A region can be a memory buffer, part of a memory-mapped file, part of some
other image, or part of some other region.

Regions must be created, used and freed all within the same thread, since
they can reference private per-thread caches. libvips sanity-checks region
ownership in various places, so you are likely to see [func@GLib.assert]
errors if you don't follow this rule.

There is API to transfer ownership of regions between threads, but
(hopefully) this is only needed within libvips, so we don't expose it.</doc>
      <source-position filename="libvips/include/vips/region.h" line="135"/>
      <constructor name="new" c:identifier="vips_region_new">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/region.c"
             line="479">Create a region. [class@Region] start out empty, you need to call
[method@Region.prepare] to fill them with pixels.

::: seealso
    [method@Region.prepare].</doc>
        <source-position filename="libvips/include/vips/region.h" line="141"/>
        <return-value transfer-ownership="full">
          <type name="Region" c:type="VipsRegion*"/>
        </return-value>
        <parameters>
          <parameter name="image" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="481">image to create this region on</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="black" c:identifier="vips_region_black">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/region.c"
             line="1010">Paints 0 into the valid part of @reg.

::: seealso
    [method@Region.paint].</doc>
        <source-position filename="libvips/include/vips/region.h" line="161"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="reg" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="1012">region to operate upon</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="buffer" c:identifier="vips_region_buffer">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/region.c"
             line="519">The region is transformed so that at least @r pixels are available as a
memory buffer that can be written to.</doc>
        <source-position filename="libvips/include/vips/region.h" line="144"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/region.c"
               line="527">0 on success, or -1 for error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="reg" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="521">region to operate upon</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </instance-parameter>
          <parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="522">[struct@Rect] of pixels you need to be able to address</doc>
            <type name="Rect" c:type="const VipsRect*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="vips_region_copy">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/region.c"
             line="1025">Copy from one region to another. Copy area @r from inside @reg to @dest,
positioning the area of pixels at @x, @y. The two regions must have pixels
which are the same size.

::: seealso
    [method@Region.paint].</doc>
        <source-position filename="libvips/include/vips/region.h" line="163"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="reg" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="1027">source region</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </instance-parameter>
          <parameter name="dest"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="1028">destination region</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </parameter>
          <parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="1029">[struct@Rect] of pixels you need to copy</doc>
            <type name="Rect" c:type="const VipsRect*"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="1030">position of @r in @dest</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="1031">position of @r in @dest</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="equalsregion" c:identifier="vips_region_equalsregion">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/region.c"
             line="780">Do two regions point to the same piece of image? ie.

```c
VIPS_REGION_ADDR(reg1, x, y) == VIPS_REGION_ADDR(reg2, x, y) &amp;&amp;
*VIPS_REGION_ADDR(reg1, x, y) ==
    *VIPS_REGION_ADDR(reg2, x, y) for all x, y, reg1, reg2.
```</doc>
        <source-position filename="libvips/include/vips/region.h" line="151"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/region.c"
               line="793">non-zero on equality.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="reg1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="782">region to test</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </instance-parameter>
          <parameter name="reg2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="783">region to test</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </parameter>
        </parameters>
      </method>
      <method name="fetch" c:identifier="vips_region_fetch">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/region.c"
             line="1918">Generate an area of pixels and return a copy. The result must be freed
with [func@GLib.free]. The requested area must be completely inside the
image.

This is equivalent to [method@Region.prepare], followed by a memcpy. It is
convenient for language bindings.</doc>
        <source-position filename="libvips/include/vips/region.h" line="179"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/region.c"
               line="1933">A copy of the pixel data.</doc>
          <type name="Pel" c:type="VipsPel*"/>
        </return-value>
        <parameters>
          <instance-parameter name="region" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="1920">region to fetch pixels from</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </instance-parameter>
          <parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="1921">area of pixels to fetch</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="top" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="1922">area of pixels to fetch</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="1923">area of pixels to fetch</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="1924">area of pixels to fetch</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <type name="gsize" c:type="size_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="height" c:identifier="vips_region_height">
        <source-position filename="libvips/include/vips/region.h" line="184"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/region.c"
               line="1999">Height of the pixels held in region.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="region" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="1997">fetch height from this</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="image" c:identifier="vips_region_image">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/region.c"
             line="588">The region is transformed so that at least @r pixels are available to be
read from the image. The image needs to be a memory buffer or represent a
file on disc that has been mapped or can be mapped.</doc>
        <source-position filename="libvips/include/vips/region.h" line="146"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/region.c"
               line="597">0 on success, or -1 for error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="reg" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="590">region to operate upon</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </instance-parameter>
          <parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="591">[struct@Rect] of pixels you need to be able to address</doc>
            <type name="Rect" c:type="const VipsRect*"/>
          </parameter>
        </parameters>
      </method>
      <method name="invalidate" c:identifier="vips_region_invalidate">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/region.c"
             line="2007">Mark a region as containing invalid pixels. Calling this function means
that the next time [method@Region.prepare] is called, the region will be
recalculated.

This is faster than calling [method@Image.invalidate_all], but obviously only
affects a single region.

::: seealso
    [method@Image.invalidate_all], [method@Region.prepare].</doc>
        <source-position filename="libvips/include/vips/region.h" line="187"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="reg" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="2009">region to invalidate</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="paint" c:identifier="vips_region_paint">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/region.c"
             line="888">Paints @value into @reg covering rectangle @r.
@r is clipped against
@reg-&gt;valid.

For int images, @value is
passed to [`memset()`](man:memset(3)), so it usually needs to be 0 or 255. For float images,
value is cast to a float and copied in to each band element.

@r is clipped against
@reg-&gt;valid.

::: seealso
    [method@Region.black].</doc>
        <source-position filename="libvips/include/vips/region.h" line="156"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="reg" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="890">region to operate upon</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </instance-parameter>
          <parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="891">area to paint</doc>
            <type name="Rect" c:type="const VipsRect*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="892">value to paint</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="paint_pel" c:identifier="vips_region_paint_pel">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/region.c"
             line="958">Paints @ink into @reg covering rectangle @r. @r is clipped against
@reg-&gt;valid.

@ink should be a byte array of the same size as an image pixel containing
the binary value to write into the pixels.

::: seealso
    [method@Region.paint].</doc>
        <source-position filename="libvips/include/vips/region.h" line="158"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="reg" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="960">region to operate upon</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </instance-parameter>
          <parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="961">area to paint</doc>
            <type name="Rect" c:type="const VipsRect*"/>
          </parameter>
          <parameter name="ink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="962">value to paint</doc>
            <type name="Pel" c:type="const VipsPel*"/>
          </parameter>
        </parameters>
      </method>
      <method name="position" c:identifier="vips_region_position">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/region.c"
             line="803">Set the position of a region. This only affects reg-&gt;valid, ie. the way
pixels are addressed, not reg-&gt;data, the pixels which are addressed. Clip
against the size of the image. Do not allow negative positions, or
positions outside the image.</doc>
        <source-position filename="libvips/include/vips/region.h" line="153"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/region.c"
               line="814">0 on success, or -1 for error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="reg" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="805">region to operate upon</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="806">position to move to</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="807">position to move to</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepare" c:identifier="vips_region_prepare">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/region.c"
             line="1624">[method@Region.prepare] fills @reg with pixels. After calling,
you can address at least the area @r with [func@REGION_ADDR] and get
valid pixels.

[method@Region.prepare] runs in-line, that is, computation is done by
the calling thread, no new threads are involved, and computation
blocks until the pixels are ready.

Use [method@Image.sink_screen] to calculate an area of pixels in the
background.

::: seealso
    [method@Image.sink_screen], [method@Region.prepare_to].</doc>
        <source-position filename="libvips/include/vips/region.h" line="173"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/region.c"
               line="1643">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="reg" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="1626">region to prepare</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </instance-parameter>
          <parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="1627">[struct@Rect] of pixels you need to be able to address</doc>
            <type name="Rect" c:type="const VipsRect*"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepare_to" c:identifier="vips_region_prepare_to">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/region.c"
             line="1750">Like [method@Region.prepare]: fill @reg with the pixels in area @r.

Unlike [method@Region.prepare], rather than writing the result to @reg, the
pixels are written into @dest at offset @x, @y.

Also unlike [method@Region.prepare], @dest is not set up for writing for
you with [method@Region.buffer]. You can
point @dest at anything, and pixels really will be written there.
This makes [method@Region.prepare_to] useful for making the ends of
pipelines.

::: seealso
    [method@Region.prepare], [method@Image.sink_disc].</doc>
        <source-position filename="libvips/include/vips/region.h" line="175"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/region.c"
               line="1772">0 on success, or -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="reg" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="1752">region to prepare</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </instance-parameter>
          <parameter name="dest" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="1753">region to write to</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </parameter>
          <parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="1754">[struct@Rect] of pixels you need to be able to address</doc>
            <type name="Rect" c:type="const VipsRect*"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="1755">position of @r in @dest</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="1756">position of @r in @dest</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="region" c:identifier="vips_region_region">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/region.c"
             line="668">Make [func@REGION_ADDR] on @reg go to @dest instead.

@r is the part of @reg which you want to be able to address (this
effectively becomes the valid field), (@x, @y) is the top LH corner of the
corresponding area in @dest.

Performs all clipping necessary to ensure that @reg-&gt;valid is indeed
valid.

If the region we attach to is moved or destroyed, we can be left with
dangling pointers! If the region we attach to is on another image, the
two images must have the same sizeof(pel).</doc>
        <source-position filename="libvips/include/vips/region.h" line="148"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/region.c"
               line="689">0 on success, or -1 for error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="reg" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="670">region to operate upon</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </instance-parameter>
          <parameter name="dest" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="671">region to connect to</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </parameter>
          <parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="672">[struct@Rect] of pixels you need to be able to address</doc>
            <type name="Rect" c:type="const VipsRect*"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="673">position of @r in @dest</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="674">position of @r in @dest</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="shrink"
              c:identifier="vips_region_shrink"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/region.c"
             line="1575">Write the pixels @target in @to from the x2 larger area in @from.
Non-complex uncoded images and LABQ only. Images with alpha (see
[method@Image.hasalpha]) shrink with pixels scaled by alpha to avoid fringing.

This is a compatibility stub that just calls [method@Region.shrink_method].

::: seealso
    [method@Region.shrink_method].</doc>
        <source-position filename="libvips/include/vips/region.h" line="169"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="from" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="1577">source region</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </instance-parameter>
          <parameter name="to"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="1578">destination region</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="1579">[struct@Rect] of pixels you need to copy</doc>
            <type name="Rect" c:type="const VipsRect*"/>
          </parameter>
        </parameters>
      </method>
      <method name="shrink_method" c:identifier="vips_region_shrink_method">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/region.c"
             line="1536">Write the pixels @target in @to from the x2 larger area in @from.
Non-complex uncoded images and LABQ only.

@method selects the method used to do the 2x2 shrink.

::: seealso
    [method@Region.copy].</doc>
        <source-position filename="libvips/include/vips/region.h" line="166"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="from" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="1538">source region</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </instance-parameter>
          <parameter name="to"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="1539">destination region</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="1540">[struct@Rect] of pixels you need to copy</doc>
            <type name="Rect" c:type="const VipsRect*"/>
          </parameter>
          <parameter name="method" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="1541">method to use when generating target pixels</doc>
            <type name="RegionShrink" c:type="VipsRegionShrink"/>
          </parameter>
        </parameters>
      </method>
      <method name="width" c:identifier="vips_region_width">
        <source-position filename="libvips/include/vips/region.h" line="182"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/region.c"
               line="1987">Width of the pixels held in region.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="region" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/region.c"
                 line="1985">fetch width from this</doc>
            <type name="Region" c:type="VipsRegion*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent_object">
        <type name="Object" c:type="VipsObject"/>
      </field>
      <field name="im">
        <type name="Image" c:type="VipsImage*"/>
      </field>
      <field name="valid">
        <type name="Rect" c:type="VipsRect"/>
      </field>
      <field name="type" introspectable="0" readable="0" private="1">
        <type c:type="RegionType"/>
      </field>
      <field name="data" readable="0" private="1">
        <type name="Pel" c:type="VipsPel*"/>
      </field>
      <field name="bpl" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="seq" readable="0" private="1">
        <type name="gpointer" c:type="void*"/>
      </field>
      <field name="thread" readable="0" private="1">
        <type name="GLib.Thread" c:type="GThread*"/>
      </field>
      <field name="window" introspectable="0" readable="0" private="1">
        <type c:type="VipsWindow*"/>
      </field>
      <field name="buffer" introspectable="0" readable="0" private="1">
        <type c:type="VipsBuffer*"/>
      </field>
      <field name="invalid" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
    </class>
    <record name="RegionClass"
            c:type="VipsRegionClass"
            glib:is-gtype-struct-for="Region">
      <source-position filename="libvips/include/vips/region.h" line="135"/>
      <field name="parent_class">
        <type name="ObjectClass" c:type="VipsObjectClass"/>
      </field>
    </record>
    <enumeration name="RegionShrink"
                 glib:type-name="VipsRegionShrink"
                 glib:get-type="vips_region_shrink_get_type"
                 c:type="VipsRegionShrink">
      <doc xml:space="preserve"
           filename="libvips/include/vips/region.h"
           line="65">How to calculate the output pixels when shrinking a 2x2 region.

Images with alpha (see [method@Image.hasalpha]) always shrink with
[enum@Vips.RegionShrink.MEAN] and pixels scaled by alpha to avoid fringing.

Set the image interpretation to [enum@Vips.Interpretation.MULTIBAND] to
treat all bands equally.</doc>
      <member name="mean"
              value="0"
              c:identifier="VIPS_REGION_SHRINK_MEAN"
              glib:nick="mean"
              glib:name="VIPS_REGION_SHRINK_MEAN">
        <doc xml:space="preserve"
             filename="libvips/include/vips/region.h"
             line="67">use the average</doc>
      </member>
      <member name="median"
              value="1"
              c:identifier="VIPS_REGION_SHRINK_MEDIAN"
              glib:nick="median"
              glib:name="VIPS_REGION_SHRINK_MEDIAN">
        <doc xml:space="preserve"
             filename="libvips/include/vips/region.h"
             line="68">use the median</doc>
      </member>
      <member name="mode"
              value="2"
              c:identifier="VIPS_REGION_SHRINK_MODE"
              glib:nick="mode"
              glib:name="VIPS_REGION_SHRINK_MODE">
        <doc xml:space="preserve"
             filename="libvips/include/vips/region.h"
             line="69">use the mode</doc>
      </member>
      <member name="max"
              value="3"
              c:identifier="VIPS_REGION_SHRINK_MAX"
              glib:nick="max"
              glib:name="VIPS_REGION_SHRINK_MAX">
        <doc xml:space="preserve"
             filename="libvips/include/vips/region.h"
             line="70">use the maximum</doc>
      </member>
      <member name="min"
              value="4"
              c:identifier="VIPS_REGION_SHRINK_MIN"
              glib:nick="min"
              glib:name="VIPS_REGION_SHRINK_MIN">
        <doc xml:space="preserve"
             filename="libvips/include/vips/region.h"
             line="71">use the minimum</doc>
      </member>
      <member name="nearest"
              value="5"
              c:identifier="VIPS_REGION_SHRINK_NEAREST"
              glib:nick="nearest"
              glib:name="VIPS_REGION_SHRINK_NEAREST">
        <doc xml:space="preserve"
             filename="libvips/include/vips/region.h"
             line="72">use the top-left pixel</doc>
      </member>
    </enumeration>
    <callback name="RegionWrite" c:type="VipsRegionWrite">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/sinkdisc.c"
           line="470">The function should write the pixels in @area from @region. @a is the
value passed into [method@Image.sink_disc].

::: seealso
    [method@Image.sink_disc].</doc>
      <source-position filename="libvips/include/vips/generate.h" line="40"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/sinkdisc.c"
             line="482">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="region" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/sinkdisc.c"
               line="472">get pixels from here</doc>
          <type name="Region" c:type="VipsRegion*"/>
        </parameter>
        <parameter name="area" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/sinkdisc.c"
               line="473">area to write</doc>
          <type name="Rect" c:type="VipsRect*"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/sinkdisc.c"
               line="474">client data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <function-macro name="SBUF" c:identifier="VIPS_SBUF" introspectable="0">
      <source-position filename="libvips/include/vips/sbuf.h" line="45"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="SBUF_BUFFER_SIZE"
              value="4096"
              c:type="VIPS_SBUF_BUFFER_SIZE">
      <source-position filename="libvips/include/vips/sbuf.h" line="59"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="SBUF_CLASS"
                    c:identifier="VIPS_SBUF_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/sbuf.h" line="48"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="SBUF_FETCH"
                    c:identifier="VIPS_SBUF_FETCH"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/sbuf.c"
           line="308">After a successful [func@SBUF_REQUIRE], you can use this require times
to fetch characters of input.</doc>
      <source-position filename="libvips/include/vips/sbuf.h" line="128"/>
      <parameters>
        <parameter name="S">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="SBUF_GETC"
                    c:identifier="VIPS_SBUF_GETC"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/sbuf.c"
           line="194">Fetch the next character from the source.</doc>
      <source-position filename="libvips/include/vips/sbuf.h" line="109"/>
      <parameters>
        <parameter name="S">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="SBUF_GET_CLASS"
                    c:identifier="VIPS_SBUF_GET_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/sbuf.h" line="55"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="SBUF_PEEK"
                    c:identifier="VIPS_SBUF_PEEK"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/sbuf.c"
           line="298">After a successful [func@SBUF_REQUIRE], you can index this to get
require characters of input.</doc>
      <source-position filename="libvips/include/vips/sbuf.h" line="127"/>
      <parameters>
        <parameter name="S">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="SBUF_REQUIRE"
                    c:identifier="VIPS_SBUF_REQUIRE"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/sbuf.c"
           line="287">Make sure at least @require characters are available for
[func@SBUF_PEEK] and [func@SBUF_FETCH].</doc>
      <source-position filename="libvips/include/vips/sbuf.h" line="123"/>
      <parameters>
        <parameter name="S">
        </parameter>
        <parameter name="R">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="SBUF_UNGETC"
                    c:identifier="VIPS_SBUF_UNGETC"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/sbuf.c"
           line="221">The opposite of [method@Sbuf.getc]: undo the previous getc.

unget more than one character is undefined. Unget at the start of the file
does nothing.</doc>
      <source-position filename="libvips/include/vips/sbuf.h" line="115"/>
      <parameters>
        <parameter name="S">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="SETSTR"
                    c:identifier="VIPS_SETSTR"
                    introspectable="0">
      <source-position filename="libvips/include/vips/memory.h" line="52"/>
      <parameters>
        <parameter name="S">
        </parameter>
        <parameter name="V">
        </parameter>
      </parameters>
    </function-macro>
    <callback name="SListFold2Fn" c:type="VipsSListFold2Fn">
      <source-position filename="libvips/include/vips/basic.h" line="103"/>
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="item"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="c"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="SListMap2Fn" c:type="VipsSListMap2Fn">
      <source-position filename="libvips/include/vips/basic.h" line="99"/>
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="item"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="SListMap4Fn" c:type="VipsSListMap4Fn">
      <source-position filename="libvips/include/vips/basic.h" line="101"/>
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="item"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="c"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="d"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <function-macro name="SOURCE"
                    c:identifier="VIPS_SOURCE"
                    introspectable="0">
      <source-position filename="libvips/include/vips/connection.h"
                       line="103"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="SOURCE_CLASS"
                    c:identifier="VIPS_SOURCE_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/connection.h"
                       line="106"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="SOURCE_CUSTOM"
                    c:identifier="VIPS_SOURCE_CUSTOM"
                    introspectable="0">
      <source-position filename="libvips/include/vips/connection.h"
                       line="253"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="SOURCE_CUSTOM_CLASS"
                    c:identifier="VIPS_SOURCE_CUSTOM_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/connection.h"
                       line="256"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="SOURCE_CUSTOM_GET_CLASS"
                    c:identifier="VIPS_SOURCE_CUSTOM_GET_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/connection.h"
                       line="263"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="SOURCE_GET_CLASS"
                    c:identifier="VIPS_SOURCE_GET_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/connection.h"
                       line="113"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="SOURCE_G_INPUT_STREAM"
                    c:identifier="VIPS_SOURCE_G_INPUT_STREAM"
                    introspectable="0">
      <source-position filename="libvips/include/vips/connection.h"
                       line="334"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="SOURCE_G_INPUT_STREAM_CLASS"
                    c:identifier="VIPS_SOURCE_G_INPUT_STREAM_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/connection.h"
                       line="337"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="SOURCE_G_INPUT_STREAM_GET_CLASS"
                    c:identifier="VIPS_SOURCE_G_INPUT_STREAM_GET_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/connection.h"
                       line="344"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="SWAP" c:identifier="VIPS_SWAP" introspectable="0">
      <source-position filename="libvips/include/vips/util.h" line="99"/>
      <parameters>
        <parameter name="TYPE">
        </parameter>
        <parameter name="A">
        </parameter>
        <parameter name="B">
        </parameter>
      </parameters>
    </function-macro>
    <record name="SaveString"
            c:type="VipsSaveString"
            glib:type-name="VipsSaveString"
            glib:get-type="vips_save_string_get_type"
            c:symbol-prefix="save_string">
      <source-position filename="libvips/include/vips/type.h" line="156"/>
      <field name="s" writable="1">
        <type name="utf8" c:type="char*"/>
      </field>
    </record>
    <class name="Sbuf"
           c:symbol-prefix="sbuf"
           c:type="VipsSbuf"
           parent="Object"
           glib:type-name="VipsSbuf"
           glib:get-type="vips_sbuf_get_type"
           glib:type-struct="SbufClass">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/sbuf.c"
           line="58">A [class@Sbuf] provides a buffered reading interface for a [class@Source].

You can fetch lines of text, skip whitespace, and so on.

It is useful for implementing things like CSV readers, for example.</doc>
      <source-position filename="libvips/include/vips/sbuf.h" line="96"/>
      <constructor name="new_from_source"
                   c:identifier="vips_sbuf_new_from_source">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/sbuf.c"
             line="98">Create a [class@Sbuf] wrapping a source.</doc>
        <source-position filename="libvips/include/vips/sbuf.h" line="102"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/sbuf.c"
               line="104">a new [class@Sbuf]</doc>
          <type name="Sbuf" c:type="VipsSbuf*"/>
        </return-value>
        <parameters>
          <parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/sbuf.c"
                 line="100">source to operate on</doc>
            <type name="Source" c:type="VipsSource*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_line" c:identifier="vips_sbuf_get_line">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/sbuf.c"
             line="318">Fetch the next line of text from @sbuf and return it. The end of
line character (or characters, for DOS files) are removed, and the string
is terminated with a null (`\0` character).

Returns `NULL` on end of file or read error.

If the line is longer than some arbitrary (but large) limit, it is
truncated. If you need to be able to read very long lines, use the
slower [method@Sbuf.get_line_copy].

The return value is owned by @sbuf and must not be freed. It
is valid until the next get call to @sbuf.</doc>
        <source-position filename="libvips/include/vips/sbuf.h" line="131"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/sbuf.c"
               line="335">the next line of text, or `NULL` on EOF or read error.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="sbuf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/sbuf.c"
                 line="320">source to operate on</doc>
            <type name="Sbuf" c:type="VipsSbuf*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_line_copy" c:identifier="vips_sbuf_get_line_copy">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/sbuf.c"
             line="388">Fetch the next line of text from @sbuf and return it. The end of
line character (or characters, for DOS files) are removed, and the string
is terminated with a null (`\0` character).

The return result must be freed with [func@GLib.free].

This is slower than [method@Sbuf.get_line], but can work with lines of
any length.</doc>
        <source-position filename="libvips/include/vips/sbuf.h" line="133"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/sbuf.c"
               line="401">the next line of text, or `NULL` on EOF or read error.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="sbuf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/sbuf.c"
                 line="390">source to operate on</doc>
            <type name="Sbuf" c:type="VipsSbuf*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_non_whitespace"
              c:identifier="vips_sbuf_get_non_whitespace">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/sbuf.c"
             line="448">Fetch the next chunk of non-whitespace text from the source, and
null-terminate it.

After this, the next getc will be the first char of the next block of
whitespace (or EOF).

If the first getc is whitespace, stop instantly and return the empty
string.

If the item is longer than some arbitrary (but large) limit, it is
truncated.

The return value is owned by @sbuf and must not be freed. It
is valid until the next get call to @sbuf.</doc>
        <source-position filename="libvips/include/vips/sbuf.h" line="135"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/sbuf.c"
               line="467">the next block of non-whitespace, or `NULL` on EOF or read error.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="sbuf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/sbuf.c"
                 line="450">source to operate on</doc>
            <type name="Sbuf" c:type="VipsSbuf*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="getc" c:identifier="vips_sbuf_getc">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/sbuf.c"
             line="172">Fetch the next character from the source.

If you can, use the macro [func@SBUF_GETC] instead for speed.</doc>
        <source-position filename="libvips/include/vips/sbuf.h" line="108"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/sbuf.c"
               line="180">the next char from @sbuf, -1 on read error or EOF.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="sbuf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/sbuf.c"
                 line="174">source to operate on</doc>
            <type name="Sbuf" c:type="VipsSbuf*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="require" c:identifier="vips_sbuf_require">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/sbuf.c"
             line="231">Make sure there are at least @require bytes of readahead available.</doc>
        <source-position filename="libvips/include/vips/sbuf.h" line="122"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/sbuf.c"
               line="238">0 on success, -1 on error or EOF.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="sbuf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/sbuf.c"
                 line="233">source to operate on</doc>
            <type name="Sbuf" c:type="VipsSbuf*"/>
          </instance-parameter>
          <parameter name="require" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/sbuf.c"
                 line="234">make sure we have at least this many chars available</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="skip_whitespace" c:identifier="vips_sbuf_skip_whitespace">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/sbuf.c"
             line="499">After this, the next getc will be the first char of the next block of
non-whitespace (or EOF).

Also skip comments, ie. from any '#' character to the end of the line.</doc>
        <source-position filename="libvips/include/vips/sbuf.h" line="137"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/sbuf.c"
               line="508">0 on success, or -1 on EOF.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="sbuf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/sbuf.c"
                 line="501">source to operate on</doc>
            <type name="Sbuf" c:type="VipsSbuf*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unbuffer" c:identifier="vips_sbuf_unbuffer">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/sbuf.c"
             line="125">Discard the input buffer and reset the read point. You must call this
before using read or seek on the underlying [class@Source] class.</doc>
        <source-position filename="libvips/include/vips/sbuf.h" line="105"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sbuf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/sbuf.c"
                 line="127">source to operate on</doc>
            <type name="Sbuf" c:type="VipsSbuf*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ungetc" c:identifier="vips_sbuf_ungetc">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/sbuf.c"
             line="203">The opposite of [method@Sbuf.getc]: undo the previous getc.

unget more than one character is undefined. Unget at the start of the file
does nothing.

If you can, use the macro [func@SBUF_UNGETC] instead for speed.</doc>
        <source-position filename="libvips/include/vips/sbuf.h" line="114"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sbuf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/sbuf.c"
                 line="205">source to operate on</doc>
            <type name="Sbuf" c:type="VipsSbuf*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="input" writable="1" transfer-ownership="none">
        <type name="Source"/>
      </property>
      <field name="parent_object">
        <type name="Object" c:type="VipsObject"/>
      </field>
      <field name="source" readable="0" private="1">
        <type name="Source" c:type="VipsSource*"/>
      </field>
      <field name="input_buffer" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4097">
          <type name="guint8" c:type="unsigned char"/>
        </array>
      </field>
      <field name="chars_in_buffer" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="read_point" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="line" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4097">
          <type name="guint8" c:type="unsigned char"/>
        </array>
      </field>
    </class>
    <record name="SbufClass"
            c:type="VipsSbufClass"
            glib:is-gtype-struct-for="Sbuf">
      <source-position filename="libvips/include/vips/sbuf.h" line="96"/>
      <field name="parent_class">
        <type name="ObjectClass" c:type="VipsObjectClass"/>
      </field>
    </record>
    <enumeration name="SdfShape"
                 glib:type-name="VipsSdfShape"
                 glib:get-type="vips_sdf_shape_get_type"
                 c:type="VipsSdfShape">
      <doc xml:space="preserve"
           filename="libvips/create/create.c"
           line="68">The SDF to generate,

::: seealso
    [ctor@Image.sdf].</doc>
      <member name="circle"
              value="0"
              c:identifier="VIPS_SDF_SHAPE_CIRCLE"
              glib:nick="circle"
              glib:name="VIPS_SDF_SHAPE_CIRCLE">
        <doc xml:space="preserve"
             filename="libvips/create/create.c"
             line="70">a circle at @a, radius @r</doc>
      </member>
      <member name="box"
              value="1"
              c:identifier="VIPS_SDF_SHAPE_BOX"
              glib:nick="box"
              glib:name="VIPS_SDF_SHAPE_BOX">
        <doc xml:space="preserve"
             filename="libvips/create/create.c"
             line="71">a box from @a to @b</doc>
      </member>
      <member name="rounded_box"
              value="2"
              c:identifier="VIPS_SDF_SHAPE_ROUNDED_BOX"
              glib:nick="rounded-box"
              glib:name="VIPS_SDF_SHAPE_ROUNDED_BOX">
        <doc xml:space="preserve"
             filename="libvips/create/create.c"
             line="72">a box with rounded @corners from @a to @b</doc>
      </member>
      <member name="line"
              value="3"
              c:identifier="VIPS_SDF_SHAPE_LINE"
              glib:nick="line"
              glib:name="VIPS_SDF_SHAPE_LINE">
        <doc xml:space="preserve"
             filename="libvips/create/create.c"
             line="73">a line from @a to @b</doc>
      </member>
    </enumeration>
    <record name="Semaphore" c:type="VipsSemaphore">
      <source-position filename="libvips/include/vips/semaphore.h" line="57"/>
      <field name="name" readable="0" private="1">
        <type name="utf8" c:type="char*"/>
      </field>
      <field name="v" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="mutex" readable="0" private="1">
        <type name="GLib.Mutex" c:type="GMutex"/>
      </field>
      <field name="cond" readable="0" private="1">
        <type name="GLib.Cond" c:type="GCond"/>
      </field>
      <method name="destroy" c:identifier="vips_semaphore_destroy">
        <source-position filename="libvips/include/vips/semaphore.h"
                         line="70"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="s" transfer-ownership="none">
            <type name="Semaphore" c:type="VipsSemaphore*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="down" c:identifier="vips_semaphore_down">
        <source-position filename="libvips/include/vips/semaphore.h"
                         line="64"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="s" transfer-ownership="none">
            <type name="Semaphore" c:type="VipsSemaphore*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="down_timeout" c:identifier="vips_semaphore_down_timeout">
        <source-position filename="libvips/include/vips/semaphore.h"
                         line="68"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="s" transfer-ownership="none">
            <type name="Semaphore" c:type="VipsSemaphore*"/>
          </instance-parameter>
          <parameter name="timeout" transfer-ownership="none">
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="downn" c:identifier="vips_semaphore_downn">
        <source-position filename="libvips/include/vips/semaphore.h"
                         line="66"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="s" transfer-ownership="none">
            <type name="Semaphore" c:type="VipsSemaphore*"/>
          </instance-parameter>
          <parameter name="n" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="vips_semaphore_init">
        <source-position filename="libvips/include/vips/semaphore.h"
                         line="72"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="s" transfer-ownership="none">
            <type name="Semaphore" c:type="VipsSemaphore*"/>
          </instance-parameter>
          <parameter name="v" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="up" c:identifier="vips_semaphore_up">
        <source-position filename="libvips/include/vips/semaphore.h"
                         line="60"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="s" transfer-ownership="none">
            <type name="Semaphore" c:type="VipsSemaphore*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="upn" c:identifier="vips_semaphore_upn">
        <source-position filename="libvips/include/vips/semaphore.h"
                         line="62"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="s" transfer-ownership="none">
            <type name="Semaphore" c:type="VipsSemaphore*"/>
          </instance-parameter>
          <parameter name="n" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <callback name="SinkNotify" c:type="VipsSinkNotify">
      <source-position filename="libvips/include/vips/generate.h" line="54"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="im" transfer-ownership="none">
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="rect" transfer-ownership="none">
          <type name="Rect" c:type="VipsRect*"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="Size"
                 glib:type-name="VipsSize"
                 glib:get-type="vips_size_get_type"
                 c:type="VipsSize">
      <doc xml:space="preserve"
           filename="libvips/resample/resample.c"
           line="55">Controls whether an operation should upsize, downsize, both up and
downsize, or force a size.

::: seealso
    [ctor@Image.thumbnail].</doc>
      <member name="both"
              value="0"
              c:identifier="VIPS_SIZE_BOTH"
              glib:nick="both"
              glib:name="VIPS_SIZE_BOTH">
        <doc xml:space="preserve"
             filename="libvips/resample/resample.c"
             line="57">size both up and down</doc>
      </member>
      <member name="up"
              value="1"
              c:identifier="VIPS_SIZE_UP"
              glib:nick="up"
              glib:name="VIPS_SIZE_UP">
        <doc xml:space="preserve"
             filename="libvips/resample/resample.c"
             line="58">only upsize</doc>
      </member>
      <member name="down"
              value="2"
              c:identifier="VIPS_SIZE_DOWN"
              glib:nick="down"
              glib:name="VIPS_SIZE_DOWN">
        <doc xml:space="preserve"
             filename="libvips/resample/resample.c"
             line="59">only downsize</doc>
      </member>
      <member name="force"
              value="3"
              c:identifier="VIPS_SIZE_FORCE"
              glib:nick="force"
              glib:name="VIPS_SIZE_FORCE">
        <doc xml:space="preserve"
             filename="libvips/resample/resample.c"
             line="60">force size, that is, break aspect ratio</doc>
      </member>
    </enumeration>
    <class name="Source"
           c:symbol-prefix="source"
           c:type="VipsSource"
           parent="Connection"
           glib:type-name="VipsSource"
           glib:get-type="vips_source_get_type"
           glib:type-struct="SourceClass">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/source.c"
           line="77">A [class@Source] provides a unified interface for reading, seeking, and
mapping data, regardless of the underlying source type.

This source can originate from something like a socket, file or memory
area.

During the header phase, we save data from unseekable sources in a buffer
so readers can rewind and read again. We don't buffer data during the
decode stage.</doc>
      <source-position filename="libvips/include/vips/connection.h"
                       line="206"/>
      <constructor name="new_from_blob"
                   c:identifier="vips_source_new_from_blob">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/source.c"
             line="491">Create a source attached to an area of memory.</doc>
        <source-position filename="libvips/include/vips/connection.h"
                         line="216"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/source.c"
               line="497">a new source.</doc>
          <type name="Source" c:type="VipsSource*"/>
        </return-value>
        <parameters>
          <parameter name="blob" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/source.c"
                 line="493">memory area to load</doc>
            <type name="Blob" c:type="VipsBlob*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_descriptor"
                   c:identifier="vips_source_new_from_descriptor">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/source.c"
             line="422">Create an source attached to a file descriptor. @descriptor is
closed with [`close()`](man:close(2)) when source is finalized.</doc>
        <source-position filename="libvips/include/vips/connection.h"
                         line="212"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/source.c"
               line="429">a new source.</doc>
          <type name="Source" c:type="VipsSource*"/>
        </return-value>
        <parameters>
          <parameter name="descriptor" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/source.c"
                 line="424">read from this file descriptor</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_file"
                   c:identifier="vips_source_new_from_file">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/source.c"
             line="453">Create a source attached to a file.

If this descriptor does not support mmap and the source is
used with a loader that can only work from memory, then the data will be
automatically read into memory to EOF before the loader starts. This can
produce high memory use if the descriptor represents a large object.

Use [func@pipe_read_limit_set] to limit the size of object that
will be read in this way. The default is 1GB.</doc>
        <source-position filename="libvips/include/vips/connection.h"
                         line="214"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/source.c"
               line="467">a new source.</doc>
          <type name="Source" c:type="VipsSource*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/source.c"
                 line="455">read from this filename</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_memory"
                   c:identifier="vips_source_new_from_memory">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/source.c"
             line="560">Create a source attached to an area of memory.

You must not free @data while the source is active.</doc>
        <source-position filename="libvips/include/vips/connection.h"
                         line="220"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/source.c"
               line="569">a new source.</doc>
          <type name="Source" c:type="VipsSource*"/>
        </return-value>
        <parameters>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/source.c"
                 line="562">memory area to load</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/source.c"
                 line="563">size of memory area</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_options"
                   c:identifier="vips_source_new_from_options">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/source.c"
             line="593">Create a source from an option string.</doc>
        <source-position filename="libvips/include/vips/connection.h"
                         line="222"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/source.c"
               line="599">a new source.</doc>
          <type name="Source" c:type="VipsSource*"/>
        </return-value>
        <parameters>
          <parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/source.c"
                 line="595">option string</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_target"
                   c:identifier="vips_source_new_from_target">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/source.c"
             line="520">Create a source from a temp target that has been written to.</doc>
        <source-position filename="libvips/include/vips/connection.h"
                         line="218"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/source.c"
               line="526">a new source.</doc>
          <type name="Source" c:type="VipsSource*"/>
        </return-value>
        <parameters>
          <parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/source.c"
                 line="522">build the source from this target</doc>
            <type name="Target" c:type="VipsTarget*"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="read" invoker="read">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/source.c"
             line="772">Read up to @length bytes from @source and store the bytes in @buffer.
Return the number of bytes actually read. If all bytes have been read from
the file, return 0.

Arguments exactly as [`read()`](man:read(2)).</doc>
        <source-position filename="libvips/include/vips/connection.h"
                         line="193"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/source.c"
               line="784">the number of bytes read, 0 on end of file, -1 on error.</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/source.c"
                 line="774">source to operate on</doc>
            <type name="Source" c:type="VipsSource*"/>
          </instance-parameter>
          <parameter name="buffer"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/source.c"
                 line="775">store bytes here</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/source.c"
                 line="776">length of @buffer in bytes</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="seek" invoker="seek">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/source.c"
             line="1165">Move the file read position. You can't call this after pixel decode starts.
The arguments are exactly as [`lseek()`](man:lseek(2)).</doc>
        <source-position filename="libvips/include/vips/connection.h"
                         line="204"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/source.c"
               line="1174">the new file position, or -1 on error.</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/source.c"
                 line="1167">source to operate on</doc>
            <type name="Source" c:type="VipsSource*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/source.c"
                 line="1168">seek by this offset</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="whence" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/source.c"
                 line="1169">seek relative to this point</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="decode" c:identifier="vips_source_decode">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/source.c"
             line="716">Signal the end of header read and the start of the pixel decode phase.
After this, you can no longer seek on this source.

Loaders should call this at the end of header read.

::: seealso
    [method@Source.unminimise].</doc>
        <source-position filename="libvips/include/vips/connection.h"
                         line="229"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/source.c"
               line="728">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/source.c"
                 line="718">source to operate on</doc>
            <type name="Source" c:type="VipsSource*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_file" c:identifier="vips_source_is_file">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/source.c"
             line="1046">Test if this source is a simple file with support for seek. Named pipes,
for example, will fail this test. If `TRUE`, you can use
[method@Connection.filename] to find the filename.

Use this to add basic source support for older loaders which can only work
on files.</doc>
        <source-position filename="libvips/include/vips/connection.h"
                         line="235"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/source.c"
               line="1057">`TRUE` if the source is a simple file.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/source.c"
                 line="1048">source to operate on</doc>
            <type name="Source" c:type="VipsSource*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_mappable" c:identifier="vips_source_is_mappable">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/source.c"
             line="1020">Some sources can be efficiently mapped into memory.
You can still use [method@Source.map] if this function returns `FALSE`,
but it will be slow.</doc>
        <source-position filename="libvips/include/vips/connection.h"
                         line="233"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/source.c"
               line="1028">`TRUE` if the source can be efficiently mapped into memory.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/source.c"
                 line="1022">source to operate on</doc>
            <type name="Source" c:type="VipsSource*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="length" c:identifier="vips_source_length">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/source.c"
             line="1296">Return the length in bytes of the source. Unseekable sources, for
example pipes, will have to be read entirely into memory before the length
can be found, so this operation can take a long time.</doc>
        <source-position filename="libvips/include/vips/connection.h"
                         line="250"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/source.c"
               line="1304">number of bytes in source, or -1 on error.</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/source.c"
                 line="1298">source to operate on</doc>
            <type name="Source" c:type="VipsSource*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="map" c:identifier="vips_source_map">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/source.c"
             line="1072">Map the source entirely into memory and return a pointer to the
start. If @length is non-NULL, the source size is written to it.

This operation can take a long time. Use [method@Source.is_mappable] to
check if a source can be mapped efficiently.

The pointer is valid for as long as @source is alive.</doc>
        <source-position filename="libvips/include/vips/connection.h"
                         line="237"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/source.c"
               line="1085">a pointer to the start of the file contents, or `NULL` on error.</doc>
          <type name="gpointer" c:type="void*"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/source.c"
                 line="1074">source to operate on</doc>
            <type name="Source" c:type="VipsSource*"/>
          </instance-parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/source.c"
                 line="1075">return the file length here, or `NULL`</doc>
            <type name="gsize" c:type="size_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="map_blob" c:identifier="vips_source_map_blob">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/source.c"
             line="1137">Just like [method@Source.map], but return a [struct@Blob] containing the
pointer. @source will stay alive as long as the result is alive.</doc>
        <source-position filename="libvips/include/vips/connection.h"
                         line="239"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/source.c"
               line="1144">a new [struct@Blob] containing the data, or `NULL` on error.</doc>
          <type name="Blob" c:type="VipsBlob*"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/source.c"
                 line="1139">source to operate on</doc>
            <type name="Source" c:type="VipsSource*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="minimise" c:identifier="vips_source_minimise">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/source.c"
             line="621">Minimise the source. As many resources as can be safely removed are
removed. Use [method@Source.unminimise] to restore the source if you wish to
use it again.

Loaders should call this in response to the minimise signal on their output
image.</doc>
        <source-position filename="libvips/include/vips/connection.h"
                         line="225"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/source.c"
                 line="623">source to operate on</doc>
            <type name="Source" c:type="VipsSource*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="read" c:identifier="vips_source_read">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/source.c"
             line="772">Read up to @length bytes from @source and store the bytes in @buffer.
Return the number of bytes actually read. If all bytes have been read from
the file, return 0.

Arguments exactly as [`read()`](man:read(2)).</doc>
        <source-position filename="libvips/include/vips/connection.h"
                         line="231"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/source.c"
               line="784">the number of bytes read, 0 on end of file, -1 on error.</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/source.c"
                 line="774">source to operate on</doc>
            <type name="Source" c:type="VipsSource*"/>
          </instance-parameter>
          <parameter name="buffer"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/source.c"
                 line="775">store bytes here</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/source.c"
                 line="776">length of @buffer in bytes</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="rewind" c:identifier="vips_source_rewind">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/source.c"
             line="1263">Rewind the source to the start.

You can't always do this after the pixel decode phase starts -- for
example, pipe-like sources can't be rewound.</doc>
        <source-position filename="libvips/include/vips/connection.h"
                         line="243"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/source.c"
               line="1272">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/source.c"
                 line="1265">source to operate on</doc>
            <type name="Source" c:type="VipsSource*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="seek" c:identifier="vips_source_seek">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/source.c"
             line="1165">Move the file read position. You can't call this after pixel decode starts.
The arguments are exactly as [`lseek()`](man:lseek(2)).</doc>
        <source-position filename="libvips/include/vips/connection.h"
                         line="241"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/source.c"
               line="1174">the new file position, or -1 on error.</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/source.c"
                 line="1167">source to operate on</doc>
            <type name="Source" c:type="VipsSource*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/source.c"
                 line="1168">seek by this offset</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="whence" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/source.c"
                 line="1169">seek relative to this point</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="sniff" c:identifier="vips_source_sniff">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/source.c"
             line="1376">Return a pointer to the first few bytes of the file. If the file is too
short, return `NULL`.</doc>
        <source-position filename="libvips/include/vips/connection.h"
                         line="248"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/source.c"
               line="1384">a pointer to the bytes at the start of the file, or `NULL` on error.</doc>
          <type name="guint8" c:type="unsigned char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/source.c"
                 line="1378">sniff this source</doc>
            <type name="Source" c:type="VipsSource*"/>
          </instance-parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/source.c"
                 line="1379">number of bytes to sniff</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="sniff_at_most" c:identifier="vips_source_sniff_at_most">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/source.c"
             line="1324">Attempt to sniff at most @length bytes from the start of the source. A
pointer to the bytes is returned in @data. The number of bytes actually
read is returned -- it may be less than @length if the file is shorter than
@length. A negative number indicates a read error.</doc>
        <source-position filename="libvips/include/vips/connection.h"
                         line="245"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/source.c"
               line="1335">number of bytes read, or -1 on error.</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/source.c"
                 line="1326">peek this source</doc>
            <type name="Source" c:type="VipsSource*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/source.c"
                 line="1327">return a pointer to the bytes read here</doc>
            <type name="guint8" c:type="unsigned char**"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/source.c"
                 line="1328">max number of bytes to read</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="unminimise" c:identifier="vips_source_unminimise">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/source.c"
             line="659">Restore the source after minimisation. This is called at the start
of every source method, so loaders should not usually need this.

::: seealso
    [method@Source.minimise].</doc>
        <source-position filename="libvips/include/vips/connection.h"
                         line="227"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/source.c"
               line="669">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/source.c"
                 line="661">source to operate on</doc>
            <type name="Source" c:type="VipsSource*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="blob" writable="1" transfer-ownership="none">
        <type name="Blob"/>
      </property>
      <field name="parent_object">
        <type name="Connection" c:type="VipsConnection"/>
      </field>
      <field name="decode">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="have_tested_seek">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="is_pipe">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="read_position">
        <type name="gint64" c:type="gint64"/>
      </field>
      <field name="length">
        <type name="gint64" c:type="gint64"/>
      </field>
      <field name="data" readable="0" private="1">
        <type name="gpointer" c:type="void*"/>
      </field>
      <field name="header_bytes" readable="0" private="1">
        <array name="GLib.ByteArray" c:type="GByteArray*">
          <type name="guint8" c:type="guint8"/>
        </array>
      </field>
      <field name="sniff" readable="0" private="1">
        <array name="GLib.ByteArray" c:type="GByteArray*">
          <type name="guint8" c:type="guint8"/>
        </array>
      </field>
      <field name="blob" readable="0" private="1">
        <type name="Blob" c:type="VipsBlob*"/>
      </field>
      <field name="mmap_baseaddr" readable="0" private="1">
        <type name="gpointer" c:type="void*"/>
      </field>
      <field name="mmap_length" readable="0" private="1">
        <type name="gsize" c:type="size_t"/>
      </field>
    </class>
    <record name="SourceClass"
            c:type="VipsSourceClass"
            glib:is-gtype-struct-for="Source">
      <source-position filename="libvips/include/vips/connection.h"
                       line="206"/>
      <field name="parent_class">
        <type name="ConnectionClass" c:type="VipsConnectionClass"/>
      </field>
      <field name="read">
        <callback name="read">
          <source-position filename="libvips/include/vips/connection.h"
                           line="193"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/source.c"
                 line="784">the number of bytes read, 0 on end of file, -1 on error.</doc>
            <type name="gint64" c:type="gint64"/>
          </return-value>
          <parameters>
            <parameter name="source" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="libvips/iofuncs/source.c"
                   line="774">source to operate on</doc>
              <type name="Source" c:type="VipsSource*"/>
            </parameter>
            <parameter name="buffer"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve"
                   filename="libvips/iofuncs/source.c"
                   line="775">store bytes here</doc>
              <type name="gpointer" c:type="void*"/>
            </parameter>
            <parameter name="length" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="libvips/iofuncs/source.c"
                   line="776">length of @buffer in bytes</doc>
              <type name="gsize" c:type="size_t"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="seek">
        <callback name="seek">
          <source-position filename="libvips/include/vips/connection.h"
                           line="204"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/source.c"
                 line="1174">the new file position, or -1 on error.</doc>
            <type name="gint64" c:type="gint64"/>
          </return-value>
          <parameters>
            <parameter name="source" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="libvips/iofuncs/source.c"
                   line="1167">source to operate on</doc>
              <type name="Source" c:type="VipsSource*"/>
            </parameter>
            <parameter name="offset" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="libvips/iofuncs/source.c"
                   line="1168">seek by this offset</doc>
              <type name="gint64" c:type="gint64"/>
            </parameter>
            <parameter name="whence" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="libvips/iofuncs/source.c"
                   line="1169">seek relative to this point</doc>
              <type name="gint" c:type="int"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="SourceCustom"
           c:symbol-prefix="source_custom"
           c:type="VipsSourceCustom"
           parent="Source"
           glib:type-name="VipsSourceCustom"
           glib:get-type="vips_source_custom_get_type"
           glib:type-struct="SourceCustomClass">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/source.c"
           line="91">Subclass of [class@Source] with action signals for handlers.

This is supposed to be useful for language bindings.</doc>
      <source-position filename="libvips/include/vips/connection.h"
                       line="282"/>
      <constructor name="new" c:identifier="vips_source_custom_new">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/sourcecustom.c"
             line="229">Create a [class@SourceCustom]. Attach signals to implement read and seek.</doc>
        <source-position filename="libvips/include/vips/connection.h"
                         line="287"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/sourcecustom.c"
               line="234">a new [class@SourceCustom]</doc>
          <type name="SourceCustom" c:type="VipsSourceCustom*"/>
        </return-value>
      </constructor>
      <virtual-method name="read">
        <source-position filename="libvips/include/vips/connection.h"
                         line="279"/>
        <return-value transfer-ownership="none">
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <type name="SourceCustom" c:type="VipsSourceCustom*"/>
          </instance-parameter>
          <parameter name="buffer"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="seek">
        <source-position filename="libvips/include/vips/connection.h"
                         line="280"/>
        <return-value transfer-ownership="none">
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <type name="SourceCustom" c:type="VipsSourceCustom*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="whence" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </virtual-method>
      <field name="parent_object">
        <type name="Source" c:type="VipsSource"/>
      </field>
      <glib:signal name="read" action="1">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/sourcecustom.c"
             line="181">This signal is emitted to read bytes from the source into @buffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/sourcecustom.c"
               line="189">the number of bytes read. Return 0 for EOF.</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <parameter name="buffer"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/sourcecustom.c"
                 line="184">`gpointer`, buffer to fill</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/sourcecustom.c"
                 line="185">`gint64`, size of buffer</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="seek" action="1">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/sourcecustom.c"
             line="200">This signal is emitted to seek the source. The handler should
change the source position appropriately.

The handler for an unseekable source should always return -1.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/sourcecustom.c"
               line="211">the new seek position.</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/sourcecustom.c"
                 line="203">`gint64`, seek offset</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="whence" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/sourcecustom.c"
                 line="204">`gint`, seek origin</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="SourceCustomClass"
            c:type="VipsSourceCustomClass"
            glib:is-gtype-struct-for="SourceCustom">
      <source-position filename="libvips/include/vips/connection.h"
                       line="282"/>
      <field name="parent_class">
        <type name="SourceClass" c:type="VipsSourceClass"/>
      </field>
      <field name="read">
        <callback name="read">
          <source-position filename="libvips/include/vips/connection.h"
                           line="279"/>
          <return-value transfer-ownership="none">
            <type name="gint64" c:type="gint64"/>
          </return-value>
          <parameters>
            <parameter name="source" transfer-ownership="none">
              <type name="SourceCustom" c:type="VipsSourceCustom*"/>
            </parameter>
            <parameter name="buffer"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <type name="gpointer" c:type="void*"/>
            </parameter>
            <parameter name="length" transfer-ownership="none">
              <type name="gint64" c:type="gint64"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="seek">
        <callback name="seek">
          <source-position filename="libvips/include/vips/connection.h"
                           line="280"/>
          <return-value transfer-ownership="none">
            <type name="gint64" c:type="gint64"/>
          </return-value>
          <parameters>
            <parameter name="source" transfer-ownership="none">
              <type name="SourceCustom" c:type="VipsSourceCustom*"/>
            </parameter>
            <parameter name="offset" transfer-ownership="none">
              <type name="gint64" c:type="gint64"/>
            </parameter>
            <parameter name="whence" transfer-ownership="none">
              <type name="gint" c:type="int"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="SourceGInputStream"
           c:symbol-prefix="source_g_input_stream"
           c:type="VipsSourceGInputStream"
           parent="Source"
           glib:type-name="VipsSourceGInputStream"
           glib:get-type="vips_source_g_input_stream_get_type"
           glib:type-struct="SourceGInputStreamClass">
      <source-position filename="libvips/include/vips/connection.h"
                       line="365"/>
      <constructor name="new" c:identifier="vips_source_g_input_stream_new">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/sourceginput.c"
             line="237">Create a [class@SourceGInputStream] which wraps @stream.

::: seealso
    [ctor@GInputStream.new_from_source]</doc>
        <source-position filename="libvips/include/vips/connection.h"
                         line="370"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/sourceginput.c"
               line="246">the new source.</doc>
          <type name="SourceGInputStream" c:type="VipsSourceGInputStream*"/>
        </return-value>
        <parameters>
          <parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/sourceginput.c"
                 line="239">read from this stream</doc>
            <type name="Gio.InputStream" c:type="GInputStream*"/>
          </parameter>
        </parameters>
      </constructor>
      <property name="stream" writable="1" transfer-ownership="none">
        <type name="Gio.InputStream"/>
      </property>
      <field name="parent_instance">
        <type name="Source" c:type="VipsSource"/>
      </field>
      <field name="stream" readable="0" private="1">
        <type name="Gio.InputStream" c:type="GInputStream*"/>
      </field>
      <field name="seekable" readable="0" private="1">
        <type name="Gio.Seekable" c:type="GSeekable*"/>
      </field>
      <field name="info" readable="0" private="1">
        <type name="Gio.FileInfo" c:type="GFileInfo*"/>
      </field>
    </class>
    <record name="SourceGInputStreamClass"
            c:type="VipsSourceGInputStreamClass"
            glib:is-gtype-struct-for="SourceGInputStream">
      <source-position filename="libvips/include/vips/connection.h"
                       line="365"/>
      <field name="parent_class">
        <type name="SourceClass" c:type="VipsSourceClass"/>
      </field>
    </record>
    <callback name="StartFn" c:type="VipsStartFn">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/generate.c"
           line="580">Start a new processing sequence for this generate function. This allocates
per-thread state, such as an input region.

::: seealso
    [func@start_one], [func@start_many].</doc>
      <source-position filename="libvips/include/vips/image.h" line="151"/>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/generate.c"
             line="592">a new sequence value</doc>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/generate.c"
               line="582">image being calculated</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/generate.c"
               line="583">user data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/generate.c"
               line="584">user data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="StopFn" c:type="VipsStopFn">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/generate.c"
           line="612">Stop a processing sequence. This frees
per-thread state, such as an input region.

::: seealso
    [func@stop_one], [func@stop_many].</doc>
      <source-position filename="libvips/include/vips/image.h" line="154"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/generate.c"
             line="624">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="seq"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/generate.c"
               line="614">sequence value</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/generate.c"
               line="615">user data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/generate.c"
               line="616">user data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <function-macro name="TARGET"
                    c:identifier="VIPS_TARGET"
                    introspectable="0">
      <source-position filename="libvips/include/vips/connection.h"
                       line="373"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="TARGET_BUFFER_SIZE"
              value="8500"
              c:type="VIPS_TARGET_BUFFER_SIZE">
      <source-position filename="libvips/include/vips/connection.h"
                       line="389"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="TARGET_CLASS"
                    c:identifier="VIPS_TARGET_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/connection.h"
                       line="376"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TARGET_CLONES"
                    c:identifier="VIPS_TARGET_CLONES"
                    introspectable="0">
      <source-position filename="libvips/include/vips/util.h" line="237"/>
      <parameters>
        <parameter name="TARGETS">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TARGET_CUSTOM"
                    c:identifier="VIPS_TARGET_CUSTOM"
                    introspectable="0">
      <source-position filename="libvips/include/vips/connection.h"
                       line="514"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="TARGET_CUSTOM_BUFFER_SIZE"
              value="4096"
              c:type="VIPS_TARGET_CUSTOM_BUFFER_SIZE">
      <source-position filename="libvips/include/vips/connection.h"
                       line="528"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="TARGET_CUSTOM_CLASS"
                    c:identifier="VIPS_TARGET_CUSTOM_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/connection.h"
                       line="517"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TARGET_CUSTOM_GET_CLASS"
                    c:identifier="VIPS_TARGET_CUSTOM_GET_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/connection.h"
                       line="524"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TARGET_GET_CLASS"
                    c:identifier="VIPS_TARGET_GET_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/connection.h"
                       line="383"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TARGET_PUTC"
                    c:identifier="VIPS_TARGET_PUTC"
                    introspectable="0">
      <source-position filename="libvips/include/vips/connection.h"
                       line="501"/>
      <parameters>
        <parameter name="S">
        </parameter>
        <parameter name="C">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="THREAD_STATE"
                    c:identifier="VIPS_THREAD_STATE"
                    introspectable="0">
      <source-position filename="libvips/include/vips/threadpool.h" line="55"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="THREAD_STATE_CLASS"
                    c:identifier="VIPS_THREAD_STATE_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/threadpool.h" line="58"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="THREAD_STATE_GET_CLASS"
                    c:identifier="VIPS_THREAD_STATE_GET_CLASS"
                    introspectable="0">
      <source-position filename="libvips/include/vips/threadpool.h" line="65"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="TRANSFORM_SCALE" value="1" c:type="VIPS_TRANSFORM_SCALE">
      <doc xml:space="preserve"
           filename="libvips/resample/interpolate.c"
           line="288">[const@TRANSFORM_SHIFT] as a multiplicative constant.</doc>
      <source-position filename="libvips/include/vips/interpolate.h"
                       line="110"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="TRANSFORM_SHIFT" value="6" c:type="VIPS_TRANSFORM_SHIFT">
      <doc xml:space="preserve"
           filename="libvips/resample/interpolate.c"
           line="281">Many of the libvips interpolators use fixed-point arithmetic for coordinate
calculation. This is how many bits of precision they use.</doc>
      <source-position filename="libvips/include/vips/interpolate.h"
                       line="109"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <class name="Target"
           c:symbol-prefix="target"
           c:type="VipsTarget"
           parent="Connection"
           glib:type-name="VipsTarget"
           glib:get-type="vips_target_get_type"
           glib:type-struct="TargetClass">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/source.c"
           line="99">A [class@Target] provides a unified interface for writing data to various
output destinations.

This target could be a socket, file, memory area, or any other destination
that accepts byte data.</doc>
      <source-position filename="libvips/include/vips/connection.h"
                       line="473"/>
      <constructor name="new_temp" c:identifier="vips_target_new_temp">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/target.c"
             line="430">Create a temporary target -- either a temporary file on disc, or an area in
memory, depending on what sort of target @based_on is.

::: seealso
    [ctor@Target.new_to_file].</doc>
        <source-position filename="libvips/include/vips/connection.h"
                         line="485"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/target.c"
               line="440">a new target.</doc>
          <type name="Target" c:type="VipsTarget*"/>
        </return-value>
        <parameters>
          <parameter name="based_on" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/target.c"
                 line="432">base the temporary target on this target</doc>
            <type name="Target" c:type="VipsTarget*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_to_descriptor"
                   c:identifier="vips_target_new_to_descriptor">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/target.c"
             line="340">Create a target attached to a file descriptor.
@descriptor is kept open until the target is finalized.

::: seealso
    [ctor@Target.new_to_file].</doc>
        <source-position filename="libvips/include/vips/connection.h"
                         line="479"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/target.c"
               line="350">a new target.</doc>
          <type name="Target" c:type="VipsTarget*"/>
        </return-value>
        <parameters>
          <parameter name="descriptor" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/target.c"
                 line="342">write to this file descriptor</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_to_file" c:identifier="vips_target_new_to_file">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/target.c"
             line="372">Create a target attached to a file.</doc>
        <source-position filename="libvips/include/vips/connection.h"
                         line="481"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/target.c"
               line="378">a new target.</doc>
          <type name="Target" c:type="VipsTarget*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/target.c"
                 line="374">write to this file</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_to_memory"
                   c:identifier="vips_target_new_to_memory">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/target.c"
             line="400">Create a target which will write to a memory area. Read from @blob to get
memory.

::: seealso
    [ctor@Target.new_to_file].</doc>
        <source-position filename="libvips/include/vips/connection.h"
                         line="483"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/target.c"
               line="409">a new target.</doc>
          <type name="Target" c:type="VipsTarget*"/>
        </return-value>
      </constructor>
      <virtual-method name="end" invoker="end">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/target.c"
             line="627">Call this at the end of write to make the target do any cleaning up. You
can call it many times.

After a target has been ended, further writes will do nothing.</doc>
        <source-position filename="libvips/include/vips/connection.h"
                         line="471"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/target.c"
               line="636">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/target.c"
                 line="629">target to operate on</doc>
            <type name="Target" c:type="VipsTarget*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="finish">
        <source-position filename="libvips/include/vips/connection.h"
                         line="445"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="target" transfer-ownership="none">
            <type name="Target" c:type="VipsTarget*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="read" invoker="read">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/target.c"
             line="562">Read up to @length bytes from @target and store the bytes in @buffer.
Return the number of bytes actually read. If all bytes have been read from
the file, return 0.

Arguments exactly as [`read()`](man:read(2)).

Reading from a target sounds weird, but libtiff needs this for
multi-page writes. This method will fail for targets like pipes.</doc>
        <source-position filename="libvips/include/vips/connection.h"
                         line="459"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/target.c"
               line="577">the number of bytes read, 0 on end of file, -1 on error.</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/target.c"
                 line="564">target to operate on</doc>
            <type name="Target" c:type="VipsTarget*"/>
          </instance-parameter>
          <parameter name="buffer"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/target.c"
                 line="565">store bytes here</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/target.c"
                 line="566">length of @buffer in bytes</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="seek" invoker="seek">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/target.c"
             line="592">Seek the target. This behaves exactly as [`lseek()`](man:lseek(2)).

Seeking a target sounds weird, but libtiff needs this. This method will
fail for targets like pipes.</doc>
        <source-position filename="libvips/include/vips/connection.h"
                         line="466"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/target.c"
               line="603">the new offset, -1 on error.</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/target.c"
                 line="594">target to operate on</doc>
            <type name="Target" c:type="VipsTarget*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/target.c"
                 line="595">offset to seek to</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="whence" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/target.c"
                 line="596">seek relative to beginning, offset, or end</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="write">
        <source-position filename="libvips/include/vips/connection.h"
                         line="441"/>
        <return-value transfer-ownership="none">
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="target" transfer-ownership="none">
            <type name="Target" c:type="VipsTarget*"/>
          </instance-parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <type name="gsize" c:type="size_t"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="end" c:identifier="vips_target_end">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/target.c"
             line="627">Call this at the end of write to make the target do any cleaning up. You
can call it many times.

After a target has been ended, further writes will do nothing.</doc>
        <source-position filename="libvips/include/vips/connection.h"
                         line="493"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/target.c"
               line="636">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/target.c"
                 line="629">target to operate on</doc>
            <type name="Target" c:type="VipsTarget*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="putc" c:identifier="vips_target_putc">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/target.c"
             line="736">Write a single character @ch to @target. See the macro [func@TARGET_PUTC]
for a faster way to do this.</doc>
        <source-position filename="libvips/include/vips/connection.h"
                         line="500"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/target.c"
               line="744">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/target.c"
                 line="738">target to operate on</doc>
            <type name="Target" c:type="VipsTarget*"/>
          </instance-parameter>
          <parameter name="ch" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/target.c"
                 line="739">character to write</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="read" c:identifier="vips_target_read">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/target.c"
             line="562">Read up to @length bytes from @target and store the bytes in @buffer.
Return the number of bytes actually read. If all bytes have been read from
the file, return 0.

Arguments exactly as [`read()`](man:read(2)).

Reading from a target sounds weird, but libtiff needs this for
multi-page writes. This method will fail for targets like pipes.</doc>
        <source-position filename="libvips/include/vips/connection.h"
                         line="489"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/target.c"
               line="577">the number of bytes read, 0 on end of file, -1 on error.</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/target.c"
                 line="564">target to operate on</doc>
            <type name="Target" c:type="VipsTarget*"/>
          </instance-parameter>
          <parameter name="buffer"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/target.c"
                 line="565">store bytes here</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/target.c"
                 line="566">length of @buffer in bytes</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="seek" c:identifier="vips_target_seek">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/target.c"
             line="592">Seek the target. This behaves exactly as [`lseek()`](man:lseek(2)).

Seeking a target sounds weird, but libtiff needs this. This method will
fail for targets like pipes.</doc>
        <source-position filename="libvips/include/vips/connection.h"
                         line="491"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/target.c"
               line="603">the new offset, -1 on error.</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/target.c"
                 line="594">target to operate on</doc>
            <type name="Target" c:type="VipsTarget*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/target.c"
                 line="595">offset to seek to</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="whence" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/target.c"
                 line="596">seek relative to beginning, offset, or end</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="steal" c:identifier="vips_target_steal">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/target.c"
             line="673">Memory targets only (see [ctor@Target.new_to_memory]). Steal all data
written to the target so far, and call [method@Target.end].

You must free the returned pointer with [func@GLib.free].

The data is NOT automatically null-terminated. Use [method@Target.putc] with
a '\0' before calling this to get a null-terminated string.

You can't call this after [method@Target.end], since that moves the data to a
blob, and we can't steal from that in case the pointer has been shared.

You can't call this function more than once.</doc>
        <source-position filename="libvips/include/vips/connection.h"
                         line="495"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/target.c"
               line="691">the
data</doc>
          <array length="0" zero-terminated="0" c:type="unsigned char*">
            <type name="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/target.c"
                 line="675">target to operate on</doc>
            <type name="Target" c:type="VipsTarget*"/>
          </instance-parameter>
          <parameter name="length"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/target.c"
                 line="676">return number of bytes of data</doc>
            <type name="gsize" c:type="size_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="steal_text" c:identifier="vips_target_steal_text">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/target.c"
             line="720">As [method@Target.steal], but return a null-terminated string.</doc>
        <source-position filename="libvips/include/vips/connection.h"
                         line="497"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/target.c"
               line="726">target contents as a null-terminated string.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/target.c"
                 line="722">target to operate on</doc>
            <type name="Target" c:type="VipsTarget*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="write" c:identifier="vips_target_write">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/target.c"
             line="528">Write @length bytes from @data to the output.</doc>
        <source-position filename="libvips/include/vips/connection.h"
                         line="487"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/target.c"
               line="536">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/target.c"
                 line="530">target to operate on</doc>
            <type name="Target" c:type="VipsTarget*"/>
          </instance-parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/target.c"
                 line="531">data to write</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/target.c"
                 line="532">length of @data in bytes</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="write_amp" c:identifier="vips_target_write_amp">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/target.c"
             line="804">Write @str to @target, but escape stuff that xml hates in text. Our
argument string is utf-8.

XML rules:

- We must escape &amp;&lt;&gt;
- Don't escape \n, \t, \r
- Do escape the other ASCII codes.</doc>
        <source-position filename="libvips/include/vips/connection.h"
                         line="511"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/target.c"
               line="818">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/target.c"
                 line="806">target to operate on</doc>
            <type name="Target" c:type="VipsTarget*"/>
          </instance-parameter>
          <parameter name="str" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/target.c"
                 line="807">string to write</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="writef"
              c:identifier="vips_target_writef"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/target.c"
             line="776">Format the string and write to @target.</doc>
        <source-position filename="libvips/include/vips/connection.h"
                         line="508"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/target.c"
               line="784">0 on success, and -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/target.c"
                 line="778">target to operate on</doc>
            <type name="Target" c:type="VipsTarget*"/>
          </instance-parameter>
          <parameter name="fmt" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/target.c"
                 line="779">`printf()`-style format string</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/target.c"
                 line="780">arguments to format string</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="writes" c:identifier="vips_target_writes">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/target.c"
             line="760">Write a null-terminated string to @target.</doc>
        <source-position filename="libvips/include/vips/connection.h"
                         line="506"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/target.c"
               line="767">0 on success, and -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/target.c"
                 line="762">target to operate on</doc>
            <type name="Target" c:type="VipsTarget*"/>
          </instance-parameter>
          <parameter name="str" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/target.c"
                 line="763">string to write</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <property name="blob" writable="1" transfer-ownership="none">
        <type name="Blob"/>
      </property>
      <property name="memory"
                writable="1"
                transfer-ownership="none"
                default-value="FALSE">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent_object">
        <type name="Connection" c:type="VipsConnection"/>
      </field>
      <field name="memory" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="ended" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="memory_buffer" readable="0" private="1">
        <type name="GLib.String" c:type="GString*"/>
      </field>
      <field name="blob" readable="0" private="1">
        <type name="Blob" c:type="VipsBlob*"/>
      </field>
      <field name="output_buffer" readable="0" private="1">
        <array zero-terminated="0" fixed-size="8500">
          <type name="guint8" c:type="unsigned char"/>
        </array>
      </field>
      <field name="write_point" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="position" readable="0" private="1">
        <type name="gint64" c:type="gint64"/>
      </field>
      <field name="delete_on_close" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="delete_on_close_filename" readable="0" private="1">
        <type name="utf8" c:type="char*"/>
      </field>
    </class>
    <record name="TargetClass"
            c:type="VipsTargetClass"
            glib:is-gtype-struct-for="Target">
      <source-position filename="libvips/include/vips/connection.h"
                       line="473"/>
      <field name="parent_class">
        <type name="ConnectionClass" c:type="VipsConnectionClass"/>
      </field>
      <field name="write">
        <callback name="write">
          <source-position filename="libvips/include/vips/connection.h"
                           line="441"/>
          <return-value transfer-ownership="none">
            <type name="gint64" c:type="gint64"/>
          </return-value>
          <parameters>
            <parameter name="target" transfer-ownership="none">
              <type name="Target" c:type="VipsTarget*"/>
            </parameter>
            <parameter name="data"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <type name="gpointer" c:type="void*"/>
            </parameter>
            <parameter name="length" transfer-ownership="none">
              <type name="gsize" c:type="size_t"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="finish">
        <callback name="finish">
          <source-position filename="libvips/include/vips/connection.h"
                           line="445"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="target" transfer-ownership="none">
              <type name="Target" c:type="VipsTarget*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="read">
        <callback name="read">
          <source-position filename="libvips/include/vips/connection.h"
                           line="459"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/target.c"
                 line="577">the number of bytes read, 0 on end of file, -1 on error.</doc>
            <type name="gint64" c:type="gint64"/>
          </return-value>
          <parameters>
            <parameter name="target" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="libvips/iofuncs/target.c"
                   line="564">target to operate on</doc>
              <type name="Target" c:type="VipsTarget*"/>
            </parameter>
            <parameter name="buffer"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve"
                   filename="libvips/iofuncs/target.c"
                   line="565">store bytes here</doc>
              <type name="gpointer" c:type="void*"/>
            </parameter>
            <parameter name="length" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="libvips/iofuncs/target.c"
                   line="566">length of @buffer in bytes</doc>
              <type name="gsize" c:type="size_t"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="seek">
        <callback name="seek">
          <source-position filename="libvips/include/vips/connection.h"
                           line="466"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/target.c"
                 line="603">the new offset, -1 on error.</doc>
            <type name="gint64" c:type="gint64"/>
          </return-value>
          <parameters>
            <parameter name="target" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="libvips/iofuncs/target.c"
                   line="594">target to operate on</doc>
              <type name="Target" c:type="VipsTarget*"/>
            </parameter>
            <parameter name="offset" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="libvips/iofuncs/target.c"
                   line="595">offset to seek to</doc>
              <type name="gint64" c:type="gint64"/>
            </parameter>
            <parameter name="whence" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="libvips/iofuncs/target.c"
                   line="596">seek relative to beginning, offset, or end</doc>
              <type name="gint" c:type="int"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="end">
        <callback name="end">
          <source-position filename="libvips/include/vips/connection.h"
                           line="471"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/target.c"
                 line="636">0 on success, -1 on error.</doc>
            <type name="gint" c:type="int"/>
          </return-value>
          <parameters>
            <parameter name="target" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="libvips/iofuncs/target.c"
                   line="629">target to operate on</doc>
              <type name="Target" c:type="VipsTarget*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="TargetCustom"
           c:symbol-prefix="target_custom"
           c:type="VipsTargetCustom"
           parent="Target"
           glib:type-name="VipsTargetCustom"
           glib:get-type="vips_target_custom_get_type"
           glib:type-struct="TargetCustomClass">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/source.c"
           line="109">Subclass of [class@Target] with action signals for handlers.

This is supposed to be useful for language bindings.</doc>
      <source-position filename="libvips/include/vips/connection.h"
                       line="548"/>
      <constructor name="new" c:identifier="vips_target_custom_new">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/targetcustom.c"
             line="348">Create a [class@TargetCustom]. Attach signals to implement write and finish.</doc>
        <source-position filename="libvips/include/vips/connection.h"
                         line="553"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/targetcustom.c"
               line="353">a new [class@TargetCustom]</doc>
          <type name="TargetCustom" c:type="VipsTargetCustom*"/>
        </return-value>
      </constructor>
      <virtual-method name="end">
        <source-position filename="libvips/include/vips/connection.h"
                         line="546"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="target" transfer-ownership="none">
            <type name="TargetCustom" c:type="VipsTargetCustom*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="finish">
        <source-position filename="libvips/include/vips/connection.h"
                         line="543"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="target" transfer-ownership="none">
            <type name="TargetCustom" c:type="VipsTargetCustom*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="read">
        <source-position filename="libvips/include/vips/connection.h"
                         line="544"/>
        <return-value transfer-ownership="none">
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="target" transfer-ownership="none">
            <type name="TargetCustom" c:type="VipsTargetCustom*"/>
          </instance-parameter>
          <parameter name="buffer"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="seek">
        <source-position filename="libvips/include/vips/connection.h"
                         line="545"/>
        <return-value transfer-ownership="none">
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="target" transfer-ownership="none">
            <type name="TargetCustom" c:type="VipsTargetCustom*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="whence" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="write">
        <source-position filename="libvips/include/vips/connection.h"
                         line="542"/>
        <return-value transfer-ownership="none">
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="target" transfer-ownership="none">
            <type name="TargetCustom" c:type="VipsTargetCustom*"/>
          </instance-parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </virtual-method>
      <field name="parent_object">
        <type name="Target" c:type="VipsTarget"/>
      </field>
      <glib:signal name="end" action="1">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/targetcustom.c"
             line="311">This signal is emitted at the end of write. The target should do
any finishing necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/targetcustom.c"
               line="318">0 on success, -1 on error.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
      </glib:signal>
      <glib:signal name="finish" action="1">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/targetcustom.c"
             line="328">Deprecated for [signal@TargetCustom::end].</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="read" action="1">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/targetcustom.c"
             line="268">This signal is emitted to read bytes from the target into @buffer.

The handler for an unreadable target should always return -1.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/targetcustom.c"
               line="278">the number of bytes read. Return 0 for EOF.</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <parameter name="buffer"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/targetcustom.c"
                 line="271">`gpointer`, buffer to fill</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/targetcustom.c"
                 line="272">`gint64`, size of buffer</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="seek" action="1">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/targetcustom.c"
             line="289">This signal is emitted to seek the target. The handler should
change the target position appropriately.

The handler for an unseekable target should always return -1.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/targetcustom.c"
               line="300">the new seek position.</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/targetcustom.c"
                 line="292">`gint64`, seek offset</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="whence" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/targetcustom.c"
                 line="293">`gint`, seek origin</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="write" action="1">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/targetcustom.c"
             line="249">This signal is emitted to write bytes to the target.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/targetcustom.c"
               line="257">the number of bytes written.</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/targetcustom.c"
                 line="252">`gpointer`, bytes to write</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libvips/iofuncs/targetcustom.c"
                 line="253">`gint64`, number of bytes</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="TargetCustomClass"
            c:type="VipsTargetCustomClass"
            glib:is-gtype-struct-for="TargetCustom">
      <source-position filename="libvips/include/vips/connection.h"
                       line="548"/>
      <field name="parent_class">
        <type name="TargetClass" c:type="VipsTargetClass"/>
      </field>
      <field name="write">
        <callback name="write">
          <source-position filename="libvips/include/vips/connection.h"
                           line="542"/>
          <return-value transfer-ownership="none">
            <type name="gint64" c:type="gint64"/>
          </return-value>
          <parameters>
            <parameter name="target" transfer-ownership="none">
              <type name="TargetCustom" c:type="VipsTargetCustom*"/>
            </parameter>
            <parameter name="data"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <type name="gpointer" c:type="void*"/>
            </parameter>
            <parameter name="length" transfer-ownership="none">
              <type name="gint64" c:type="gint64"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="finish">
        <callback name="finish">
          <source-position filename="libvips/include/vips/connection.h"
                           line="543"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="target" transfer-ownership="none">
              <type name="TargetCustom" c:type="VipsTargetCustom*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="read">
        <callback name="read">
          <source-position filename="libvips/include/vips/connection.h"
                           line="544"/>
          <return-value transfer-ownership="none">
            <type name="gint64" c:type="gint64"/>
          </return-value>
          <parameters>
            <parameter name="target" transfer-ownership="none">
              <type name="TargetCustom" c:type="VipsTargetCustom*"/>
            </parameter>
            <parameter name="buffer"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <type name="gpointer" c:type="void*"/>
            </parameter>
            <parameter name="length" transfer-ownership="none">
              <type name="gint64" c:type="gint64"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="seek">
        <callback name="seek">
          <source-position filename="libvips/include/vips/connection.h"
                           line="545"/>
          <return-value transfer-ownership="none">
            <type name="gint64" c:type="gint64"/>
          </return-value>
          <parameters>
            <parameter name="target" transfer-ownership="none">
              <type name="TargetCustom" c:type="VipsTargetCustom*"/>
            </parameter>
            <parameter name="offset" transfer-ownership="none">
              <type name="gint64" c:type="gint64"/>
            </parameter>
            <parameter name="whence" transfer-ownership="none">
              <type name="gint" c:type="int"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="end">
        <callback name="end">
          <source-position filename="libvips/include/vips/connection.h"
                           line="546"/>
          <return-value transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </return-value>
          <parameters>
            <parameter name="target" transfer-ownership="none">
              <type name="TargetCustom" c:type="VipsTargetCustom*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <enumeration name="TextWrap"
                 glib:type-name="VipsTextWrap"
                 glib:get-type="vips_text_wrap_get_type"
                 c:type="VipsTextWrap">
      <doc xml:space="preserve"
           filename="libvips/create/create.c"
           line="54">Sets the word wrapping style for [ctor@Image.text] when used with a maximum
width.

::: seealso
    [ctor@Image.text].</doc>
      <member name="word"
              value="0"
              c:identifier="VIPS_TEXT_WRAP_WORD"
              glib:nick="word"
              glib:name="VIPS_TEXT_WRAP_WORD">
        <doc xml:space="preserve"
             filename="libvips/create/create.c"
             line="56">wrap at word boundaries</doc>
      </member>
      <member name="char"
              value="1"
              c:identifier="VIPS_TEXT_WRAP_CHAR"
              glib:nick="char"
              glib:name="VIPS_TEXT_WRAP_CHAR">
        <doc xml:space="preserve"
             filename="libvips/create/create.c"
             line="57">wrap at character boundaries</doc>
      </member>
      <member name="word_char"
              value="2"
              c:identifier="VIPS_TEXT_WRAP_WORD_CHAR"
              glib:nick="word-char"
              glib:name="VIPS_TEXT_WRAP_WORD_CHAR">
        <doc xml:space="preserve"
             filename="libvips/create/create.c"
             line="58">wrap at word boundaries, but fall back to character boundaries if there is not enough space for a full word</doc>
      </member>
      <member name="none"
              value="3"
              c:identifier="VIPS_TEXT_WRAP_NONE"
              glib:nick="none"
              glib:name="VIPS_TEXT_WRAP_NONE">
        <doc xml:space="preserve"
             filename="libvips/create/create.c"
             line="59">no wrapping</doc>
      </member>
    </enumeration>
    <callback name="ThreadStartFn"
              c:type="VipsThreadStartFn"
              introspectable="0">
      <source-position filename="libvips/include/vips/threadpool.h"
                       line="118"/>
      <return-value>
        <type name="ThreadState" c:type="VipsThreadState*"/>
      </return-value>
      <parameters>
        <parameter name="im" transfer-ownership="none">
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <class name="ThreadState"
           c:symbol-prefix="thread_state"
           c:type="VipsThreadState"
           parent="Object"
           glib:type-name="VipsThreadState"
           glib:get-type="vips_thread_state_get_type"
           glib:type-struct="ThreadStateClass">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/threadpool.c"
           line="80">A [class@ThreadState] represents a per-thread state.

[callback@ThreadpoolAllocateFn] functions can use these members to
communicate with [callback@ThreadpoolWorkFn] functions.

::: seealso
    [func@threadpool_run].</doc>
      <source-position filename="libvips/include/vips/threadpool.h"
                       line="105"/>
      <constructor name="new" c:identifier="vips_thread_state_new">
        <source-position filename="libvips/include/vips/threadpool.h"
                         line="114"/>
        <return-value transfer-ownership="full">
          <type name="ThreadState" c:type="VipsThreadState*"/>
        </return-value>
        <parameters>
          <parameter name="im" transfer-ownership="none">
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="a"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="set" c:identifier="vips_thread_state_set">
        <source-position filename="libvips/include/vips/threadpool.h"
                         line="108"/>
        <return-value transfer-ownership="none" nullable="1">
          <type name="gpointer" c:type="void*"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="VipsObject*"/>
          </parameter>
          <parameter name="a"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="b"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </function>
      <field name="parent_object">
        <type name="Object" c:type="VipsObject"/>
      </field>
      <field name="im">
        <type name="Image" c:type="VipsImage*"/>
      </field>
      <field name="reg">
        <type name="Region" c:type="VipsRegion*"/>
      </field>
      <field name="pos">
        <type name="Rect" c:type="VipsRect"/>
      </field>
      <field name="x">
        <type name="gint" c:type="int"/>
      </field>
      <field name="y">
        <type name="gint" c:type="int"/>
      </field>
      <field name="stop">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="a">
        <type name="gpointer" c:type="void*"/>
      </field>
      <field name="stall">
        <type name="gboolean" c:type="gboolean"/>
      </field>
    </class>
    <record name="ThreadStateClass"
            c:type="VipsThreadStateClass"
            glib:is-gtype-struct-for="ThreadState">
      <source-position filename="libvips/include/vips/threadpool.h"
                       line="105"/>
      <field name="parent_class">
        <type name="ObjectClass" c:type="VipsObjectClass"/>
      </field>
    </record>
    <callback name="ThreadpoolAllocateFn" c:type="VipsThreadpoolAllocateFn">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/threadpool.c"
           line="553">This function is called to allocate a new work unit for the thread. It is
always single-threaded, so it can modify per-pool state (such as a
counter).

It should set @stop to `TRUE` to indicate that no work could be allocated
because the job is done.

::: seealso
    [func@threadpool_run].</doc>
      <source-position filename="libvips/include/vips/threadpool.h"
                       line="124"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/threadpool.c"
             line="569">0 on success, or -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="state" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/threadpool.c"
               line="555">per-thread state</doc>
          <type name="ThreadState" c:type="VipsThreadState*"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/threadpool.c"
               line="556">client data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="stop" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/threadpool.c"
               line="557">set this to signal end of computation</doc>
          <type name="gboolean" c:type="gboolean*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ThreadpoolProgressFn" c:type="VipsThreadpoolProgressFn">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/threadpool.c"
           line="587">This function is called by the main thread once for every work unit
processed. It can be used to give the user progress feedback.

::: seealso
    [func@threadpool_run].</doc>
      <source-position filename="libvips/include/vips/threadpool.h"
                       line="135"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/threadpool.c"
             line="597">0 on success, or -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/threadpool.c"
               line="589">client data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ThreadpoolWorkFn" c:type="VipsThreadpoolWorkFn">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/threadpool.c"
           line="572">This function is called to process a work unit. Many copies of this can run
at once, so it should not write to the per-pool state. It can write to
per-thread state.

::: seealso
    [func@threadpool_run].</doc>
      <source-position filename="libvips/include/vips/threadpool.h"
                       line="130"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/threadpool.c"
             line="584">0 on success, or -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="state" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/threadpool.c"
               line="574">per-thread state</doc>
          <type name="ThreadState" c:type="VipsThreadState*"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/threadpool.c"
               line="575">client data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="Token"
                 introspectable="0"
                 glib:type-name="VipsToken"
                 glib:get-type="vips_token_get_type"
                 c:type="VipsToken">
      <doc xml:space="preserve"
           filename="libvips/include/vips/util.h"
           line="303">Tokens returned by the vips lexical analyzer, see vips__token_get(). This
is used to parse option strings for arguments.

Left and right brackets can be any of (, {, [, &lt;.

Strings may be in double quotes, and may contain escaped quote characters,
for example string, "string" and "str\"ing".</doc>
      <member name="left"
              value="1"
              c:identifier="VIPS_TOKEN_LEFT"
              glib:nick="left"
              glib:name="VIPS_TOKEN_LEFT">
        <doc xml:space="preserve"
             filename="libvips/include/vips/util.h"
             line="305">left bracket</doc>
      </member>
      <member name="right"
              value="2"
              c:identifier="VIPS_TOKEN_RIGHT"
              glib:nick="right"
              glib:name="VIPS_TOKEN_RIGHT">
        <doc xml:space="preserve"
             filename="libvips/include/vips/util.h"
             line="306">right bracket</doc>
      </member>
      <member name="string"
              value="3"
              c:identifier="VIPS_TOKEN_STRING"
              glib:nick="string"
              glib:name="VIPS_TOKEN_STRING">
        <doc xml:space="preserve"
             filename="libvips/include/vips/util.h"
             line="307">string constant</doc>
      </member>
      <member name="equals"
              value="4"
              c:identifier="VIPS_TOKEN_EQUALS"
              glib:nick="equals"
              glib:name="VIPS_TOKEN_EQUALS">
        <doc xml:space="preserve"
             filename="libvips/include/vips/util.h"
             line="308">equals sign</doc>
      </member>
      <member name="comma"
              value="5"
              c:identifier="VIPS_TOKEN_COMMA"
              glib:nick="comma"
              glib:name="VIPS_TOKEN_COMMA">
        <doc xml:space="preserve"
             filename="libvips/include/vips/util.h"
             line="309">comma</doc>
      </member>
    </enumeration>
    <callback name="TypeMap2Fn" c:type="VipsTypeMap2Fn">
      <source-position filename="libvips/include/vips/object.h" line="669"/>
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="TypeMapFn" c:type="VipsTypeMapFn">
      <source-position filename="libvips/include/vips/object.h" line="668"/>
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <function-macro name="UNREF" c:identifier="VIPS_UNREF" introspectable="0">
      <source-position filename="libvips/include/vips/object.h" line="46"/>
      <parameters>
        <parameter name="X">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="UNROLL"
                    c:identifier="VIPS_UNROLL"
                    introspectable="0">
      <source-position filename="libvips/include/vips/util.h" line="110"/>
      <parameters>
        <parameter name="N">
        </parameter>
        <parameter name="OPER">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="VERSION" value="8.18.0" c:type="VIPS_VERSION">
      <source-position filename="libvips/include/vips/version.h" line="7"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VERSION_STRING"
              value="8.18.0"
              c:type="VIPS_VERSION_STRING">
      <source-position filename="libvips/include/vips/version.h" line="8"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <function name="add_option_entries" c:identifier="vips_add_option_entries">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/init.c"
           line="927">Add the standard vips [struct@GLib.OptionEntry] to a
[struct@GLib.OptionGroup].

::: seealso
    [ctor@GLib.OptionGroup.new].</doc>
      <source-position filename="libvips/include/vips/vips.h" line="180"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="option_group" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/init.c"
               line="929">group to add to</doc>
          <type name="GLib.OptionGroup" c:type="GOptionGroup*"/>
        </parameter>
      </parameters>
    </function>
    <function name="allocate_input_array"
              c:identifier="vips_allocate_input_array"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/generate.c"
           line="536">Convenience function -- make a `NULL`-terminated array of input images.
Use with [func@start_many].

::: seealso
    [method@Image.generate], [func@start_many].</doc>
      <source-position filename="libvips/include/vips/generate.h" line="73"/>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/generate.c"
             line="547">`NULL`-terminated array of images.
  Do not free the result.</doc>
        <type name="Image" c:type="VipsImage**"/>
      </return-value>
      <parameters>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/generate.c"
               line="538">free array when this image closes</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/generate.c"
               line="539">`NULL`-terminated list of input images</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="amiMSBfirst" c:identifier="vips_amiMSBfirst">
      <source-position filename="libvips/include/vips/util.h" line="339"/>
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
    </function>
    <function name="analyzeload"
              c:identifier="vips_analyzeload"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/analyzeload.c"
           line="155">Load an Analyze 6.0 file. If @filename is "fred.img", this will look for
an image header called "fred.hdr" and pixel data in "fred.img". You can
also load "fred" or "fred.hdr".

Images are
loaded lazilly and byte-swapped, if necessary. The Analyze metadata is read
and attached.

::: seealso
    [ctor@Image.new_from_file].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="669"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/analyzeload.c"
             line="172">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/analyzeload.c"
               line="157">file to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/analyzeload.c"
               line="158">decompressed image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/analyzeload.c"
               line="159">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="area_free_cb"
              c:identifier="vips_area_free_cb"
              moved-to="Area.free_cb">
      <source-position filename="libvips/include/vips/type.h" line="103"/>
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="mem"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="area" transfer-ownership="none">
          <type name="Area" c:type="VipsArea*"/>
        </parameter>
      </parameters>
    </function>
    <function name="argument_class_map"
              c:identifier="vips_argument_class_map"
              moved-to="ArgumentClass.map"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/object.c"
           line="620">And loop over a class. Same as ^^, but with no VipsArgumentInstance.</doc>
      <source-position filename="libvips/include/vips/object.h" line="334"/>
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="object_class" transfer-ownership="none">
          <type name="ObjectClass" c:type="VipsObjectClass*"/>
        </parameter>
        <parameter name="fn" transfer-ownership="none">
          <type name="ArgumentClassMapFn" c:type="VipsArgumentClassMapFn"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="argument_get_id"
              c:identifier="vips_argument_get_id"
              moved-to="Argument.get_id"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/object.c"
           line="230">Allocate a new property id. See
[method@GObject.ObjectClass.install_property].</doc>
      <source-position filename="libvips/include/vips/object.h" line="312"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="236">a new property id &gt; 0</doc>
        <type name="gint" c:type="int"/>
      </return-value>
    </function>
    <function name="argument_map"
              c:identifier="vips_argument_map"
              moved-to="Argument.map">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/object.c"
           line="576">Loop over the [struct@Argument] of an object. Stop when @fn returns non-`NULL`
and return that value.</doc>
      <source-position filename="libvips/include/vips/object.h" line="325"/>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="586">`NULL` if @fn returns `NULL` for all arguments, otherwise the first
non-`NULL` value from @fn.</doc>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/object.c"
               line="578">object whose args should be enumerated</doc>
          <type name="Object" c:type="VipsObject*"/>
        </parameter>
        <parameter name="fn"
                   transfer-ownership="none"
                   scope="call"
                   closure="2">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/object.c"
               line="579">call this function for every argument</doc>
          <type name="ArgumentMapFn" c:type="VipsArgumentMapFn"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/object.c"
               line="580">client data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/object.c"
               line="581">client data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="arrayjoin"
              c:identifier="vips_arrayjoin"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/conversion/arrayjoin.c"
           line="471">Lay out the images in @in in a grid. The grid is @across images across and
however high is necessary to use up all of @in. Images are set down
left-to-right and top-to-bottom. @across defaults to @n.

Each input image is placed with a box of size @hspacing by @vspacing
pixels and cropped. These default to the largest width and largest height
of the input images.

Space between images is filled with @background. This defaults to 0
(black).

Images are positioned within their @hspacing by @vspacing box at low,
centre or high coordinate values, controlled by @halign and @valign. These
default to left-top.

Boxes are joined and separated by @shim pixels. This defaults to 0.

If the number of bands in the input images differs, all but one of the
images must have one band. In this case, an n-band image is formed from the
one-band image by joining n copies of the one-band image together, and then
the n-band images are operated upon.

The input images are cast up to the smallest common type (see table
Smallest common format in
[arithmetic](libvips-arithmetic.html)).

[method@Image.colourspace] can be useful for moving the images to a common
colourspace for compositing.

::: tip "Optional arguments"
    * @across: `gint`, number of images per row
    * @shim: `gint`, space between images, in pixels
    * @background: [struct@ArrayDouble], background ink colour
    * @halign: [enum@Align], low, centre or high alignment
    * @valign: [enum@Align], low, centre or high alignment
    * @hspacing: `gint`, horizontal distance between images
    * @vspacing: `gint`, vertical distance between images

::: seealso
    [method@Image.join], [method@Image.insert], [method@Image.colourspace].</doc>
      <source-position filename="libvips/include/vips/conversion.h"
                       line="173"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/conversion/arrayjoin.c"
             line="519">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/arrayjoin.c"
               line="473">array of input images</doc>
          <array length="2" zero-terminated="0" c:type="VipsImage**">
            <type name="Image" c:type="VipsImage*"/>
          </array>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/conversion/arrayjoin.c"
               line="474">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/arrayjoin.c"
               line="475">number of input images</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/arrayjoin.c"
               line="476">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="band_format_is8bit"
              c:identifier="vips_band_format_is8bit"
              moved-to="BandFormat.is8bit">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/image.c"
           line="3776">Return `TRUE` if @format is uchar or schar.</doc>
      <source-position filename="libvips/include/vips/image.h" line="572"/>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="3778">format to test</doc>
          <type name="BandFormat" c:type="VipsBandFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="band_format_iscomplex"
              c:identifier="vips_band_format_iscomplex"
              moved-to="BandFormat.iscomplex">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/image.c"
           line="3836">Return `TRUE` if @fmt is one of the complex types.</doc>
      <source-position filename="libvips/include/vips/image.h" line="576"/>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="3838">format to test</doc>
          <type name="BandFormat" c:type="VipsBandFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="band_format_isfloat"
              c:identifier="vips_band_format_isfloat"
              moved-to="BandFormat.isfloat">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/image.c"
           line="3806">Return `TRUE` if @format is one of the float types.</doc>
      <source-position filename="libvips/include/vips/image.h" line="574"/>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="3808">format to test</doc>
          <type name="BandFormat" c:type="VipsBandFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="band_format_isint"
              c:identifier="vips_band_format_isint"
              moved-to="BandFormat.isint">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/image.c"
           line="3716">Return `TRUE` if @format is one of the integer types.</doc>
      <source-position filename="libvips/include/vips/image.h" line="568"/>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="3718">format to test</doc>
          <type name="BandFormat" c:type="VipsBandFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="band_format_isuint"
              c:identifier="vips_band_format_isuint"
              moved-to="BandFormat.isuint">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/image.c"
           line="3746">Return `TRUE` if @format is one of the unsigned integer types.</doc>
      <source-position filename="libvips/include/vips/image.h" line="570"/>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="3748">format to test</doc>
          <type name="BandFormat" c:type="VipsBandFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="bandjoin" c:identifier="vips_bandjoin" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/conversion/bandjoin.c"
           line="228">Join a set of images together, bandwise.

If the images
have n and m bands, then the output image will have n + m
bands, with the first n coming from the first image and the last m
from the second.

If the images differ in size, the smaller images are enlarged to match the
larger by adding zero pixels along the bottom and right.

The input images are cast up to the smallest common type (see table
Smallest common format in
[arithmetic](libvips-arithmetic.html)).

::: seealso
    [method@Image.insert].</doc>
      <source-position filename="libvips/include/vips/conversion.h"
                       line="273"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/conversion/bandjoin.c"
             line="252">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/bandjoin.c"
               line="230">array of input images</doc>
          <array length="2" zero-terminated="0" c:type="VipsImage**">
            <type name="Image" c:type="VipsImage*"/>
          </array>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/conversion/bandjoin.c"
               line="231">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/bandjoin.c"
               line="232">number of input images</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/bandjoin.c"
               line="233">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="bandrank" c:identifier="vips_bandrank" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/conversion/bandrank.c"
           line="289">Sorts the images @in band-element-wise, then outputs an
image in which each band element is selected from the sorted list by the
@index parameter. For example, if @index
is zero, then each output band element will be the minimum of all the
corresponding input band elements.

By default, @index is -1, meaning pick the median value.

It works for any uncoded, non-complex image type. Images are cast up to the
smallest common-format.

Any image can have either 1 band or n bands, where n is the same for all
the non-1-band images. Single band images are then effectively copied to
make n-band images.

Smaller input images are expanded by adding black pixels.

::: tip "Optional arguments"
    * @index: `gint`, pick this index from list of sorted values

::: seealso
    [method@Image.rank].</doc>
      <source-position filename="libvips/include/vips/conversion.h"
                       line="285"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/conversion/bandrank.c"
             line="319">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/bandrank.c"
               line="291">array of input images</doc>
          <array length="2" zero-terminated="0" c:type="VipsImage**">
            <type name="Image" c:type="VipsImage*"/>
          </array>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/conversion/bandrank.c"
               line="292">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/bandrank.c"
               line="293">number of input images</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/bandrank.c"
               line="294">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="black" c:identifier="vips_black" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/create/black.c"
           line="167">Make a black unsigned char image of a specified size.

::: tip "Optional arguments"
    * @bands: `gint`, output bands

::: seealso
    [ctor@Image.xyz], [ctor@Image.text], [ctor@Image.gaussnoise].</doc>
      <source-position filename="libvips/include/vips/create.h" line="58"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/create/black.c"
             line="182">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/create/black.c"
               line="169">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/black.c"
               line="170">output width</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/black.c"
               line="171">output height</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/black.c"
               line="172">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="blob_copy"
              c:identifier="vips_blob_copy"
              moved-to="Blob.copy">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/type.c"
           line="648">Like [ctor@Blob.new], but take a copy of the data. Useful for bindings
which struggle with callbacks.

::: seealso
    [ctor@Blob.new].</doc>
      <source-position filename="libvips/include/vips/type.h" line="191"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/type.c"
             line="659">the new [struct@Blob].</doc>
        <type name="Blob" c:type="VipsBlob*"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="650">data to store</doc>
          <array length="1" zero-terminated="0" c:type="void*">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="651">number of bytes in @data</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="block_untrusted_set"
              c:identifier="vips_block_untrusted_set">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/init.c"
           line="1317">Set the block state on all untrusted operations.

```c
vips_block_untrusted_set(TRUE);
```

Will block all untrusted operations from running.

Use `vips -l` at the command-line to see the class hierarchy and which
operations are marked as untrusted.

Set the environment variable `VIPS_BLOCK_UNTRUSTED` to block all untrusted
operations on [func@init].</doc>
      <source-position filename="libvips/include/vips/vips.h" line="186"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="state" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/init.c"
               line="1319">the block state to set</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="break_token" c:identifier="vips_break_token">
      <source-position filename="libvips/include/vips/util.h" line="280"/>
      <return-value transfer-ownership="full">
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="brk" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="cache_drop_all" c:identifier="vips_cache_drop_all">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/cache.c"
           line="845">Drop the whole operation cache, handy for leak tracking. Also called
automatically on [func@shutdown].</doc>
      <source-position filename="libvips/include/vips/operation.h" line="136"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="cache_get_max" c:identifier="vips_cache_get_max">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/cache.c"
           line="1180">Get the maximum number of operations we keep in cache.</doc>
      <source-position filename="libvips/include/vips/operation.h" line="148"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/cache.c"
             line="1185">the maximum number of operations we keep in cache</doc>
        <type name="gint" c:type="int"/>
      </return-value>
    </function>
    <function name="cache_get_max_files"
              c:identifier="vips_cache_get_max_files">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/cache.c"
           line="1233">Get the maximum number of tracked files we allow before we start dropping
cached operations. See [func@tracked_get_files].

libvips only tracks file descriptors it allocates, it can't track ones
allocated by external libraries. If you use an operation like
[ctor@Image.magickload], most of the descriptors it uses won't be included.

::: seealso
    [func@tracked_get_files].</doc>
      <source-position filename="libvips/include/vips/operation.h" line="154"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/cache.c"
             line="1246">the maximum number of tracked files we allow</doc>
        <type name="gint" c:type="int"/>
      </return-value>
    </function>
    <function name="cache_get_max_mem" c:identifier="vips_cache_get_max_mem">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/cache.c"
           line="1216">Get the maximum amount of tracked memory we allow before we start dropping
cached operations. See [func@tracked_get_mem].

::: seealso
    [func@tracked_get_mem].</doc>
      <source-position filename="libvips/include/vips/operation.h" line="152"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/cache.c"
             line="1225">the maximum amount of tracked memory we allow</doc>
        <type name="gsize" c:type="size_t"/>
      </return-value>
    </function>
    <function name="cache_get_size" c:identifier="vips_cache_get_size">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/cache.c"
           line="1193">Get the current number of operations in cache.</doc>
      <source-position filename="libvips/include/vips/operation.h" line="150"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/cache.c"
             line="1198">get the current number of operations in cache.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
    </function>
    <function name="cache_operation_build"
              c:identifier="vips_cache_operation_build">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/cache.c"
           line="1116">A binding-friendly version of [func@cache_operation_buildp].

After calling this, @operation has the same ref count as when it went in,
and the result must be freed with [method@Object.unref_outputs] and
[method@GObject.Object.unref].</doc>
      <source-position filename="libvips/include/vips/operation.h" line="140"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/cache.c"
             line="1126">The built operation.</doc>
        <type name="Operation" c:type="VipsOperation*"/>
      </return-value>
      <parameters>
        <parameter name="operation" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/cache.c"
               line="1118">operation to lookup</doc>
          <type name="Operation" c:type="VipsOperation*"/>
        </parameter>
      </parameters>
    </function>
    <function name="cache_operation_buildp"
              c:identifier="vips_cache_operation_buildp"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/cache.c"
           line="967">Look up @operation in the cache. If we get a hit, unref @operation, ref the
old one and return that through the argument pointer.

If we miss, build and add @operation.

Operators that have been tagged as invalid by [signal@Image::invalidate] are
removed from cache.

Operators with the [flags@Vips.OperationFlags.BLOCKED] flag are never
executed.

Operators with the [flags@Vips.OperationFlags.REVALIDATE] flag are always
executed and any old cache value is replaced.

Operators with the [flags@Vips.OperationFlags.NOCACHE] flag are never cached.</doc>
      <source-position filename="libvips/include/vips/operation.h" line="138"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/cache.c"
             line="987">0 on success, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="operation" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/cache.c"
               line="969">pointer to operation to lookup</doc>
          <type name="Operation" c:type="VipsOperation**"/>
        </parameter>
      </parameters>
    </function>
    <function name="cache_print" c:identifier="vips_cache_print">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/cache.c"
           line="677">Print the whole operation cache to stdout. Handy for debugging.</doc>
      <source-position filename="libvips/include/vips/operation.h" line="142"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="cache_set_dump" c:identifier="vips_cache_set_dump">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/cache.c"
           line="1271">Handy for debugging. Print the operation cache to stdout just before exit.

::: seealso
    [func@cache_set_trace].</doc>
      <source-position filename="libvips/include/vips/operation.h" line="158"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="dump" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/cache.c"
               line="1273">if `TRUE`, dump the operation cache on exit</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="cache_set_max" c:identifier="vips_cache_set_max">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/cache.c"
           line="1146">Set the maximum number of operations we keep in cache.</doc>
      <source-position filename="libvips/include/vips/operation.h" line="144"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="max" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/cache.c"
               line="1148">maximum number of operation to cache</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="cache_set_max_files"
              c:identifier="vips_cache_set_max_files">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/cache.c"
           line="1254">Set the maximum number of tracked files we allow before we start dropping
cached operations. See [func@tracked_get_files].

::: seealso
    [func@tracked_get_files].</doc>
      <source-position filename="libvips/include/vips/operation.h" line="156"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="max_files" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/cache.c"
               line="1256">max open files we allow</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="cache_set_max_mem" c:identifier="vips_cache_set_max_mem">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/cache.c"
           line="1159">Set the maximum amount of tracked memory we allow before we start dropping
cached operations. See [func@tracked_get_mem].

libvips only tracks memory it allocates, it can't track memory allocated by
external libraries. If you use an operation like [ctor@Image.magickload],
most of the memory it uses won't be included.

::: seealso
    [func@tracked_get_mem].</doc>
      <source-position filename="libvips/include/vips/operation.h" line="146"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="max_mem" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/cache.c"
               line="1161">maximum amount of tracked memory we use</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="cache_set_trace" c:identifier="vips_cache_set_trace">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/cache.c"
           line="1286">Handy for debugging. Print operation cache actions to stdout as we run.

You can set the environment variable `VIPS_TRACE` to turn this option on, or
use the command-line flag `--vips-cache-trace`.

::: seealso
    [func@cache_set_dump].</doc>
      <source-position filename="libvips/include/vips/operation.h" line="160"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="trace" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/cache.c"
               line="1288">if `TRUE`, trace the operation cache</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="call" c:identifier="vips_call" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/operation.c"
           line="1033">[func@call] calls the named operation, passing in required arguments and
then setting any optional ones from the remainder of the arguments as a set
of name/value pairs.

For example, [method@Image.embed] takes six required arguments, @in, @out,
@x, @y, @width, @height, and has two optional arguments, @extend and
@background. You can run it with [func@call] like this:

```c
VipsImage *in = ...
VipsImage *out;

if (vips_call("embed", in, &amp;out, 10, 10, 100, 100,
        "extend", VIPS_EXTEND_COPY,
        NULL))
    ... error
```

Normally of course you'd just use the [method@Image.embed] wrapper function and get
type-safety for the required arguments.

::: seealso
    [func@call_split], [func@call_options].</doc>
      <source-position filename="libvips/include/vips/operation.h" line="122"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/operation.c"
             line="1062">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="operation_name" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/operation.c"
               line="1035">name of operation to call</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/operation.c"
               line="1036">required args, then a `NULL`-terminated list of argument/value pairs</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="call_argv" c:identifier="vips_call_argv">
      <source-position filename="libvips/include/vips/operation.h" line="133"/>
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="operation" transfer-ownership="none">
          <type name="Operation" c:type="VipsOperation*"/>
        </parameter>
        <parameter name="argc" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="argv" transfer-ownership="none">
          <type name="utf8" c:type="char**"/>
        </parameter>
      </parameters>
    </function>
    <function name="call_options" c:identifier="vips_call_options">
      <source-position filename="libvips/include/vips/operation.h" line="131"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="group" transfer-ownership="none">
          <type name="GLib.OptionGroup" c:type="GOptionGroup*"/>
        </parameter>
        <parameter name="operation" transfer-ownership="none">
          <type name="Operation" c:type="VipsOperation*"/>
        </parameter>
      </parameters>
    </function>
    <function name="call_required_optional"
              c:identifier="vips_call_required_optional"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/operation.c"
           line="937">This is the main entry point for the C and C++ varargs APIs. @operation
is executed, supplying @required and @optional arguments.

Beware, this can change @operation to point at an old, cached one.</doc>
      <source-position filename="libvips/include/vips/operation.h" line="119"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/operation.c"
             line="948">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="operation" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/operation.c"
               line="939">the operation to execute</doc>
          <type name="Operation" c:type="VipsOperation**"/>
        </parameter>
        <parameter name="required" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/operation.c"
               line="940">`va_list` of required arguments</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
        <parameter name="optional" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/operation.c"
               line="941">`NULL`-terminated `va_list` of name / value pairs</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function name="call_split"
              c:identifier="vips_call_split"
              introspectable="0">
      <source-position filename="libvips/include/vips/operation.h" line="125"/>
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="operation_name" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="optional" transfer-ownership="none">
          <type name="va_list" c:type="va_list"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="call_split_option_string"
              c:identifier="vips_call_split_option_string"
              introspectable="0">
      <source-position filename="libvips/include/vips/operation.h" line="127"/>
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="operation_name" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="option_string" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="optional" transfer-ownership="none">
          <type name="va_list" c:type="va_list"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="check_8or16" c:identifier="vips_check_8or16">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="804">Check that the image is 8 or 16-bit integer, signed or unsigned.
Otherwise set an error message
and return non-zero.

::: seealso
    [func@error].</doc>
      <source-position filename="libvips/include/vips/error.h" line="114"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/error.c"
             line="816">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="806">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="807">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_bandno" c:identifier="vips_check_bandno">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="996">@bandno should be a valid band number (ie. 0 to im-&gt;Bands - 1), or can be
-1, meaning all bands.
If not, set an error message
and return non-zero.

::: seealso
    [func@error].</doc>
      <source-position filename="libvips/include/vips/error.h" line="95"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/error.c"
             line="1010">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="998">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="999">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="bandno" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="1000">band number</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_bands" c:identifier="vips_check_bands">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="511">Check that the image has @bands bands.
Otherwise set an error message
and return non-zero.

::: seealso
    [func@error].</doc>
      <source-position filename="libvips/include/vips/error.h" line="83"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/error.c"
             line="524">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="513">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="514">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="bands" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="515">must have this many bands</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_bands_1or3" c:identifier="vips_check_bands_1or3">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="537">Check that the image has either one or three bands.
Otherwise set an error message
and return non-zero.

::: seealso
    [func@error].</doc>
      <source-position filename="libvips/include/vips/error.h" line="85"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/error.c"
             line="549">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="539">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="540">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_bands_1orn" c:identifier="vips_check_bands_1orn">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="590">Check that the images have the same number of bands, or that one of the
images has just 1 band.
If not, set an error message
and return non-zero.

::: seealso
    [func@error].</doc>
      <source-position filename="libvips/include/vips/error.h" line="89"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/error.c"
             line="604">0 on OK, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="592">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im1" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="593">first image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="im2" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="594">second image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_bands_1orn_unary"
              c:identifier="vips_check_bands_1orn_unary">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="620">Check that an image has 1 or @n bands. Handy for unary operations, cf.
[func@check_bands_1orn].
If not, set an error message
and return non-zero.

::: seealso
    [func@check_bands_1orn].</doc>
      <source-position filename="libvips/include/vips/error.h" line="91"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/error.c"
             line="634">0 on OK, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="622">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="623">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="624">number of bands, or 1</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_bands_atleast"
              c:identifier="vips_check_bands_atleast">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="563">Check that the image has at least @bands bands.
Otherwise set an error message
and return non-zero.

::: seealso
    [func@error].</doc>
      <source-position filename="libvips/include/vips/error.h" line="87"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/error.c"
             line="576">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="565">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="566">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="bands" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="567">at least this many bands</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_bands_same" c:identifier="vips_check_bands_same">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="969">Check that the images have the same number of bands.
If not, set an error message
and return non-zero.

::: seealso
    [func@error].</doc>
      <source-position filename="libvips/include/vips/error.h" line="93"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/error.c"
             line="982">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="971">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im1" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="972">first image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="im2" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="973">second image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_coding" c:identifier="vips_check_coding">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="459">Check that the image has the required @coding.
If not, set an error message
and return non-zero.

::: seealso
    [func@error].</doc>
      <source-position filename="libvips/include/vips/error.h" line="73"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/error.c"
             line="472">0 on OK, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="461">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="462">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="coding" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="463">required coding</doc>
          <type name="Coding" c:type="VipsCoding"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_coding_known" c:identifier="vips_check_coding_known">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="430">Check that the image is uncoded, LABQ coded or RAD coded.
If not, set an error message
and return non-zero.

::: seealso
    [func@error].</doc>
      <source-position filename="libvips/include/vips/error.h" line="75"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/error.c"
             line="442">0 on OK, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="432">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="433">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_coding_noneorlabq"
              c:identifier="vips_check_coding_noneorlabq">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="401">Check that the image is uncoded or LABQ coded.
If not, set an error message
and return non-zero.

::: seealso
    [func@error].</doc>
      <source-position filename="libvips/include/vips/error.h" line="77"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/error.c"
             line="413">0 on OK, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="403">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="404">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_coding_same" c:identifier="vips_check_coding_same">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="1052">Check that the images have the same coding.
If not, set an error message
and return non-zero.

::: seealso
    [func@error].</doc>
      <source-position filename="libvips/include/vips/error.h" line="79"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/error.c"
             line="1065">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="1054">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im1" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="1055">first image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="im2" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="1056">second image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_complex" c:identifier="vips_check_complex">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="672">Check that the image is complex.
Otherwise set an error message
and return non-zero.

::: seealso
    [func@error].</doc>
      <source-position filename="libvips/include/vips/error.h" line="106"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/error.c"
             line="684">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="674">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="675">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_format" c:identifier="vips_check_format">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="725">Check that the image has the specified format.
Otherwise set an error message
and return non-zero.

::: seealso
    [func@error].</doc>
      <source-position filename="libvips/include/vips/error.h" line="110"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/error.c"
             line="738">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="727">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="728">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="fmt" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="729">format to test for</doc>
          <type name="BandFormat" c:type="VipsBandFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_format_same" c:identifier="vips_check_format_same">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="1025">Check that the images have the same format.
If not, set an error message
and return non-zero.

::: seealso
    [func@error].</doc>
      <source-position filename="libvips/include/vips/error.h" line="118"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/error.c"
             line="1038">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="1027">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im1" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="1028">first image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="im2" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="1029">second image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_hist" c:identifier="vips_check_hist">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="1142">Histogram images must have width or height 1, and must not have more than
65536 elements. Return 0 if the image will pass as a histogram, or -1 and
set an error message otherwise.

::: seealso
    [func@error].</doc>
      <source-position filename="libvips/include/vips/error.h" line="128"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/error.c"
             line="1154">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="1144">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="1145">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_int" c:identifier="vips_check_int">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="753">Check that the image is in one of the integer formats.
Otherwise set an error message
and return non-zero.

::: seealso
    [func@error].</doc>
      <source-position filename="libvips/include/vips/error.h" line="98"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/error.c"
             line="765">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="755">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="756">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_matrix" c:identifier="vips_check_matrix">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="1174">Matrix images must have width and height less than 100000 and have 1 band.

Return 0 if the image will pass as a matrix, or -1 and set an error
message otherwise.

@out is set to be @im cast to double and stored in memory. Use
[func@MATRIX] to address values in @out.

You must unref @out when you are done with it.

::: seealso
    [func@MATRIX].</doc>
      <source-position filename="libvips/include/vips/error.h" line="130"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/error.c"
             line="1193">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="1176">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="1177">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="1178">put image as in-memory doubles here</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_mono" c:identifier="vips_check_mono">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="486">Check that the image has exactly one band.
Otherwise set an error message
and return non-zero.

::: seealso
    [func@error].</doc>
      <source-position filename="libvips/include/vips/error.h" line="81"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/error.c"
             line="498">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="488">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="489">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_noncomplex" c:identifier="vips_check_noncomplex">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="647">Check that the image is not complex.
Otherwise set an error message
and return non-zero.

::: seealso
    [func@error].</doc>
      <source-position filename="libvips/include/vips/error.h" line="104"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/error.c"
             line="659">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="649">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="650">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_oddsquare" c:identifier="vips_check_oddsquare">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="942">Check that the image is square and that the sides are odd.
If not, set an error message
and return non-zero.

::: seealso
    [func@error].</doc>
      <source-position filename="libvips/include/vips/error.h" line="122"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/error.c"
             line="954">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="944">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="945">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_precision_intfloat"
              c:identifier="vips_check_precision_intfloat">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="1251">Check that @prec image is either float or int.
If not, set an error message
and return non-zero.

::: seealso
    [func@error].</doc>
      <source-position filename="libvips/include/vips/error.h" line="135"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/error.c"
             line="1263">0 on OK, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="1253">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="precision" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="1254">precision to check</doc>
          <type name="Precision" c:type="VipsPrecision"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_separable" c:identifier="vips_check_separable">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="1224">Separable matrix images must have width or height 1.
Return 0 if the image will pass, or -1 and
set an error message otherwise.

::: seealso
    [func@error].</doc>
      <source-position filename="libvips/include/vips/error.h" line="132"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/error.c"
             line="1236">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="1226">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="1227">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_size_same" c:identifier="vips_check_size_same">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="915">Check that the images have the same size.
If not, set an error message
and return non-zero.

::: seealso
    [func@error].</doc>
      <source-position filename="libvips/include/vips/error.h" line="120"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/error.c"
             line="928">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="917">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im1" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="918">first image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="im2" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="919">second image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_twocomponents"
              c:identifier="vips_check_twocomponents">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="697">Check that the image is has two "components", ie. is a one-band complex or
a two-band non-complex.
Otherwise set an error message
and return non-zero.

::: seealso
    [func@error].</doc>
      <source-position filename="libvips/include/vips/error.h" line="108"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/error.c"
             line="710">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="699">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="700">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_u8or16" c:identifier="vips_check_u8or16">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="833">Check that the image is 8 or 16-bit unsigned integer.
Otherwise set an error message
and return non-zero.

::: seealso
    [func@error].</doc>
      <source-position filename="libvips/include/vips/error.h" line="112"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/error.c"
             line="845">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="835">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="836">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_u8or16orf" c:identifier="vips_check_u8or16orf">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="860">Check that the image is 8 or 16-bit unsigned integer, or float.
Otherwise set an error message and return non-zero.

::: seealso
    [func@error].</doc>
      <source-position filename="libvips/include/vips/error.h" line="116"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/error.c"
             line="871">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="862">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="863">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_uint" c:identifier="vips_check_uint">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="778">Check that the image is in one of the unsigned integer formats.
Otherwise set an error message
and return non-zero.

::: seealso
    [func@error].</doc>
      <source-position filename="libvips/include/vips/error.h" line="100"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/error.c"
             line="790">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="780">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="781">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_uintorf" c:identifier="vips_check_uintorf">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="887">Check that the image is unsigned int or float.
Otherwise set an error message and return non-zero.

::: seealso
    [func@error].</doc>
      <source-position filename="libvips/include/vips/error.h" line="102"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/error.c"
             line="898">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="889">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="890">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_uncoded" c:identifier="vips_check_uncoded">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="376">Check that the image is not coded.
If not, set an error message
and return non-zero.

::: seealso
    [func@error].</doc>
      <source-position filename="libvips/include/vips/error.h" line="71"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/error.c"
             line="388">0 on OK, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="378">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="379">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_vector" c:identifier="vips_check_vector">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="1103">Operations with a vector constant need a 1-element vector, or a vector with
the same number of elements as there are bands in the image, or a 1-band
image and a many-element vector.

::: seealso
    [func@error].</doc>
      <source-position filename="libvips/include/vips/error.h" line="126"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/error.c"
             line="1116">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="1105">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="1106">number of elements in vector</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="1107">image to check against</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_vector_length"
              c:identifier="vips_check_vector_length">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="1079">Check that @n == @len.

::: seealso
    [func@error].</doc>
      <source-position filename="libvips/include/vips/error.h" line="124"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/error.c"
             line="1090">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="1081">the originating domain for the error message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="1082">number of elements in vector</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="1083">number of elements vector should have</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="class_find" c:identifier="vips_class_find">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/object.c"
           line="2869">Search below @basename, return the first class whose name or @nickname
matches.

::: seealso
    [func@type_find]</doc>
      <source-position filename="libvips/include/vips/object.h" line="685"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="2880">the found class.</doc>
        <type name="ObjectClass" c:type="const VipsObjectClass*"/>
      </return-value>
      <parameters>
        <parameter name="basename" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/object.c"
               line="2871">name of base class</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="nickname" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/object.c"
               line="2872">search for a class with this nickname</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="class_map_all"
              c:identifier="vips_class_map_all"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/object.c"
           line="2804">Loop over all the subclasses of @type. Non-abstract classes only.
Stop when @fn returns
non-`NULL` and return that value.</doc>
      <source-position filename="libvips/include/vips/object.h" line="683"/>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="2814">`NULL` if @fn returns `NULL` for all arguments, otherwise the first
non-`NULL` value from @fn.</doc>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/object.c"
               line="2806">base type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="fn" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/object.c"
               line="2807">call this function for every type</doc>
          <type name="ClassMapFn" c:type="VipsClassMapFn"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/object.c"
               line="2808">client data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="col_C2Ccmc" c:identifier="vips_col_C2Ccmc">
      <doc xml:space="preserve"
           filename="libvips/colour/LCh2UCS.c"
           line="102">Calculate Ccmc from C.</doc>
      <source-position filename="libvips/include/vips/colour.h" line="271"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/colour/LCh2UCS.c"
             line="108">Ccmc.</doc>
        <type name="gfloat" c:type="float"/>
      </return-value>
      <parameters>
        <parameter name="C" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/LCh2UCS.c"
               line="104">Chroma</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="col_Ccmc2C" c:identifier="vips_col_Ccmc2C">
      <doc xml:space="preserve"
           filename="libvips/colour/UCS2LCh.c"
           line="161">Calculate C from Ccmc using a table.
Call [func@col_make_tables_CMC] at
least once before using this function.</doc>
      <source-position filename="libvips/include/vips/colour.h" line="280"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/colour/UCS2LCh.c"
             line="169">C.</doc>
        <type name="gfloat" c:type="float"/>
      </return-value>
      <parameters>
        <parameter name="Ccmc" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/UCS2LCh.c"
               line="163">Ccmc</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="col_Ch2ab" c:identifier="vips_col_Ch2ab">
      <doc xml:space="preserve"
           filename="libvips/colour/LCh2Lab.c"
           line="60">Calculate ab from Ch, h in degrees.</doc>
      <source-position filename="libvips/include/vips/colour.h" line="266"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="C" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/LCh2Lab.c"
               line="62">Chroma</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="h" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/LCh2Lab.c"
               line="63">Hue angle (degrees)</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="a" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/LCh2Lab.c"
               line="64">return CIE a* value</doc>
          <type name="gfloat" c:type="float*"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/LCh2Lab.c"
               line="65">return CIE b* value</doc>
          <type name="gfloat" c:type="float*"/>
        </parameter>
      </parameters>
    </function>
    <function name="col_Ch2hcmc" c:identifier="vips_col_Ch2hcmc">
      <doc xml:space="preserve"
           filename="libvips/colour/LCh2UCS.c"
           line="122">Calculate hcmc from C and h.</doc>
      <source-position filename="libvips/include/vips/colour.h" line="273"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/colour/LCh2UCS.c"
             line="129">hcmc.</doc>
        <type name="gfloat" c:type="float"/>
      </return-value>
      <parameters>
        <parameter name="C" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/LCh2UCS.c"
               line="124">Chroma</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="h" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/LCh2UCS.c"
               line="125">Hue (degrees)</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="col_Chcmc2h" c:identifier="vips_col_Chcmc2h">
      <doc xml:space="preserve"
           filename="libvips/colour/UCS2LCh.c"
           line="183">Calculate h from C and hcmc, using a table.
Call [func@col_make_tables_CMC] at
least once before using this function.</doc>
      <source-position filename="libvips/include/vips/colour.h" line="282"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/colour/UCS2LCh.c"
             line="192">h.</doc>
        <type name="gfloat" c:type="float"/>
      </return-value>
      <parameters>
        <parameter name="C" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/UCS2LCh.c"
               line="185">Chroma</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="hcmc" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/UCS2LCh.c"
               line="186">Hue cmc (degrees)</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="col_L2Lcmc" c:identifier="vips_col_L2Lcmc">
      <doc xml:space="preserve"
           filename="libvips/colour/LCh2UCS.c"
           line="81">Calculate Lcmc from L.</doc>
      <source-position filename="libvips/include/vips/colour.h" line="269"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/colour/LCh2UCS.c"
             line="87">Lcmc</doc>
        <type name="gfloat" c:type="float"/>
      </return-value>
      <parameters>
        <parameter name="L" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/LCh2UCS.c"
               line="83">CIE L*</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="col_Lab2XYZ" c:identifier="vips_col_Lab2XYZ">
      <doc xml:space="preserve"
           filename="libvips/colour/Lab2XYZ.c"
           line="229">Calculate XYZ from Lab, D65.

::: seealso
    [method@Image.Lab2XYZ].</doc>
      <source-position filename="libvips/include/vips/colour.h" line="256"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="L" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/Lab2XYZ.c"
               line="231">Input CIE Lab value</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="a" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/Lab2XYZ.c"
               line="232">Input CIE Lab value</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/Lab2XYZ.c"
               line="233">Input CIE Lab value</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="X"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/colour/Lab2XYZ.c"
               line="234">Return CIE XYZ colour</doc>
          <type name="gfloat" c:type="float*"/>
        </parameter>
        <parameter name="Y"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/colour/Lab2XYZ.c"
               line="235">Return CIE XYZ colour</doc>
          <type name="gfloat" c:type="float*"/>
        </parameter>
        <parameter name="Z"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/colour/Lab2XYZ.c"
               line="236">Return CIE XYZ colour</doc>
          <type name="gfloat" c:type="float*"/>
        </parameter>
      </parameters>
    </function>
    <function name="col_Lcmc2L" c:identifier="vips_col_Lcmc2L">
      <doc xml:space="preserve"
           filename="libvips/colour/UCS2LCh.c"
           line="140">Calculate L from Lcmc using a table. Call [func@col_make_tables_CMC] at
least once before using this function.</doc>
      <source-position filename="libvips/include/vips/colour.h" line="278"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/colour/UCS2LCh.c"
             line="147">L*</doc>
        <type name="gfloat" c:type="float"/>
      </return-value>
      <parameters>
        <parameter name="Lcmc" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/UCS2LCh.c"
               line="142">L cmc</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="col_XYZ2Lab" c:identifier="vips_col_XYZ2Lab">
      <doc xml:space="preserve"
           filename="libvips/colour/XYZ2Lab.c"
           line="172">Calculate XYZ from Lab, D65.

::: seealso
    [method@Image.XYZ2Lab].</doc>
      <source-position filename="libvips/include/vips/colour.h" line="259"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="X" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/XYZ2Lab.c"
               line="174">Input CIE XYZ colour</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="Y" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/XYZ2Lab.c"
               line="175">Input CIE XYZ colour</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="Z" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/XYZ2Lab.c"
               line="176">Input CIE XYZ colour</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="L"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/colour/XYZ2Lab.c"
               line="177">Return CIE Lab value</doc>
          <type name="gfloat" c:type="float*"/>
        </parameter>
        <parameter name="a"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/colour/XYZ2Lab.c"
               line="178">Return CIE Lab value</doc>
          <type name="gfloat" c:type="float*"/>
        </parameter>
        <parameter name="b"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/colour/XYZ2Lab.c"
               line="179">Return CIE Lab value</doc>
          <type name="gfloat" c:type="float*"/>
        </parameter>
      </parameters>
    </function>
    <function name="col_XYZ2scRGB" c:identifier="vips_col_XYZ2scRGB">
      <doc xml:space="preserve"
           filename="libvips/colour/LabQ2sRGB.c"
           line="248">Turn XYZ into scRGB.

::: seealso
    [method@Image.XYZ2scRGB].</doc>
      <source-position filename="libvips/include/vips/colour.h" line="299"/>
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="X" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/LabQ2sRGB.c"
               line="250">Input XYZ value</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="Y" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/LabQ2sRGB.c"
               line="251">Input XYZ value</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="Z" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/LabQ2sRGB.c"
               line="252">Input XYZ value</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="R"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/colour/LabQ2sRGB.c"
               line="253">Return scRGB colour</doc>
          <type name="gfloat" c:type="float*"/>
        </parameter>
        <parameter name="G"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/colour/LabQ2sRGB.c"
               line="254">Return scRGB colour</doc>
          <type name="gfloat" c:type="float*"/>
        </parameter>
        <parameter name="B"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/colour/LabQ2sRGB.c"
               line="255">Return scRGB colour</doc>
          <type name="gfloat" c:type="float*"/>
        </parameter>
      </parameters>
    </function>
    <function name="col_ab2Ch" c:identifier="vips_col_ab2Ch">
      <source-position filename="libvips/include/vips/colour.h" line="264"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="a" transfer-ownership="none">
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="C" transfer-ownership="none">
          <type name="gfloat" c:type="float*"/>
        </parameter>
        <parameter name="h" transfer-ownership="none">
          <type name="gfloat" c:type="float*"/>
        </parameter>
      </parameters>
    </function>
    <function name="col_ab2h" c:identifier="vips_col_ab2h">
      <source-position filename="libvips/include/vips/colour.h" line="262"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/colour/Lab2LCh.c"
             line="59">Hue (degrees)</doc>
        <type name="gdouble" c:type="double"/>
      </return-value>
      <parameters>
        <parameter name="a" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/Lab2LCh.c"
               line="56">CIE a</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/Lab2LCh.c"
               line="57">CIE b</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
      </parameters>
    </function>
    <function name="col_dE00" c:identifier="vips_col_dE00">
      <doc xml:space="preserve"
           filename="libvips/colour/dE00.c"
           line="56">CIEDE2000, from:

Luo, Cui, Rigg, "The Development of the CIE 2000 Colour-Difference
Formula: CIEDE2000", COLOR research and application, pp 340</doc>
      <source-position filename="libvips/include/vips/colour.h" line="317"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/colour/dE00.c"
             line="70">CIE dE2000 colour difference.</doc>
        <type name="gfloat" c:type="float"/>
      </return-value>
      <parameters>
        <parameter name="L1" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/dE00.c"
               line="58">Input coordinate 1</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="a1" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/dE00.c"
               line="59">Input coordinate 1</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="b1" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/dE00.c"
               line="60">Input coordinate 1</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="L2" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/dE00.c"
               line="61">Input coordinate 2</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="a2" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/dE00.c"
               line="62">Input coordinate 2</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="b2" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/dE00.c"
               line="63">Input coordinate 2</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="col_make_tables_CMC"
              c:identifier="vips_col_make_tables_CMC">
      <doc xml:space="preserve"
           filename="libvips/colour/UCS2LCh.c"
           line="222">Make the lookup tables for cmc.</doc>
      <source-position filename="libvips/include/vips/colour.h" line="276"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="col_sRGB2scRGB_16" c:identifier="vips_col_sRGB2scRGB_16">
      <source-position filename="libvips/include/vips/colour.h" line="287"/>
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="r" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="g" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="R" transfer-ownership="none">
          <type name="gfloat" c:type="float*"/>
        </parameter>
        <parameter name="G" transfer-ownership="none">
          <type name="gfloat" c:type="float*"/>
        </parameter>
        <parameter name="B" transfer-ownership="none">
          <type name="gfloat" c:type="float*"/>
        </parameter>
      </parameters>
    </function>
    <function name="col_sRGB2scRGB_16_noclip"
              c:identifier="vips_col_sRGB2scRGB_16_noclip">
      <source-position filename="libvips/include/vips/colour.h" line="292"/>
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="r" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="g" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="R" transfer-ownership="none">
          <type name="gfloat" c:type="float*"/>
        </parameter>
        <parameter name="G" transfer-ownership="none">
          <type name="gfloat" c:type="float*"/>
        </parameter>
        <parameter name="B" transfer-ownership="none">
          <type name="gfloat" c:type="float*"/>
        </parameter>
      </parameters>
    </function>
    <function name="col_sRGB2scRGB_8" c:identifier="vips_col_sRGB2scRGB_8">
      <source-position filename="libvips/include/vips/colour.h" line="285"/>
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="r" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="g" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="R" transfer-ownership="none">
          <type name="gfloat" c:type="float*"/>
        </parameter>
        <parameter name="G" transfer-ownership="none">
          <type name="gfloat" c:type="float*"/>
        </parameter>
        <parameter name="B" transfer-ownership="none">
          <type name="gfloat" c:type="float*"/>
        </parameter>
      </parameters>
    </function>
    <function name="col_sRGB2scRGB_8_noclip"
              c:identifier="vips_col_sRGB2scRGB_8_noclip">
      <source-position filename="libvips/include/vips/colour.h" line="289"/>
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="r" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="g" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="R" transfer-ownership="none">
          <type name="gfloat" c:type="float*"/>
        </parameter>
        <parameter name="G" transfer-ownership="none">
          <type name="gfloat" c:type="float*"/>
        </parameter>
        <parameter name="B" transfer-ownership="none">
          <type name="gfloat" c:type="float*"/>
        </parameter>
      </parameters>
    </function>
    <function name="col_scRGB2BW_16" c:identifier="vips_col_scRGB2BW_16">
      <source-position filename="libvips/include/vips/colour.h" line="309"/>
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="R" transfer-ownership="none">
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="G" transfer-ownership="none">
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="B" transfer-ownership="none">
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="g" transfer-ownership="none">
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="og" transfer-ownership="none">
          <type name="gint" c:type="int*"/>
        </parameter>
      </parameters>
    </function>
    <function name="col_scRGB2BW_8" c:identifier="vips_col_scRGB2BW_8">
      <source-position filename="libvips/include/vips/colour.h" line="311"/>
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="R" transfer-ownership="none">
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="G" transfer-ownership="none">
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="B" transfer-ownership="none">
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="g" transfer-ownership="none">
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="og" transfer-ownership="none">
          <type name="gint" c:type="int*"/>
        </parameter>
      </parameters>
    </function>
    <function name="col_scRGB2XYZ" c:identifier="vips_col_scRGB2XYZ">
      <doc xml:space="preserve"
           filename="libvips/colour/LabQ2sRGB.c"
           line="214">Turn scRGB into XYZ.

::: seealso
    [method@Image.scRGB2XYZ].</doc>
      <source-position filename="libvips/include/vips/colour.h" line="296"/>
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="R" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/LabQ2sRGB.c"
               line="216">Input scRGB value</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="G" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/LabQ2sRGB.c"
               line="217">Input scRGB value</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="B" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/LabQ2sRGB.c"
               line="218">Input scRGB value</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="X"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/colour/LabQ2sRGB.c"
               line="219">Return XYZ colour</doc>
          <type name="gfloat" c:type="float*"/>
        </parameter>
        <parameter name="Y"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/colour/LabQ2sRGB.c"
               line="220">Return XYZ colour</doc>
          <type name="gfloat" c:type="float*"/>
        </parameter>
        <parameter name="Z"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/colour/LabQ2sRGB.c"
               line="221">Return XYZ colour</doc>
          <type name="gfloat" c:type="float*"/>
        </parameter>
      </parameters>
    </function>
    <function name="col_scRGB2sRGB_16" c:identifier="vips_col_scRGB2sRGB_16">
      <source-position filename="libvips/include/vips/colour.h" line="306"/>
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="R" transfer-ownership="none">
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="G" transfer-ownership="none">
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="B" transfer-ownership="none">
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="r" transfer-ownership="none">
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="g" transfer-ownership="none">
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="og" transfer-ownership="none">
          <type name="gint" c:type="int*"/>
        </parameter>
      </parameters>
    </function>
    <function name="col_scRGB2sRGB_8" c:identifier="vips_col_scRGB2sRGB_8">
      <source-position filename="libvips/include/vips/colour.h" line="303"/>
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="R" transfer-ownership="none">
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="G" transfer-ownership="none">
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="B" transfer-ownership="none">
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="r" transfer-ownership="none">
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="g" transfer-ownership="none">
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="og" transfer-ownership="none">
          <type name="gint" c:type="int*"/>
        </parameter>
      </parameters>
    </function>
    <function name="composite"
              c:identifier="vips_composite"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/conversion/conversion.c"
           line="52">Composite an array of images together.

Images are placed in a stack, with @in[0] at the bottom and @in[@n - 1] at
the top. Pixels are blended together working from the bottom upwards, with
the blend mode at each step being set by the corresponding [enum@BlendMode]
in @mode.

Images are transformed to a compositing space before processing. This is
[enum@Vips.Interpretation.sRGB], [enum@Vips.Interpretation.B_W],
[enum@Vips.Interpretation.RGB16], or [enum@Vips.Interpretation.GREY16]
by default, depending on
how many bands and bits the input images have. You can select any other
space, such as [enum@Vips.Interpretation.LAB] or
[enum@Vips.Interpretation.scRGB].

The output image is in the compositing space. It will always be
[enum@Vips.BandFormat.FLOAT] unless one of the inputs is
[enum@Vips.BandFormat.DOUBLE], in which case the output will be double
as well.

Complex images are not supported.

The output image will always have an alpha band. A solid alpha is
added to any input missing an alpha.

The images do not need to match in size or format. The output image is
always the size of @in[0], with other images being
positioned with the @x and @y parameters and clipped
against that rectangle.

Image are normally treated as unpremultiplied, so this operation can be used
directly on PNG images. If your images have been through
[method@Image.premultiply], set @premultiplied.

::: tip "Optional arguments"
    * @compositing_space: [enum@Interpretation] to composite in
    * @premultiplied: `gboolean`, images are already premultiplied
    * @x: [struct@ArrayInt], array of (@n - 1) x coordinates
    * @y: [struct@ArrayInt], array of (@n - 1) y coordinates

::: seealso
    [method@Image.insert].</doc>
      <source-position filename="libvips/include/vips/conversion.h"
                       line="336"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/conversion/conversion.c"
             line="103">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/conversion.c"
               line="54">array of input images</doc>
          <array length="2" zero-terminated="0" c:type="VipsImage**">
            <type name="Image" c:type="VipsImage*"/>
          </array>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/conversion/conversion.c"
               line="55">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/conversion.c"
               line="56">number of input images</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="mode" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/conversion.c"
               line="57">array of (@n - 1) [enum@BlendMode]</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/conversion.c"
               line="58">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="concurrency_get" c:identifier="vips_concurrency_get">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/thread.c"
           line="221">Returns the number of worker threads that vips should use when running
[func@threadpool_run].

vips gets this values from these sources in turn:

If [func@concurrency_set] has been called, this value is used. The special
value 0 means "default". You can also use the command-line argument
`--vips-concurrency` to set this value.

If [func@concurrency_set] has not been called and no command-line argument
was used, vips uses the value of the environment variable `VIPS_CONCURRENCY`.

If `VIPS_CONCURRENCY` has not been set, vips finds the number of hardware
threads that the host machine can run in parallel and uses that value.

The final value is clipped to the range 1 - 1024.

::: seealso
    [func@concurrency_get].</doc>
      <source-position filename="libvips/include/vips/operation.h" line="168"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/thread.c"
             line="244">number of worker threads to use.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
    </function>
    <function name="concurrency_set" c:identifier="vips_concurrency_set">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/thread.c"
           line="191">Sets the number of worker threads that vips should use when running
[func@threadpool_run].

The special value 0 means "default". In this case, the number of threads
is set by the environment variable `VIPS_CONCURRENCY`, or if that is not
set, the number of threads available on the host machine.

::: seealso
    [func@concurrency_get].</doc>
      <source-position filename="libvips/include/vips/operation.h" line="166"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="concurrency" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/thread.c"
               line="193">number of threads to run</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="csvload" c:identifier="vips_csvload" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/csvload.c"
           line="666">Load a CSV (comma-separated values) file.

The output image is always 1 band (monochrome),
[enum@Vips.BandFormat.DOUBLE]. Use [method@Image.bandfold] to turn
RGBRGBRGB mono images into colour images.

Items in lines can be either floating point numbers in the C locale, or
strings enclosed in double-quotes ("), or empty.
You can use a backslash (\) within the quotes to escape special characters,
such as quote marks.

@skip sets the number of lines to skip at the start of the file.
Default zero.

@lines sets the number of lines to read from the file. Default -1,
meaning read all lines to end of file.

@whitespace sets the skippable whitespace characters.
Default *space*.
Whitespace characters are always run together.

@separator sets the characters that separate fields.
Default ;,*tab*. Separators are never run together.

Use @fail_on to set the type of error that will cause load to fail. By
default, loaders are permissive, that is, [enum@Vips.FailOn.NONE].

::: tip "Optional arguments"
    * @skip: `gint`, skip this many lines at start of file
    * @lines: `gint`, read this many lines from file
    * @whitespace: `gchararray`, set of whitespace characters
    * @separator: `gchararray`, set of separator characters
    * @fail_on: [enum@FailOn], types of read error to fail on

::: seealso
    [ctor@Image.new_from_file], [method@Image.bandfold].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="687"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/csvload.c"
             line="709">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/csvload.c"
               line="668">file to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/csvload.c"
               line="669">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/csvload.c"
               line="670">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="csvload_source"
              c:identifier="vips_csvload_source"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/csvload.c"
           line="724">Exactly as [ctor@Image.csvload], but read from a source.

::: tip "Optional arguments"
    * @skip: `gint`, skip this many lines at start of file
    * @lines: `gint`, read this many lines from file
    * @whitespace: `gchararray`, set of whitespace characters
    * @separator: `gchararray`, set of separator characters
    * @fail_on: [enum@FailOn], types of read error to fail on

::: seealso
    [ctor@Image.csvload].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="690"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/csvload.c"
             line="742">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="source" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/csvload.c"
               line="726">source to load</doc>
          <type name="Source" c:type="VipsSource*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/csvload.c"
               line="727">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/csvload.c"
               line="728">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="dcrawload"
              c:identifier="vips_dcrawload"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/dcrawload.c"
           line="651">Read a RAW camera file using LibRaw.

This loader supports the most RAW formats, including
ARW, CR2, CR3, CRW, DNG, NEF, NRW, ORF, PEF, RAF, RAW, RW2, SRW, X3F, and
many others.

The loader applies demosaicing and basic processing to produce an RGB or
grayscale image suitable for further processing. It attaches XMP and ICC
metadata, if present.

::: tip "Optional arguments"
    * @bitdepth: `gint`, load as 8 or 16 bit data</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="908"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/dcrawload.c"
             line="670">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/dcrawload.c"
               line="653">file to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/dcrawload.c"
               line="654">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/dcrawload.c"
               line="655">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="dcrawload_buffer"
              c:identifier="vips_dcrawload_buffer"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/dcrawload.c"
           line="714">Exactly as [ctor@Image.dcrawload], but read from a buffer.

::: tip "Optional arguments"
    * @bitdepth: `gint`, load as 8 or 16 bit data

::: seealso
    [ctor@Image.dcrawload].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="911"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/dcrawload.c"
             line="729">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="buf" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/dcrawload.c"
               line="716">memory area to load</doc>
          <array length="1" zero-terminated="0" c:type="void*">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/dcrawload.c"
               line="717">size of memory area</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/dcrawload.c"
               line="718">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/dcrawload.c"
               line="719">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="dcrawload_source"
              c:identifier="vips_dcrawload_source"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/dcrawload.c"
           line="685">Exactly as [ctor@Image.dcrawload], but read from a source.

::: tip "Optional arguments"
    * @bitdepth: `gint`, load as 8 or 16 bit data

::: seealso
    [ctor@Image.dcrawload].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="914"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/dcrawload.c"
             line="699">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="source" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/dcrawload.c"
               line="687">source to load from</doc>
          <type name="Source" c:type="VipsSource*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/dcrawload.c"
               line="688">image to write</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/dcrawload.c"
               line="689">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="enum_from_nick" c:identifier="vips_enum_from_nick">
      <source-position filename="libvips/include/vips/util.h" line="248"/>
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="str" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="enum_nick" c:identifier="vips_enum_nick">
      <source-position filename="libvips/include/vips/util.h" line="246"/>
      <return-value transfer-ownership="none">
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="enm" transfer-ownership="none">
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="enum_string" c:identifier="vips_enum_string">
      <source-position filename="libvips/include/vips/util.h" line="244"/>
      <return-value transfer-ownership="none">
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="enm" transfer-ownership="none">
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="error" c:identifier="vips_error" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="202">Format the string in the style of [`printf()`](man:printf(3)) and append to the error buffer.

::: seealso
    [func@error_system], [func@verror].</doc>
      <source-position filename="libvips/include/vips/error.h" line="51"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="204">the source of the error</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="fmt" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="205">`printf()`-style format string for the error</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="206">arguments to the format string</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="error_buffer" c:identifier="vips_error_buffer">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="108">Get a pointer to the start of the error buffer as a C string.
The string is owned by the error system and must not be freed.

::: seealso
    [func@error_clear].</doc>
      <source-position filename="libvips/include/vips/error.h" line="39"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/error.c"
             line="117">the error buffer as a C string which must not be freed</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
    </function>
    <function name="error_buffer_copy" c:identifier="vips_error_buffer_copy">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="131">Return a copy of the vips error buffer, and clear it.</doc>
      <source-position filename="libvips/include/vips/error.h" line="41"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/error.c"
             line="136">a copy of the libvips error buffer</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
    </function>
    <function name="error_clear" c:identifier="vips_error_clear">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="319">Clear and reset the error buffer. This is typically called after presenting
an error to the user.

::: seealso
    [func@error_buffer].</doc>
      <source-position filename="libvips/include/vips/error.h" line="43"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="error_exit"
              c:identifier="vips_error_exit"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="336">Sends a formatted error message to stderr, then sends the contents of the
error buffer, if any, then shuts down vips and terminates the program with
an error code.

@fmt may be `NULL`, in which case only the error buffer is printed before
exiting.

::: seealso
    [func@error].</doc>
      <source-position filename="libvips/include/vips/error.h" line="67"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="fmt" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="338">`printf()`-style format string for the message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="339">arguments to the format string</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="error_freeze" c:identifier="vips_error_freeze">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="79">Stop errors being logged. Use [func@error_thaw] to unfreeze. You can
nest freeze/thaw pairs.</doc>
      <source-position filename="libvips/include/vips/error.h" line="46"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="error_g" c:identifier="vips_error_g" throws="1">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="268">This function sets the glib error pointer from the vips error buffer and
clears it. It's handy for returning errors to glib functions from vips.

See [func@g_error] for the inverse operation.

::: seealso
    [func@GLib.set_error], [func@g_error].</doc>
      <source-position filename="libvips/include/vips/error.h" line="62"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="error_system"
              c:identifier="vips_error_system"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="244">Format the string in the style of [`printf()`](man:printf(3)) and append to the error buffer.
Then create and append a localised message based on the system error code,
usually the value of errno.

::: seealso
    [func@verror_system].</doc>
      <source-position filename="libvips/include/vips/error.h" line="56"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="err" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="246">the system error code</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="247">the source of the error</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="fmt" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="248">`printf()`-style format string for the error</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="249">arguments to the format string</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="error_thaw" c:identifier="vips_error_thaw">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="94">Re-enable error logging.</doc>
      <source-position filename="libvips/include/vips/error.h" line="48"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="existsf" c:identifier="vips_existsf" introspectable="0">
      <source-position filename="libvips/include/vips/util.h" line="289"/>
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="eye" c:identifier="vips_eye" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/create/eye.c"
           line="121">Create a test pattern with increasing spatial frequency in X and
amplitude in Y.

@factor should be between 0 and 1 and determines the
maximum spatial frequency.

Set @uchar to output a uchar image.

::: tip "Optional arguments"
    * @factor: `gdouble`, maximum spatial frequency
    * @uchar: `gboolean`, output a uchar image

::: seealso
    [ctor@Image.zone].</doc>
      <source-position filename="libvips/include/vips/create.h" line="82"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/create/eye.c"
             line="143">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/create/eye.c"
               line="123">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/eye.c"
               line="124">image size</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/eye.c"
               line="125">image size</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/eye.c"
               line="126">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="file_length" c:identifier="vips_file_length">
      <source-position filename="libvips/include/vips/util.h" line="286"/>
      <return-value transfer-ownership="none">
        <type name="gint64" c:type="gint64"/>
      </return-value>
      <parameters>
        <parameter name="fd" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="filename_get_filename"
              c:identifier="vips_filename_get_filename">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/image.c"
           line="1785">Given a vips filename like "fred.jpg[Q=90]", return a new string of
just the filename part, "fred.jpg" in this case.

Useful for language bindings.

::: seealso
    [func@filename_get_options].</doc>
      <source-position filename="libvips/include/vips/image.h" line="463"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="1797">transfer full: just the filename component.</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="vips_filename" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="1787">a filename including a set of options</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="filename_get_options"
              c:identifier="vips_filename_get_options">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/image.c"
           line="1810">Given a vips filename like "fred.jpg[Q=90]", return a new string of
just the options part, "[Q=90]" in this case.

Useful for language bindings.

::: seealso
    [func@filename_get_filename].</doc>
      <source-position filename="libvips/include/vips/image.h" line="465"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="1822">transfer full: just the options component.</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="vips_filename" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="1812">a filename including a set of options</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="filename_suffix_match"
              c:identifier="vips_filename_suffix_match">
      <source-position filename="libvips/include/vips/util.h" line="283"/>
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="path" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="suffixes" transfer-ownership="none">
          <type name="utf8" c:type="const char**"/>
        </parameter>
      </parameters>
    </function>
    <function name="fitsload" c:identifier="vips_fitsload" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/fitsload.c"
           line="344">Read a FITS image file into a VIPS image.

This operation can read images with up to three dimensions. Any higher
dimensions must be empty.

It can read 8, 16 and 32-bit integer images, signed and unsigned, float and
double.

FITS metadata is attached with the "fits-" prefix.

::: seealso
    [ctor@Image.new_from_file].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="659"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/fitsload.c"
             line="363">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/fitsload.c"
               line="346">file to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/fitsload.c"
               line="347">decompressed image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/fitsload.c"
               line="348">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="fitsload_source"
              c:identifier="vips_fitsload_source"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/fitsload.c"
           line="378">Exactly as [ctor@Image.fitsload], but read from a source.</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="662"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/fitsload.c"
             line="386">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="source" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/fitsload.c"
               line="380">source to load from</doc>
          <type name="Source" c:type="VipsSource*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/fitsload.c"
               line="381">decompressed image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/fitsload.c"
               line="382">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="flags_from_nick" c:identifier="vips_flags_from_nick">
      <source-position filename="libvips/include/vips/util.h" line="250"/>
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="foreign_flags" c:identifier="vips_foreign_flags">
      <doc xml:space="preserve"
           filename="libvips/foreign/foreign.c"
           line="868">Return the flags for @filename using @loader.
@loader is something like "tiffload" or "VipsForeignLoadTiff".</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="282"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/foreign.c"
             line="876">the flags for @filename.</doc>
        <type name="ForeignFlags" c:type="VipsForeignFlags"/>
      </return-value>
      <parameters>
        <parameter name="loader" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="870">name of loader to use for test</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="871">file to test</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="format_sizeof" c:identifier="vips_format_sizeof">
      <source-position filename="libvips/include/vips/header.h" line="196"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="161">number of bytes for a band format.</doc>
        <type name="guint64" c:type="guint64"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="159">format type</doc>
          <type name="BandFormat" c:type="VipsBandFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="format_sizeof_unsafe"
              c:identifier="vips_format_sizeof_unsafe"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/header.c"
           line="171">A fast but dangerous version of [func@format_sizeof]. You must have
previously range-checked @format or you'll crash.</doc>
      <source-position filename="libvips/include/vips/header.h" line="198"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="178">number of bytes for a band format.</doc>
        <type name="guint64" c:type="guint64"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="173">format type</doc>
          <type name="BandFormat" c:type="VipsBandFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="fractsurf"
              c:identifier="vips_fractsurf"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/create/fractsurf.c"
           line="133">Generate an image of size @width by @height and fractal dimension
@fractal_dimension. The dimension should be between 2 and 3.

::: seealso
    [ctor@Image.gaussnoise], [ctor@Image.mask_fractal].</doc>
      <source-position filename="libvips/include/vips/create.h" line="157"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/create/fractsurf.c"
             line="147">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/create/fractsurf.c"
               line="135">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/fractsurf.c"
               line="136">output width</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/fractsurf.c"
               line="137">output height</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="fractal_dimension" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/fractsurf.c"
               line="138">fractal dimension</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/fractsurf.c"
               line="139">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="g_error" c:identifier="vips_g_error" throws="1">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="298">This function adds the [struct@GLib.Error] to the vips error buffer and clears it. It's
the opposite of [func@error_g].

::: seealso
    [func@error_g].</doc>
      <source-position filename="libvips/include/vips/error.h" line="64"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="g_thread_new" c:identifier="vips_g_thread_new">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/thread.c"
           line="117">Wrapper for [ctor@GLib.Thread.try_new].</doc>
      <source-position filename="libvips/include/vips/thread.h" line="40"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/thread.c"
             line="125">the new [struct@GLib.Thread], or `NULL` if an
error occurred</doc>
        <type name="GLib.Thread" c:type="GThread*"/>
      </return-value>
      <parameters>
        <parameter name="domain"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/thread.c"
               line="119">an (optional) name for the new thread</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="func"
                   transfer-ownership="none"
                   scope="async"
                   closure="2">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/thread.c"
               line="120">a function to execute in the new thread</doc>
          <type name="GLib.ThreadFunc" c:type="GThreadFunc"/>
        </parameter>
        <parameter name="data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/thread.c"
               line="121">an argument to supply to the new thread</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="gaussmat" c:identifier="vips_gaussmat" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/create/gaussmat.c"
           line="228">Creates a circularly symmetric Gaussian image of radius
@sigma.

The size of the mask is determined by the variable @min_ampl;
if for instance the value .1 is entered this means that the produced mask
is clipped at values less than 10 percent of the maximum amplitude.

The program uses the following equation:

```
H(r) = exp(-(r * r) / (2 * @sigma * @sigma))
```

The generated image has odd size and its maximum value is normalised to
1.0, unless @precision is [enum@Vips.Precision.INTEGER].

If @separable is set, only the centre horizontal is generated. This is
useful for separable convolutions.

If @precision is [enum@Vips.Precision.INTEGER], an integer gaussian is
generated. This is useful for integer convolutions.

"scale" is set to the sum of all the mask elements.

::: tip "Optional arguments"
    * @separable: `gboolean`, generate a separable gaussian
    * @precision: [enum@Precision] for @out

::: seealso
    [ctor@Image.logmat], [method@Image.conv].</doc>
      <source-position filename="libvips/include/vips/create.h" line="68"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/create/gaussmat.c"
             line="266">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/create/gaussmat.c"
               line="230">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="sigma" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/gaussmat.c"
               line="231">standard deviation of mask</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="min_ampl" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/gaussmat.c"
               line="232">minimum amplitude</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/gaussmat.c"
               line="233">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="gaussnoise"
              c:identifier="vips_gaussnoise"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/create/gaussnoise.c"
           line="211">Make a one band float image of gaussian noise with the specified
distribution.

The gaussian distribution is created by averaging 12 random numbers from a
linear generator, then weighting appropriately with @mean and @sigma.

::: tip "Optional arguments"
    * @mean: `gdouble`, mean of generated pixels
    * @sigma: `gdouble`, standard deviation of generated pixels

::: seealso
    [ctor@Image.black], [ctor@Image.xyz], [ctor@Image.text].</doc>
      <source-position filename="libvips/include/vips/create.h" line="79"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/create/gaussnoise.c"
             line="231">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/create/gaussnoise.c"
               line="213">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/gaussnoise.c"
               line="214">output width</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/gaussnoise.c"
               line="215">output height</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/gaussnoise.c"
               line="216">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="get_argv0" c:identifier="vips_get_argv0">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/init.c"
           line="173">::: seealso
    [func@INIT].</doc>
      <source-position filename="libvips/include/vips/vips.h" line="171"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/init.c"
             line="179">a pointer to an internal copy of the
argv0 string passed to [func@INIT]. Do not free this value</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
    </function>
    <function name="get_disc_threshold" c:identifier="vips_get_disc_threshold">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/image.c"
           line="2500">Return the number of bytes at which we flip between open via memory and
open via disc. This defaults to 100mb, but can be changed with the
`VIPS_DISC_THRESHOLD` environment variable or the `--vips-disc-threshold`
command-line flag. See [ctor@Image.new_from_file].</doc>
      <source-position filename="libvips/include/vips/image.h" line="514"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/image.c"
             line="2508">disc threshold in bytes.</doc>
        <type name="guint64" c:type="guint64"/>
      </return-value>
    </function>
    <function name="get_prgname" c:identifier="vips_get_prgname">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/init.c"
           line="188">Return the program name.

::: seealso
    [func@INIT].</doc>
      <source-position filename="libvips/include/vips/vips.h" line="173"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/init.c"
             line="196">a pointer to an internal copy of the program
name. Do not free this value</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
    </function>
    <function name="gifload" c:identifier="vips_gifload" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/nsgifload.c"
           line="914">Read a GIF file into a libvips image.

Use @page to select a page to render, numbering from zero.

Use @n to select the number of pages to render. The default is 1. Pages are
rendered in a vertical column. Set to -1 to mean "until the end of the
document". Use [method@Image.grid] to change page layout.

Use @fail_on to set the type of error that will cause load to fail. By
default, loaders are permissive, that is, [enum@Vips.FailOn.NONE].

The output image is RGBA for GIFs containing transparent elements, RGB
otherwise.

::: tip "Optional arguments"
    * @page: `gint`, page (frame) to read
    * @n: `gint`, load this many pages
    * @fail_on: [enum@FailOn], types of read error to fail on

::: seealso
    [ctor@Image.new_from_file].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="888"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/nsgifload.c"
             line="942">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/nsgifload.c"
               line="916">file to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/nsgifload.c"
               line="917">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/nsgifload.c"
               line="918">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="gifload_buffer"
              c:identifier="vips_gifload_buffer"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/nsgifload.c"
           line="957">Exactly as [ctor@Image.gifload], but read from a memory buffer.

You must not free the buffer while @out is active. The
[signal@Object::postclose] signal on @out is a good place to free.

::: tip "Optional arguments"
    * @page: `gint`, page (frame) to read
    * @n: `gint`, load this many pages
    * @fail_on: [enum@FailOn], types of read error to fail on

::: seealso
    [ctor@Image.gifload].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="891"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/nsgifload.c"
             line="977">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="buf" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/nsgifload.c"
               line="959">memory area to load</doc>
          <array length="1" zero-terminated="0" c:type="void*">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/nsgifload.c"
               line="960">size of memory area</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/nsgifload.c"
               line="961">image to write</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/nsgifload.c"
               line="962">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="gifload_source"
              c:identifier="vips_gifload_source"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/nsgifload.c"
           line="999">Exactly as [ctor@Image.gifload], but read from a source.

::: tip "Optional arguments"
    * @page: `gint`, page (frame) to read
    * @n: `gint`, load this many pages
    * @fail_on: [enum@FailOn], types of read error to fail on

::: seealso
    [ctor@Image.gifload].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="894"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/nsgifload.c"
             line="1015">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="source" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/nsgifload.c"
               line="1001">source to load</doc>
          <type name="Source" c:type="VipsSource*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/nsgifload.c"
               line="1002">image to write</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/nsgifload.c"
               line="1003">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="grey" c:identifier="vips_grey" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/create/grey.c"
           line="101">Create a one-band float image with the left-most column zero and the
right-most 1.

Intermediate pixels are a linear ramp.

Set @uchar to output a uchar image with the leftmost pixel 0 and the
rightmost 255.

::: tip "Optional arguments"
    * @uchar: `gboolean`, output a uchar image

::: seealso
    [ctor@Image.xyz], [ctor@Image.identity].</doc>
      <source-position filename="libvips/include/vips/create.h" line="65"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/create/grey.c"
             line="122">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/create/grey.c"
               line="103">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/grey.c"
               line="104">image size</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/grey.c"
               line="105">image size</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/grey.c"
               line="106">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="guess_libdir" c:identifier="vips_guess_libdir">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/init.c"
           line="1186">[func@guess_libdir] tries to guess the install directory (usually the
configure libdir, or $prefix/lib). You should pass
in the value of argv[0] (the name your program was run as) as a clue to
help it out, plus the name of the environment variable you let the user
override your package install area with (eg. "VIPSHOME").

On success, [func@guess_libdir] returns the libdir it discovered, and as a
side effect, sets the prefix environment variable (if it's not set).

Don't free the return string!

::: seealso
    [func@guess_prefix].</doc>
      <source-position filename="libvips/include/vips/vips.h" line="196"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/init.c"
             line="1205">the libdir as a static string, do not free.</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="argv0" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/init.c"
               line="1188">program name (typically argv[0])</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="env_name" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/init.c"
               line="1189">save prefix in this environment variable</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="guess_prefix" c:identifier="vips_guess_prefix">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/init.c"
           line="1139">[func@guess_prefix] tries to guess the install directory. You should pass
in the value of argv[0] (the name your program was run as) as a clue to
help it out, plus the name of the environment variable you let the user
override your package install area with (eg. "VIPSHOME").

On success, [func@guess_prefix] returns the prefix it discovered, and as a
side effect, sets the environment variable (if it's not set).

Don't free the return string!

::: seealso
    [func@guess_libdir].</doc>
      <source-position filename="libvips/include/vips/vips.h" line="194"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/init.c"
             line="1157">the install prefix as a static string, do not free.</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="argv0" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/init.c"
               line="1141">program name (typically argv[0])</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="env_name" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/init.c"
               line="1142">save prefix in this environment variable</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="hash_table_map" c:identifier="vips_hash_table_map">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/util.c"
           line="304">Like slist map, but for a hash table.</doc>
      <source-position filename="libvips/include/vips/util.h" line="272"/>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/util.c"
             line="313">`NULL` if @fn returns `NULL` for all arguments, otherwise the first
non-`NULL` value from @fn.</doc>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="hash" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/util.c"
               line="306">a [struct@GLib.HashTable]</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="fn" transfer-ownership="none" scope="call">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/util.c"
               line="307">function to apply to each hash value</doc>
          <type name="SListMap2Fn" c:type="VipsSListMap2Fn"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/util.c"
               line="308">user data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/util.c"
               line="309">user data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="heifload" c:identifier="vips_heifload" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/foreign.c"
           line="2224">Read a HEIF image file into a VIPS image.

Use @page to select a page to render, numbering from zero. If neither @n
nor @page are set, @page defaults to the primary page, otherwise to 0.

Use @n to select the number of pages to render. The default is 1. Pages are
rendered in a vertical column. Set to -1 to mean "until the end of the
document". Use [method@Image.grid] to reorganise pages.

HEIF images have a primary image. The metadata item `heif-primary` gives
the page number of the primary.

If @thumbnail is `TRUE`, then fetch a stored thumbnail rather than the
image.

By default, input image dimensions are limited to 16384x16384.
If @unlimited is `TRUE`, this increases to the maximum of 65535x65535.

The bitdepth of the heic image is recorded in the metadata item
`heif-bitdepth`.

::: tip "Optional arguments"
    * @page: `gint`, page (top-level image number) to read
    * @n: `gint`, load this many pages
    * @thumbnail: `gboolean`, fetch thumbnail instead of image
    * @unlimited: `gboolean`, remove all denial of service limits

::: seealso
    [ctor@Image.new_from_file].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="938"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/foreign.c"
             line="2260">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2226">file to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2227">decompressed image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2228">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="heifload_buffer"
              c:identifier="vips_heifload_buffer"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/foreign.c"
           line="2275">Read a HEIF image file into a VIPS image.
Exactly as [ctor@Image.heifload], but read from a memory buffer.

You must not free the buffer while @out is active. The
[signal@Object::postclose] signal on @out is a good place to free.

::: tip "Optional arguments"
    * @page: `gint`, page (top-level image number) to read
    * @n: `gint`, load this many pages
    * @thumbnail: `gboolean`, fetch thumbnail instead of image
    * @unlimited: `gboolean`, remove all denial of service limits

::: seealso
    [ctor@Image.heifload].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="941"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/foreign.c"
             line="2297">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="buf" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2277">memory area to load</doc>
          <array length="1" zero-terminated="0" c:type="void*">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2278">size of memory area</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2279">image to write</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2280">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="heifload_source"
              c:identifier="vips_heifload_source"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/foreign.c"
           line="2319">Exactly as [ctor@Image.heifload], but read from a source.

::: tip "Optional arguments"
    * @page: `gint`, page (top-level image number) to read
    * @n: `gint`, load this many pages
    * @thumbnail: `gboolean`, fetch thumbnail instead of image
    * @unlimited: `gboolean`, remove all denial of service limits

::: seealso
    [ctor@Image.heifload].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="944"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/foreign.c"
             line="2336">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="source" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2321">source to load from</doc>
          <type name="Source" c:type="VipsSource*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2322">image to write</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2323">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="icc_is_compatible_profile"
              c:identifier="vips_icc_is_compatible_profile">
      <source-position filename="libvips/include/vips/colour.h" line="242"/>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="image" transfer-ownership="none">
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="data_length" transfer-ownership="none">
          <type name="gsize" c:type="size_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="icc_present" c:identifier="vips_icc_present">
      <doc xml:space="preserve"
           filename="libvips/colour/icc_transform.c"
           line="126">VIPS can optionally be built without the ICC library. Use this function to
test for its availability.</doc>
      <source-position filename="libvips/include/vips/colour.h" line="227"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/colour/icc_transform.c"
             line="132">non-zero if the ICC library is present.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
    </function>
    <function name="identity" c:identifier="vips_identity" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/create/identity.c"
           line="172">Creates an identity lookup table, ie. one which will leave an image
unchanged when applied with [method@Image.maplut]. Each entry in the table
has a value equal to its position.

Use the arithmetic operations on these tables to make LUTs representing
arbitrary functions.

Normally LUTs are 8-bit. Set @ushort to create a 16-bit table.

Normally 16-bit tables have 65536 entries. You can set this smaller with
@size.

::: tip "Optional arguments"
    * @bands: `gint`, number of bands to create
    * @ushort: `gboolean`, `TRUE` for an unsigned short identity
    * @size: `gint`, number of LUT elements for a ushort image

::: seealso
    [ctor@Image.xyz], [method@Image.maplut].</doc>
      <source-position filename="libvips/include/vips/create.h" line="95"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/create/identity.c"
             line="197">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/create/identity.c"
               line="174">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/identity.c"
               line="175">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="init" c:identifier="vips_init">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/init.c"
           line="433">This function starts up libvips, see [func@INIT].

This function is for bindings which need to start up vips. C programs
should use the [func@INIT] macro, which does some extra checks.

::: seealso
    [func@INIT].</doc>
      <source-position filename="libvips/include/vips/vips.h" line="169"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/init.c"
             line="445">0 on success, -1 otherwise</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="argv0" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/init.c"
               line="435">name of application</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="interpolate"
              c:identifier="vips_interpolate"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/resample/interpolate.c"
           line="201">Look up the @interpolate method in the class and call it. Use
[method@Interpolate.get_method] to get a direct pointer to the function and
avoid the lookup overhead.

You need to set @in and @out up correctly.</doc>
      <source-position filename="libvips/include/vips/interpolate.h"
                       line="97"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="interpolate" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/resample/interpolate.c"
               line="203">interpolator to use</doc>
          <type name="Interpolate" c:type="VipsInterpolate*"/>
        </parameter>
        <parameter name="out"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/resample/interpolate.c"
               line="204">write result here</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/resample/interpolate.c"
               line="205">read source data from here</doc>
          <type name="Region" c:type="VipsRegion*"/>
        </parameter>
        <parameter name="x" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/resample/interpolate.c"
               line="206">interpolate value at this position</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/resample/interpolate.c"
               line="207">interpolate value at this position</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
      </parameters>
    </function>
    <function name="interpretation_bands"
              c:identifier="vips_interpretation_bands"
              moved-to="Interpretation.bands">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/header.c"
           line="208">The number of "real" bands we expect for this interpretation. If we've no
idea (eg. MULTIBAND), return 0.</doc>
      <source-position filename="libvips/include/vips/header.h" line="203"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="215">the number of bands implied by this interpretation, or 0.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="interpretation" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="210">image to check</doc>
          <type name="Interpretation" c:type="VipsInterpretation"/>
        </parameter>
      </parameters>
    </function>
    <function name="interpretation_max_alpha"
              c:identifier="vips_interpretation_max_alpha"
              moved-to="Interpretation.max_alpha">
      <source-position filename="libvips/include/vips/header.h" line="201"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/header.c"
             line="192">the maximum alpha value for an interpretation.</doc>
        <type name="gdouble" c:type="double"/>
      </return-value>
      <parameters>
        <parameter name="interpretation" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/header.c"
               line="190">image interpretation</doc>
          <type name="Interpretation" c:type="VipsInterpretation"/>
        </parameter>
      </parameters>
    </function>
    <function name="iscasepostfix" c:identifier="vips_iscasepostfix">
      <source-position filename="libvips/include/vips/util.h" line="276"/>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="a" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="isdirf" c:identifier="vips_isdirf" introspectable="0">
      <source-position filename="libvips/include/vips/util.h" line="292"/>
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="ispoweroftwo" c:identifier="vips_ispoweroftwo">
      <source-position filename="libvips/include/vips/util.h" line="337"/>
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="p" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="isprefix" c:identifier="vips_isprefix">
      <source-position filename="libvips/include/vips/util.h" line="278"/>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="a" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="jp2kload" c:identifier="vips_jp2kload" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/jp2kload.c"
           line="1620">Read a JPEG2000 image.

The loader supports 8, 16 and 32-bit int pixel
values, signed and unsigned. It supports greyscale, RGB, YCC, CMYK and
multispectral colour spaces. It will read any ICC profile on the image.

It will only load images where all channels have the same format.

Use @page to set the page to load, where page 0 is the base resolution
image and higher-numbered pages are x2 reductions. Use the metadata item
"n-pages" to find the number of pyramid layers.

Some versions of openjpeg can fail to decode some tiled images correctly.
Setting @oneshot will force the loader to decode tiled images in a single
operation and can improve compatibility.

Use @fail_on to set the type of error that will cause load to fail. By
default, loaders are permissive, that is, [enum@Vips.FailOn.NONE].

::: tip "Optional arguments"
    * @page: `gint`, load this page
    * @oneshot: `gboolean`, load pages in one-shot mode
    * @fail_on: [enum@FailOn], types of read error to fail on

::: seealso
    [ctor@Image.new_from_file].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="967"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/jp2kload.c"
             line="1653">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/jp2kload.c"
               line="1622">file to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/jp2kload.c"
               line="1623">decompressed image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/jp2kload.c"
               line="1624">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="jp2kload_buffer"
              c:identifier="vips_jp2kload_buffer"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/jp2kload.c"
           line="1668">Exactly as [ctor@Image.jp2kload], but read from a buffer.

You must not free the buffer while @out is active. The
[signal@Object::postclose] signal on @out is a good place to free.

::: tip "Optional arguments"
    * @page: `gint`, load this page
    * @oneshot: `gboolean`, load pages in one-shot mode
    * @fail_on: [enum@FailOn], types of read error to fail on</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="970"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/jp2kload.c"
             line="1685">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="buf" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/jp2kload.c"
               line="1670">memory area to load</doc>
          <array length="1" zero-terminated="0" c:type="void*">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/jp2kload.c"
               line="1671">size of memory area</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/jp2kload.c"
               line="1672">image to write</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/jp2kload.c"
               line="1673">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="jp2kload_source"
              c:identifier="vips_jp2kload_source"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/jp2kload.c"
           line="1707">Exactly as [ctor@Image.jp2kload], but read from a source.

::: tip "Optional arguments"
    * @page: `gint`, load this page
    * @oneshot: `gboolean`, load pages in one-shot mode
    * @fail_on: [enum@FailOn], types of read error to fail on</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="973"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/jp2kload.c"
             line="1720">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="source" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/jp2kload.c"
               line="1709">source to load from</doc>
          <type name="Source" c:type="VipsSource*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/jp2kload.c"
               line="1710">decompressed image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/jp2kload.c"
               line="1711">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="jpegload" c:identifier="vips_jpegload" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/jpegload.c"
           line="428">Read a JPEG file into a VIPS image. It can read most 8-bit JPEG images,
including CMYK and YCbCr.

@shrink means shrink by this integer factor during load.  Possible values
are 1, 2, 4 and 8. Shrinking during read is very much faster than
decompressing the whole image and then shrinking later.

Use @fail_on to set the type of error that will cause load to fail. By
default, loaders are permissive, that is, [enum@Vips.FailOn.NONE].

Setting @autorotate to `TRUE` will make the loader interpret the
orientation tag and automatically rotate the image appropriately during
load.

If @autorotate is `FALSE`, the metadata field [const@META_ORIENTATION] is set
to the value of the orientation tag. Applications may read and interpret
this field
as they wish later in processing. See [method@Image.autorot]. Save
operations will use [const@META_ORIENTATION], if present, to set the
orientation of output images.

Example:

```c
vips_jpegload("fred.jpg", &amp;out,
    "shrink", 8,
    "fail_on", VIPS_FAIL_ON_TRUNCATED,
    NULL);
```

Any embedded ICC profiles are ignored: you always just get the RGB from
the file. Instead, the embedded profile will be attached to the image as
[const@META_ICC_NAME]. You need to use something like
[method@Image.icc_import] to get CIE values from the file.

EXIF metadata is attached as [const@META_EXIF_NAME], IPTC as
[const@META_IPTC_NAME], and XMP as [const@META_XMP_NAME].

The int metadata item "jpeg-multiscan" is set to the result of
`jpeg_has_multiple_scans()`. Interlaced jpeg images need a large amount of
memory to load, so this field gives callers a chance to handle these
images differently.

The string-valued field "jpeg-chroma-subsample" gives the chroma subsample
in standard notation. 4:4:4 means no subsample, 4:2:0 means YCbCr with
Cb and Cr subsampled horizontally and vertically, 4:4:4:4 means a CMYK
image with no subsampling.

The EXIF thumbnail, if present, is attached to the image as
"jpeg-thumbnail-data". See [method@Image.get_blob].

::: tip "Optional arguments"
    * @shrink: `gint`, shrink by this much on load
    * @fail_on: [enum@FailOn], types of read error to fail on
    * @autorotate: `gboolean`, use exif Orientation tag to rotate the image
      during load

::: seealso
    [ctor@Image.jpegload_buffer], [method@Image.autorot].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="505"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/jpegload.c"
             line="494">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/jpegload.c"
               line="430">file to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/jpegload.c"
               line="431">decompressed image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/jpegload.c"
               line="432">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="jpegload_buffer"
              c:identifier="vips_jpegload_buffer"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/jpegload.c"
           line="509">Read a JPEG-formatted memory block into a VIPS image. Exactly as
[ctor@Image.jpegload], but read from a memory buffer.

You must not free the buffer while @out is active. The
[signal@Object::postclose] signal on @out is a good place to free.

::: tip "Optional arguments"
    * @shrink: `gint`, shrink by this much on load
    * @fail_on: [enum@FailOn], types of read error to fail on
    * @autorotate: `gboolean`, use exif Orientation tag to rotate the image
      during load

::: seealso
    [ctor@Image.jpegload].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="508"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/jpegload.c"
             line="531">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="buf" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/jpegload.c"
               line="511">memory area to load</doc>
          <array length="1" zero-terminated="0" c:type="void*">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/jpegload.c"
               line="512">size of memory area</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/jpegload.c"
               line="513">image to write</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/jpegload.c"
               line="514">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="jpegload_source"
              c:identifier="vips_jpegload_source"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/jpegload.c"
           line="553">Read a JPEG-formatted memory block into a VIPS image. Exactly as
[ctor@Image.jpegload], but read from a source.

::: tip "Optional arguments"
    * @shrink: `gint`, shrink by this much on load
    * @fail_on: [enum@FailOn], types of read error to fail on
    * @autorotate: `gboolean`, use exif Orientation tag to rotate the image
      during load

::: seealso
    [ctor@Image.jpegload].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="511"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/jpegload.c"
             line="571">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="source" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/jpegload.c"
               line="555">source to load</doc>
          <type name="Source" c:type="VipsSource*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/jpegload.c"
               line="556">image to write</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/jpegload.c"
               line="557">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="jxlload" c:identifier="vips_jxlload" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/foreign.c"
           line="2505">Read a JPEG-XL image.

The JPEG-XL loader and saver are experimental features and may change
in future libvips versions.

::: seealso
    [ctor@Image.new_from_file].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="992"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/foreign.c"
             line="2519">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2507">file to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2508">decompressed image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2509">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="jxlload_buffer"
              c:identifier="vips_jxlload_buffer"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/foreign.c"
           line="2534">Exactly as [ctor@Image.jxlload], but read from a buffer.</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="989"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/foreign.c"
             line="2543">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="buf" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2536">memory area to load</doc>
          <array length="1" zero-terminated="0" c:type="void*">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2537">size of memory area</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2538">image to write</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2539">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="jxlload_source"
              c:identifier="vips_jxlload_source"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/foreign.c"
           line="2565">Exactly as [ctor@Image.jxlload], but read from a source.</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="986"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/foreign.c"
             line="2573">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="source" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2567">source to load from</doc>
          <type name="Source" c:type="VipsSource*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2568">decompressed image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2569">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="leak_set" c:identifier="vips_leak_set">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/init.c"
           line="1290">Turn on or off vips leak checking. See also `--vips-leak`,
[func@add_option_entries] and the `VIPS_LEAK` environment variable.

You should call this very early in your program.</doc>
      <source-position filename="libvips/include/vips/vips.h" line="183"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="leak" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/init.c"
               line="1292">turn leak checking on or off</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="logmat" c:identifier="vips_logmat" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/create/logmat.c"
           line="244">Create a circularly symmetric Laplacian of Gaussian mask of radius
@sigma.

The size of the mask is determined by the variable @min_ampl;
if for instance the value .1 is entered this means that the produced mask
is clipped at values within 10 percent of zero, and where the change
between mask elements is less than 10%.

The program uses the following equation: (from Handbook of Pattern
Recognition and image processing by Young and Fu, AP 1986 pages 220-221):

```
H(r) = (1 / (2 * M_PI * s4)) * (2 - (r2 / s2)) * exp(-r2 / (2 * s2))
```

where:

```
2 = @sigma * @sigma,
s4 = s2 * s2
r2 = r * r.
```

The generated mask has odd size and its maximum value is normalised to
1.0, unless @precision is [enum@Vips.Precision.INTEGER].

If @separable is set, only the centre horizontal is generated. This is
useful for separable convolutions.

If @precision is [enum@Vips.Precision.INTEGER], an integer mask is generated.
This is useful for integer convolutions.

"scale" is set to the sum of all the mask elements.

::: tip "Optional arguments"
    * @separable: `gboolean`, generate a separable mask
    * @precision: [enum@Precision] for @out

::: seealso
    [ctor@Image.gaussmat], [method@Image.conv].</doc>
      <source-position filename="libvips/include/vips/create.h" line="71"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/create/logmat.c"
             line="292">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/create/logmat.c"
               line="246">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="sigma" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/logmat.c"
               line="247">standard deviation of mask</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="min_ampl" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/logmat.c"
               line="248">minimum amplitude</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/logmat.c"
               line="249">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="magickload"
              c:identifier="vips_magickload"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/magickload.c"
           line="63">Read in an image using libMagick, the ImageMagick library.

This library can read more than 80 file formats, including BMP, EPS,
DICOM and many others.
The reader can handle any ImageMagick image, including the float and double
formats. It will work with any quantum size, including HDR. Any metadata
attached to the libMagick image is copied on to the VIPS image.

The reader should also work with most versions of GraphicsMagick. See the
`-Dmagick-package` configure option.

The file format is usually guessed from the filename suffix, or sniffed
from the file contents.

Normally it will only load the first image in a many-image sequence (such
as a GIF or a PDF). Use @page and @n to set the start page and number of
pages to load. Set @n to -1 to load all pages from @page onwards.

@density is "WxH" in DPI, e.g. "600x300" or "600" (default is "72x72"). See
the [density
docs](http://www.imagemagick.org/script/command-line-options.php#density)
on the imagemagick website.

::: tip "Optional arguments"
    * @page: `gint`, load from this page
    * @n: `gint`, load this many pages
    * @density: `gchararray`, canvas resolution for rendering vector formats
      like SVG

::: seealso
    [ctor@Image.new_from_file].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="716"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/magickload.c"
             line="101">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/magickload.c"
               line="65">file to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/magickload.c"
               line="66">decompressed image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/magickload.c"
               line="67">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="magickload_buffer"
              c:identifier="vips_magickload_buffer"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/magickload.c"
           line="116">Read an image memory block using libMagick into a VIPS image. Exactly as
[ctor@Image.magickload], but read from a memory source.

You must not free the buffer while @out is active. The
[signal@Object::postclose] signal on @out is a good place to free.

::: tip "Optional arguments"
    * @page: `gint`, load from this page
    * @n: `gint`, load this many pages
    * @density: `gchararray`, canvas resolution for rendering vector formats
      like SVG

::: seealso
    [ctor@Image.magickload].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="719"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/magickload.c"
             line="138">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="buf" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/magickload.c"
               line="118">memory area to load</doc>
          <array length="1" zero-terminated="0" c:type="void*">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/magickload.c"
               line="119">size of memory area</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/magickload.c"
               line="120">image to write</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/magickload.c"
               line="121">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="magickload_source"
              c:identifier="vips_magickload_source"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/magickload.c"
           line="160">Exactly as [ctor@Image.magickload], but read from a source.

::: tip "Optional arguments"
    * @page: `gint`, load from this page
    * @n: `gint`, load this many pages
    * @density: `gchararray`, canvas resolution for rendering vector formats
      like SVG

::: seealso
    [ctor@Image.magickload].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="722"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/magickload.c"
             line="177">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="source" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/magickload.c"
               line="162">source to load</doc>
          <type name="Source" c:type="VipsSource*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/magickload.c"
               line="163">image to write</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/magickload.c"
               line="164">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="malloc" c:identifier="vips_malloc">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/memory.c"
           line="138">[func@GLib.malloc] local to @object, that is, the memory will be automatically
freed for you when the object is closed. If @object is `NULL`, you need to
free the memory explicitly with [func@GLib.free].

This function cannot fail. See [func@tracked_malloc] if you are
allocating large amounts of memory.

::: seealso
    [func@tracked_malloc].</doc>
      <source-position filename="libvips/include/vips/memory.h" line="97"/>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/memory.c"
             line="153">a pointer to the allocated memory.</doc>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/memory.c"
               line="140">allocate memory local to this [class@Object], or `NULL`</doc>
          <type name="Object" c:type="VipsObject*"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/memory.c"
               line="141">number of bytes to allocate</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="map_equal" c:identifier="vips_map_equal">
      <source-position filename="libvips/include/vips/util.h" line="269"/>
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="mask_butterworth"
              c:identifier="vips_mask_butterworth"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/create/mask_butterworth.c"
           line="120">Make an butterworth high- or low-pass filter, that is, one with a variable,
smooth transition
positioned at @frequency_cutoff, where @frequency_cutoff is in
range 0 - 1.

The shape of the curve is controlled by
@order -- higher values give a sharper transition. See Gonzalez and Wintz,
Digital Image Processing, 1987.

::: tip "Optional arguments"
    * @nodc: `gboolean`, don't set the DC pixel
    * @reject: `gboolean`, invert the filter sense
    * @optical: `gboolean`, coordinates in optical space
    * @uchar: `gboolean`, output a uchar image

::: seealso
    [ctor@Image.mask_ideal].</doc>
      <source-position filename="libvips/include/vips/create.h" line="121"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/create/mask_butterworth.c"
             line="148">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/create/mask_butterworth.c"
               line="122">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_butterworth.c"
               line="123">image size</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_butterworth.c"
               line="124">image size</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="order" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_butterworth.c"
               line="125">filter order</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="frequency_cutoff" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_butterworth.c"
               line="126">frequency threshold</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="amplitude_cutoff" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_butterworth.c"
               line="127">amplitude threshold</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_butterworth.c"
               line="128">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="mask_butterworth_band"
              c:identifier="vips_mask_butterworth_band"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/create/mask_butterworth_band.c"
           line="161">Make an butterworth band-pass or band-reject filter, that is, one with a
variable, smooth transition positioned at @frequency_cutoff_x,
@frequency_cutoff_y, of radius @radius.

The shape of the curve is controlled by
@order -- higher values give a sharper transition. See Gonzalez and Wintz,
Digital Image Processing, 1987.

::: tip "Optional arguments"
    * @nodc: `gboolean`, don't set the DC pixel
    * @reject: `gboolean`, invert the filter sense
    * @optical: `gboolean`, coordinates in optical space
    * @uchar: `gboolean`, output a uchar image

::: seealso
    [ctor@Image.mask_ideal].</doc>
      <source-position filename="libvips/include/vips/create.h" line="132"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/create/mask_butterworth_band.c"
             line="190">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/create/mask_butterworth_band.c"
               line="163">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_butterworth_band.c"
               line="164">image size</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_butterworth_band.c"
               line="165">image size</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="order" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_butterworth_band.c"
               line="166">filter order</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="frequency_cutoff_x" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_butterworth_band.c"
               line="167">band position</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="frequency_cutoff_y" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_butterworth_band.c"
               line="168">band position</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="radius" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_butterworth_band.c"
               line="169">band radius</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="amplitude_cutoff" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_butterworth_band.c"
               line="170">amplitude threshold</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_butterworth_band.c"
               line="171">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="mask_butterworth_ring"
              c:identifier="vips_mask_butterworth_ring"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/create/mask_butterworth_ring.c"
           line="120">Make a butterworth ring-pass or ring-reject filter, that is, one with a
variable,
smooth transition
positioned at @frequency_cutoff of width @width, where @frequency_cutoff is
in the range 0 - 1.

The shape of the curve is controlled by
@order -- higher values give a sharper transition. See Gonzalez and Wintz,
Digital Image Processing, 1987.

::: tip "Optional arguments"
    * @nodc: `gboolean`, don't set the DC pixel
    * @reject: `gboolean`, invert the filter sense
    * @optical: `gboolean`, coordinates in optical space
    * @uchar: `gboolean`, output a uchar image

::: seealso
    [ctor@Image.mask_ideal].</doc>
      <source-position filename="libvips/include/vips/create.h" line="126"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/create/mask_butterworth_ring.c"
             line="150">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/create/mask_butterworth_ring.c"
               line="122">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_butterworth_ring.c"
               line="123">image size</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_butterworth_ring.c"
               line="124">image size</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="order" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_butterworth_ring.c"
               line="125">filter order</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="frequency_cutoff" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_butterworth_ring.c"
               line="126">frequency threshold</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="amplitude_cutoff" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_butterworth_ring.c"
               line="127">amplitude threshold</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="ringwidth" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_butterworth_ring.c"
               line="128">ringwidth</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_butterworth_ring.c"
               line="129">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="mask_fractal"
              c:identifier="vips_mask_fractal"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/create/mask_fractal.c"
           line="106">This operation should be used to create fractal images by filtering the
power spectrum of Gaussian white noise.

See [ctor@Image.gaussnoise].

::: tip "Optional arguments"
    * @nodc: `gboolean`, don't set the DC pixel
    * @reject: `gboolean`, invert the filter sense
    * @optical: `gboolean`, coordinates in optical space
    * @uchar: `gboolean`, output a uchar image

::: seealso
    [ctor@Image.mask_ideal].</doc>
      <source-position filename="libvips/include/vips/create.h" line="152"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/create/mask_fractal.c"
             line="128">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/create/mask_fractal.c"
               line="108">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_fractal.c"
               line="109">image size</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_fractal.c"
               line="110">image size</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="fractal_dimension" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_fractal.c"
               line="111">fractal dimension</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_fractal.c"
               line="112">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="mask_gaussian"
              c:identifier="vips_mask_gaussian"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/create/mask_gaussian.c"
           line="107">Make a gaussian high- or low-pass filter, that is, one with a variable,
smooth transition positioned at @frequency_cutoff.

::: tip "Optional arguments"
    * @nodc: `gboolean`, don't set the DC pixel
    * @reject: `gboolean`, invert the filter sense
    * @optical: `gboolean`, coordinates in optical space
    * @uchar: `gboolean`, output a uchar image

::: seealso
    [ctor@Image.mask_ideal].</doc>
      <source-position filename="libvips/include/vips/create.h" line="138"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/create/mask_gaussian.c"
             line="128">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/create/mask_gaussian.c"
               line="109">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_gaussian.c"
               line="110">image size</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_gaussian.c"
               line="111">image size</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="frequency_cutoff" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_gaussian.c"
               line="112">frequency threshold</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="amplitude_cutoff" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_gaussian.c"
               line="113">amplitude threshold</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_gaussian.c"
               line="114">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="mask_gaussian_band"
              c:identifier="vips_mask_gaussian_band"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/create/mask_gaussian_band.c"
           line="144">Make a gaussian band-pass or band-reject filter, that is, one with a
variable, smooth transition positioned at @frequency_cutoff_x,
@frequency_cutoff_y, of radius @radius.

::: tip "Optional arguments"
    * @nodc: `gboolean`, don't set the DC pixel
    * @reject: `gboolean`, invert the filter sense
    * @optical: `gboolean`, coordinates in optical space
    * @uchar: `gboolean`, output a uchar image

::: seealso
    [ctor@Image.mask_ideal].</doc>
      <source-position filename="libvips/include/vips/create.h" line="147"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/create/mask_gaussian_band.c"
             line="168">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/create/mask_gaussian_band.c"
               line="146">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_gaussian_band.c"
               line="147">image size</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_gaussian_band.c"
               line="148">image size</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="frequency_cutoff_x" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_gaussian_band.c"
               line="149">band position</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="frequency_cutoff_y" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_gaussian_band.c"
               line="150">band position</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="radius" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_gaussian_band.c"
               line="151">band radius</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="amplitude_cutoff" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_gaussian_band.c"
               line="152">amplitude threshold</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_gaussian_band.c"
               line="153">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="mask_gaussian_ring"
              c:identifier="vips_mask_gaussian_ring"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/create/mask_gaussian_ring.c"
           line="114">Make a gaussian ring-pass or ring-reject filter, that is, one with a
variable, smooth transition positioned at @frequency_cutoff of width
@ringwidth.

::: tip "Optional arguments"
    * @nodc: `gboolean`, don't set the DC pixel
    * @reject: `gboolean`, invert the filter sense
    * @optical: `gboolean`, coordinates in optical space
    * @uchar: `gboolean`, output a uchar image

::: seealso
    [ctor@Image.mask_ideal].</doc>
      <source-position filename="libvips/include/vips/create.h" line="142"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/create/mask_gaussian_ring.c"
             line="137">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/create/mask_gaussian_ring.c"
               line="116">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_gaussian_ring.c"
               line="117">image size</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_gaussian_ring.c"
               line="118">image size</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="frequency_cutoff" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_gaussian_ring.c"
               line="119">frequency threshold</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="amplitude_cutoff" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_gaussian_ring.c"
               line="120">amplitude threshold</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="ringwidth" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_gaussian_ring.c"
               line="121">ringwidth</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_gaussian_ring.c"
               line="122">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="mask_ideal"
              c:identifier="vips_mask_ideal"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/create/mask_ideal.c"
           line="97">Make an ideal high- or low-pass filter, that is, one with a sharp cutoff
positioned at @frequency_cutoff, where @frequency_cutoff is in
the range 0 - 1.

This operation creates a one-band float image of the specified size.
The image has
values in the range [0, 1] and is typically used for multiplying against
frequency domain images to filter them.
Masks are created with the DC component at (0, 0). The DC pixel always
has the value 1.0.

Set @nodc to not set the DC pixel.

Set @optical to position the DC component in the centre of the image. This
makes the mask suitable for multiplying against optical Fourier transforms.
See [method@Image.wrap].

Set @reject to invert the sense of
the filter. For example, low-pass becomes low-reject.

Set @uchar to output an 8-bit unsigned char image rather than a
float image. In this case, pixels are in the range [0 - 255].

::: tip "Optional arguments"
    * @nodc: `gboolean`, don't set the DC pixel
    * @reject: `gboolean`, invert the filter sense
    * @optical: `gboolean`, coordinates in optical space
    * @uchar: `gboolean`, output a uchar image

::: seealso
    [ctor@Image.mask_ideal], [ctor@Image.mask_ideal_ring],
    [ctor@Image.mask_ideal_band], [ctor@Image.mask_butterworth],
    [ctor@Image.mask_butterworth_ring], [ctor@Image.mask_butterworth_band],
    [ctor@Image.mask_gaussian], [ctor@Image.mask_gaussian_ring],
    [ctor@Image.mask_gaussian_band].</doc>
      <source-position filename="libvips/include/vips/create.h" line="108"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/create/mask_ideal.c"
             line="141">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/create/mask_ideal.c"
               line="99">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_ideal.c"
               line="100">image size</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_ideal.c"
               line="101">image size</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="frequency_cutoff" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_ideal.c"
               line="102">threshold at which filter ends</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_ideal.c"
               line="103">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="mask_ideal_band"
              c:identifier="vips_mask_ideal_band"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/create/mask_ideal_band.c"
           line="127">Make an ideal band-pass or band-reject filter, that is, one with a
sharp cutoff around the point @frequency_cutoff_x, @frequency_cutoff_y,
of size @radius.

::: tip "Optional arguments"
    * @nodc: `gboolean`, don't set the DC pixel
    * @reject: `gboolean`, invert the filter sense
    * @optical: `gboolean`, coordinates in optical space
    * @uchar: `gboolean`, output a uchar image

::: seealso
    [ctor@Image.mask_ideal].</doc>
      <source-position filename="libvips/include/vips/create.h" line="116"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/create/mask_ideal_band.c"
             line="150">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/create/mask_ideal_band.c"
               line="129">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_ideal_band.c"
               line="130">image size</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_ideal_band.c"
               line="131">image size</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="frequency_cutoff_x" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_ideal_band.c"
               line="132">position of band</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="frequency_cutoff_y" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_ideal_band.c"
               line="133">position of band</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="radius" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_ideal_band.c"
               line="134">size of band</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_ideal_band.c"
               line="135">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="mask_ideal_ring"
              c:identifier="vips_mask_ideal_ring"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/create/mask_ideal_ring.c"
           line="111">Make an ideal ring-pass or ring-reject filter, that is, one with a sharp
ring positioned at @frequency_cutoff of width @width, where
@frequency_cutoff and @width are expressed as the range 0 - 1.

::: tip "Optional arguments"
    * @nodc: `gboolean`, don't set the DC pixel
    * @reject: `gboolean`, invert the filter sense
    * @optical: `gboolean`, coordinates in optical space
    * @uchar: `gboolean`, output a uchar image

::: seealso
    [ctor@Image.mask_ideal].</doc>
      <source-position filename="libvips/include/vips/create.h" line="112"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/create/mask_ideal_ring.c"
             line="133">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/create/mask_ideal_ring.c"
               line="113">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_ideal_ring.c"
               line="114">image size</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_ideal_ring.c"
               line="115">image size</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="frequency_cutoff" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_ideal_ring.c"
               line="116">threshold at which filter ends</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="ringwidth" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_ideal_ring.c"
               line="117">ring width</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/mask_ideal_ring.c"
               line="118">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="matload" c:identifier="vips_matload" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/matload.c"
           line="152">Read a Matlab save file into a VIPS image.

This operation searches the save
file for the first array variable with between 1 and 3 dimensions and loads
it as an image. It will not handle complex images. It does not handle
sparse matrices.

::: seealso
    [ctor@Image.new_from_file].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="819"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/matload.c"
             line="168">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/matload.c"
               line="154">file to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/matload.c"
               line="155">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/matload.c"
               line="156">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="matrixload"
              c:identifier="vips_matrixload"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/matrixload.c"
           line="466">Reads a matrix from a file.

Matrix files have a simple format that's supposed to be easy to create with
a text editor or a spreadsheet.

The first line has four numbers for width, height, scale and
offset (scale and offset may be omitted, in which case they default to 1.0
and 0.0). Scale must be non-zero. Width and height must be positive
integers. The numbers are separated by any mixture of spaces, commas,
tabs and quotation marks ("). The scale and offset fields may be
floating-point, and must use '.'
as a decimal separator.

Subsequent lines each hold one row of matrix data, with numbers again
separated by any mixture of spaces, commas,
tabs and quotation marks ("). The numbers may be floating-point, and must
use '.'
as a decimal separator.

Extra characters at the ends of lines or at the end of the file are
ignored.

::: seealso
    [ctor@Image.matrixload].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="700"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/matrixload.c"
             line="497">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/matrixload.c"
               line="468">file to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/matrixload.c"
               line="469">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/matrixload.c"
               line="470">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="matrixload_source"
              c:identifier="vips_matrixload_source"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/matrixload.c"
           line="512">Exactly as [ctor@Image.matrixload], but read from a source.

::: seealso
    [ctor@Image.matrixload].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="703"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/matrixload.c"
             line="523">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="source" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/matrixload.c"
               line="514">source to load</doc>
          <type name="Source" c:type="VipsSource*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/matrixload.c"
               line="515">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/matrixload.c"
               line="516">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="max_coord_get" c:identifier="vips_max_coord_get">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/init.c"
           line="145">Return the maximum coordinate value. This can be the default, a value set
set by the `--vips-max-coord` CLI arg, or a value set in the `VIPS_MAX_COORD`
environment variable.

These strings can include unit specifiers, eg. "10m" for 10 million pixels.
Values above INT_MAX are not supported.</doc>
      <source-position filename="libvips/include/vips/vips.h" line="167"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/init.c"
             line="155">The maximum value a coordinate, or image dimension, can have.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
    </function>
    <function name="mkdirf" c:identifier="vips_mkdirf" introspectable="0">
      <source-position filename="libvips/include/vips/util.h" line="295"/>
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="nickname_find" c:identifier="vips_nickname_find">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/object.c"
           line="3002">Return the VIPS nickname for a [alias@GObject.Type]. Handy for language bindings.</doc>
      <source-position filename="libvips/include/vips/object.h" line="680"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="3008">the class nickname.</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/object.c"
               line="3004">[alias@GObject.Type] to search for</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="niftiload"
              c:identifier="vips_niftiload"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/niftiload.c"
           line="799">Read a NIFTI image file into a VIPS image.

NIFTI metadata is attached with the "nifti-" prefix.

::: seealso
    [ctor@Image.new_from_file].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="957"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/niftiload.c"
             line="812">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/niftiload.c"
               line="801">file to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/niftiload.c"
               line="802">decompressed image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/niftiload.c"
               line="803">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="niftiload_source"
              c:identifier="vips_niftiload_source"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/niftiload.c"
           line="827">Exactly as [ctor@Image.niftiload], but read from a source.</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="960"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/niftiload.c"
             line="835">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="source" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/niftiload.c"
               line="829">source to load from</doc>
          <type name="Source" c:type="VipsSource*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/niftiload.c"
               line="830">decompressed image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/niftiload.c"
               line="831">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="object_local"
                    c:identifier="vips_object_local"
                    introspectable="0">
      <source-position filename="libvips/include/vips/object.h" line="680"/>
      <parameters>
        <parameter name="V">
        </parameter>
        <parameter name="G">
        </parameter>
      </parameters>
    </function-macro>
    <function name="openexrload"
              c:identifier="vips_openexrload"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/openexrload.c"
           line="163">Read a OpenEXR file into a VIPS image.

The reader can handle scanline and tiled OpenEXR images. It can't handle
OpenEXR colour management, image attributes, many pixel formats, anything
other than RGBA.

This reader uses the rather limited OpenEXR C API. It should really be
redone in C++.

::: seealso
    [ctor@Image.new_from_file].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="655"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/openexrload.c"
             line="181">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/openexrload.c"
               line="165">file to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/openexrload.c"
               line="166">decompressed image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/openexrload.c"
               line="167">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="openslideload"
              c:identifier="vips_openslideload"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/foreign.c"
           line="2861">Read a virtual slide supported by the OpenSlide library into a VIPS image.
OpenSlide supports images in Aperio, Hamamatsu, MIRAX, Sakura, Trestle,
and Ventana formats.

To facilitate zooming, virtual slide formats include multiple scaled-down
versions of the high-resolution image.  These are typically called
"levels".  By default, [ctor@Image.openslideload] reads the
highest-resolution level (level 0).  Set @level to the level number you want.

In addition to the slide image itself, virtual slide formats sometimes
include additional images, such as a scan of the slide's barcode.
OpenSlide calls these "associated images".  To read an associated image,
set @associated to the image's name.
A slide's associated images are listed in the
"slide-associated-images" metadata item.

If you set @attach_associated, then all associated images are attached as
metadata items. Use [method@Image.get_image] on @out to retrieve them. Images
are attached as "openslide-associated-XXXXX", where XXXXX is the name of the
associated image.

By default, the output of this operator is RGBA. Set @rgb to enable RGB
output.

::: tip "Optional arguments"
    * @level: `gint`, load this level
    * @associated: `gchararray`, load this associated image
    * @attach_associated: `gboolean`, attach all associated images as metadata
    * @autocrop: `gboolean`, crop to image bounds
    * @rgb: `gboolean`, output RGB (not RGBA) pixels

::: seealso
    [ctor@Image.new_from_file].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="483"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/foreign.c"
             line="2901">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2863">file to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2864">decompressed image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2865">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="openslideload_source"
              c:identifier="vips_openslideload_source"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/foreign.c"
           line="2916">Exactly as [ctor@Image.openslideload], but read from a source.

::: tip "Optional arguments"
    * @level: `gint`, load this level
    * @associated: `gchararray`, load this associated image
    * @attach_associated: `gboolean`, attach all associated images as metadata
    * @autocrop: `gboolean`, crop to image bounds
    * @rgb: `gboolean`, output RGB (not RGBA) pixels</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="486"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/foreign.c"
             line="2931">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="source" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2918">source to load from</doc>
          <type name="Source" c:type="VipsSource*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2919">decompressed image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2920">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="pdfload" c:identifier="vips_pdfload" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/foreign.c"
           line="2719">Render a PDF file into a VIPS image.

The output image is always RGBA -- CMYK PDFs will be
converted. If you need CMYK bitmaps, you should use [ctor@Image.magickload]
instead.

Use @page to select a page to render, numbering from zero.

Use @n to select the number of pages to render. The default is 1. Pages are
rendered in a vertical column, with each individual page aligned to the
left. Set to -1 to mean "until the end of the document". Use
[method@Image.grid] to change page layout.

Use @dpi to set the rendering resolution. The default is 72. Additionally,
you can scale by setting @scale. If you set both, they combine.

Use @background to set the background RGBA colour. The default is 255
(solid white), use eg. 0 for a transparent background.

Use @password to supply a decryption password.

When using pdfium, the region of a page to render can be selected with
@page_box, defaulting to the crop box.

The operation fills a number of header fields with metadata, for example
"pdf-author". They may be useful.

This function only reads the image header and does not render any pixel
data. Rendering occurs when pixels are accessed.

::: tip "Optional arguments"
    * @page: `gint`, load this page, numbered from zero
    * @n: `gint`, load this many pages
    * @dpi: `gdouble`, render at this DPI
    * @scale: `gdouble`, scale render by this factor
    * @background: [struct@ArrayDouble], background colour
    * @page_box: [enum@ForeignPdfPageBox], use this page box (pdfium only)

::: seealso
    [ctor@Image.new_from_file], [ctor@Image.magickload].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="865"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/foreign.c"
             line="2766">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2721">file to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2722">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2723">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="pdfload_buffer"
              c:identifier="vips_pdfload_buffer"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/foreign.c"
           line="2781">Read a PDF-formatted memory buffer into a VIPS image. Exactly as
[ctor@Image.pdfload], but read from memory.

You must not free the buffer while @out is active. The
[signal@Object::postclose] signal on @out is a good place to free.

::: tip "Optional arguments"
    * @page: `gint`, load this page, numbered from zero
    * @n: `gint`, load this many pages
    * @dpi: `gdouble`, render at this DPI
    * @scale: `gdouble`, scale render by this factor
    * @background: [struct@ArrayDouble], background colour
    * @page_box: [enum@ForeignPdfPageBox], use this page box (pdfium only)

::: seealso
    [ctor@Image.pdfload].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="868"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/foreign.c"
             line="2805">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="buf" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2783">memory area to load</doc>
          <array length="1" zero-terminated="0" c:type="void*">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2784">size of memory area</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2785">image to write</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2786">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="pdfload_source"
              c:identifier="vips_pdfload_source"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/foreign.c"
           line="2827">Exactly as [ctor@Image.pdfload], but read from a source.

::: tip "Optional arguments"
    * @page: `gint`, load this page, numbered from zero
    * @n: `gint`, load this many pages
    * @dpi: `gdouble`, render at this DPI
    * @scale: `gdouble`, scale render by this factor
    * @background: [struct@ArrayDouble], background colour
    * @page_box: [enum@ForeignPdfPageBox], use this page box (pdfium only)

::: seealso
    [ctor@Image.pdfload]</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="871"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/foreign.c"
             line="2846">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="source" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2829">source to load from</doc>
          <type name="Source" c:type="VipsSource*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2830">image to write</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/foreign.c"
               line="2831">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="perlin" c:identifier="vips_perlin" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/create/perlin.c"
           line="337">Create a one-band float image of [Perlin
noise](https://en.wikipedia.org/wiki/Perlin_noise).

Use @cell_size to set the size of the cells from which the image is
constructed. The default is 256 x 256.

If @width and @height are multiples of @cell_size, the image will tessellate.

Normally, output pixels are [enum@Vips.BandFormat.FLOAT] in the range
[-1, +1]. Set @uchar to output a uchar image with pixels in [0, 255].

::: tip "Optional arguments"
    * @cell_size: `gint`, size of Perlin cells
    * @uchar: `gboolean`, output a uchar image

::: seealso
    [ctor@Image.worley], [ctor@Image.fractsurf], [ctor@Image.gaussnoise].</doc>
      <source-position filename="libvips/include/vips/create.h" line="165"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/create/perlin.c"
             line="362">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/create/perlin.c"
               line="339">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/perlin.c"
               line="340">horizontal size</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/perlin.c"
               line="341">vertical size</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/perlin.c"
               line="342">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="pipe_read_limit_set"
              c:identifier="vips_pipe_read_limit_set">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/source.c"
           line="126">If a source does not support mmap or seek and the source is
used with a loader that can only work from memory, then the data will be
automatically read into memory to EOF before the loader starts. This can
produce high memory use if the descriptor represents a large object.

Use [func@pipe_read_limit_set] to limit the size of object that
will be read in this way. The default is 1GB.

Set a value of -1 to mean no limit.

::: seealso
    `--vips-pipe-read-limit` and the environment variable
    `VIPS_PIPE_READ_LIMIT`.</doc>
      <source-position filename="libvips/include/vips/connection.h"
                       line="100"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="limit" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/source.c"
               line="128">maximum number of bytes to buffer from a pipe</doc>
          <type name="gint64" c:type="gint64"/>
        </parameter>
      </parameters>
    </function>
    <function name="pngload" c:identifier="vips_pngload" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/pngload.c"
           line="400">Read a PNG file into a VIPS image. It can read all png images, including 8-
and 16-bit images, 1 and 3 channel, with and without an alpha channel.

Any ICC profile is read and attached to the VIPS image. It also supports
XMP metadata.

Use @fail_on to set the type of error that will cause load to fail. By
default, loaders are permissive, that is, [enum@Vips.FailOn.NONE].

By default, the PNG loader limits the number of text and data chunks to
block some denial of service attacks. Set @unlimited to disable these
limits.

::: tip "Optional arguments"
    * @fail_on: [enum@FailOn], types of read error to fail on
    * @unlimited: `gboolean`, Remove all denial of service limits

::: seealso
    [ctor@Image.new_from_file].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="756"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/pngload.c"
             line="426">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/pngload.c"
               line="402">file to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/pngload.c"
               line="403">decompressed image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/pngload.c"
               line="404">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="pngload_buffer"
              c:identifier="vips_pngload_buffer"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/pngload.c"
           line="441">Exactly as [ctor@Image.pngload], but read from a PNG-formatted memory block.

You must not free the buffer while @out is active. The
[signal@Object::postclose] signal on @out is a good place to free.

::: tip "Optional arguments"
    * @fail_on: [enum@FailOn], types of read error to fail on
    * @unlimited: `gboolean`, Remove all denial of service limits

::: seealso
    [ctor@Image.pngload].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="759"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/pngload.c"
             line="460">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="buf" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/pngload.c"
               line="443">memory area to load</doc>
          <array length="1" zero-terminated="0" c:type="void*">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/pngload.c"
               line="444">size of memory area</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/pngload.c"
               line="445">image to write</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/pngload.c"
               line="446">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="pngload_source"
              c:identifier="vips_pngload_source"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/pngload.c"
           line="482">Exactly as [ctor@Image.pngload], but read from a source.

::: tip "Optional arguments"
    * @fail_on: [enum@FailOn], types of read error to fail on
    * @unlimited: `gboolean`, Remove all denial of service limits

::: seealso
    [ctor@Image.pngload].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="753"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/pngload.c"
             line="497">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="source" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/pngload.c"
               line="484">source to load from</doc>
          <type name="Source" c:type="VipsSource*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/pngload.c"
               line="485">image to write</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/pngload.c"
               line="486">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="ppmload" c:identifier="vips_ppmload" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/ppmload.c"
           line="973">Read a PPM/PBM/PGM/PFM file into a VIPS image.

It can read 1, 8, 16 and 32 bit images, colour or monochrome,
stored in binary or in ASCII. One bit images become 8 bit VIPS images,
with 0 and 255 for 0 and 1.

::: seealso
    [ctor@Image.new_from_file].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="803"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/ppmload.c"
             line="988">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/ppmload.c"
               line="975">file to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/ppmload.c"
               line="976">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/ppmload.c"
               line="977">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="ppmload_buffer"
              c:identifier="vips_ppmload_buffer"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/ppmload.c"
           line="1003">Exactly as [ctor@Image.ppmload], but read from a memory source.

::: seealso
    [ctor@Image.ppmload].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="806"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/ppmload.c"
             line="1015">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="buf" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/ppmload.c"
               line="1005">memory area to load</doc>
          <array length="1" zero-terminated="0" c:type="void*">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/ppmload.c"
               line="1006">size of memory area</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/ppmload.c"
               line="1007">image to write</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/ppmload.c"
               line="1008">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="ppmload_source"
              c:identifier="vips_ppmload_source"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/ppmload.c"
           line="1037">Exactly as [ctor@Image.ppmload], but read from a source.

::: seealso
    [ctor@Image.ppmload].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="809"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/ppmload.c"
             line="1048">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="source" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/ppmload.c"
               line="1039">source to load</doc>
          <type name="Source" c:type="VipsSource*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/ppmload.c"
               line="1040">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/ppmload.c"
               line="1041">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="profile_load"
              c:identifier="vips_profile_load"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/colour/profile_load.c"
           line="170">Load a named profile.

Profiles are loaded from four sources:

- The special name `"none"` means no profile. @profile will be `NULL` in this
  case.

- @name can be the name of one of the ICC profiles embedded in libvips.
  These names can be at least `"cmyk"`, `"p3"` and `"srgb"`.

- @name can be the full path to a file.

- @name can be the name of an ICC profile in the system profile directory
  for your platform.</doc>
      <source-position filename="libvips/include/vips/colour.h" line="224"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/colour/profile_load.c"
             line="191">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/profile_load.c"
               line="172">name of profile to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="profile"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/colour/profile_load.c"
               line="173">loaded profile</doc>
          <type name="Blob" c:type="VipsBlob**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/profile_load.c"
               line="174">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="profile_set" c:identifier="vips_profile_set">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/gate.c"
           line="87">If set, vips will record profiling information, and dump it on program
exit. These profiles can be analysed with the `vipsprofile` program.</doc>
      <source-position filename="libvips/include/vips/gate.h" line="73"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="profile" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/gate.c"
               line="89">`TRUE` to enable profile recording</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="progress_set"
              c:identifier="vips_progress_set"
              moved-to="Progress.set">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/image.c"
           line="387">If set, vips will print messages about the progress of computation to
stdout. This can also be enabled with the `--vips-progress` option, or by
setting the environment variable `VIPS_PROGRESS`.</doc>
      <source-position filename="libvips/include/vips/image.h" line="437"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="progress" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/image.c"
               line="389">`TRUE` to enable progress messages</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="pythagoras" c:identifier="vips_pythagoras">
      <doc xml:space="preserve"
           filename="libvips/colour/dE76.c"
           line="61">Pythagorean distance between two points in colour space. Lab/XYZ/CMC etc.</doc>
      <source-position filename="libvips/include/vips/colour.h" line="314"/>
      <return-value transfer-ownership="none">
        <type name="gfloat" c:type="float"/>
      </return-value>
      <parameters>
        <parameter name="L1" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/dE76.c"
               line="63">Input coordinate 1</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="a1" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/dE76.c"
               line="64">Input coordinate 1</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="b1" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/dE76.c"
               line="65">Input coordinate 1</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="L2" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/dE76.c"
               line="66">Input coordinate 2</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="a2" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/dE76.c"
               line="67">Input coordinate 2</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="b2" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/colour/dE76.c"
               line="68">Input coordinate 2</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="radload" c:identifier="vips_radload" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/radload.c"
           line="363">Read a Radiance (HDR) file into a VIPS image.

Radiance files are read as [enum@Vips.Coding.RAD]. They have one byte for each of
red, green and blue, and one byte of shared exponent. Some operations (like
[method@Image.extract_area]) can work directly with images in this format, but
mmany (all the arithmetic operations, for example) will not. Unpack
[enum@Vips.Coding.RAD] images to 3 band float with [method@Image.rad2float] if
you want to do arithmetic on them.

This operation ignores some header fields, like VIEW and DATE. It will not
rotate/flip as the FORMAT string asks.

Sections of this reader from Greg Ward and Radiance with kind permission.

::: seealso
    [ctor@Image.new_from_file].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="826"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/radload.c"
             line="386">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/radload.c"
               line="365">file to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/radload.c"
               line="366">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/radload.c"
               line="367">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="radload_buffer"
              c:identifier="vips_radload_buffer"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/radload.c"
           line="401">Exactly as [ctor@Image.radload], but read from a HDR-formatted memory block.

You must not free the buffer while @out is active. The
[signal@Object::postclose] signal on @out is a good place to free.

::: seealso
    [ctor@Image.radload].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="829"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/radload.c"
             line="416">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="buf" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/radload.c"
               line="403">memory area to load</doc>
          <array length="1" zero-terminated="0" c:type="void*">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/radload.c"
               line="404">size of memory area</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/radload.c"
               line="405">image to write</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/radload.c"
               line="406">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="radload_source"
              c:identifier="vips_radload_source"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/radload.c"
           line="438">Exactly as [ctor@Image.radload], but read from a source.

::: seealso
    [ctor@Image.radload].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="823"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/radload.c"
             line="449">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="source" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/radload.c"
               line="440">source to load from</doc>
          <type name="Source" c:type="VipsSource*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/radload.c"
               line="441">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/radload.c"
               line="442">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="rawload" c:identifier="vips_rawload" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/rawload.c"
           line="195">This operation mmaps the file, setting up @out so that access to that
image will read from the file.

By default, it assumes uchar pixels. Use @format to select something else.

The image will be tagged as [enum@Vips.Interpretation.MULTIBAND]. Use
@interpretation to select something else.

Use [method@Image.byteswap] to reverse the byte ordering if necessary.

::: tip "Optional arguments"
    * @offset: `guint64`, offset in bytes from start of file
    * @format: [enum@BandFormat], set image format
    * @interpretation: [enum@Interpretation], set image interpretation

::: seealso
    [ctor@Image.new_from_file], [method@Image.copy], [method@Image.byteswap].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="673"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/rawload.c"
             line="222">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/rawload.c"
               line="197">file to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/rawload.c"
               line="198">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/rawload.c"
               line="199">width of image in pixels</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/rawload.c"
               line="200">height of image in pixels</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="bands" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/rawload.c"
               line="201">number of image bands</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/rawload.c"
               line="202">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="realpath" c:identifier="vips_realpath">
      <source-position filename="libvips/include/vips/util.h" line="342"/>
      <return-value transfer-ownership="full">
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="path" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="rename" c:identifier="vips_rename">
      <source-position filename="libvips/include/vips/util.h" line="301"/>
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="old_name" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="new_name" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="rmdirf" c:identifier="vips_rmdirf" introspectable="0">
      <source-position filename="libvips/include/vips/util.h" line="298"/>
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="sdf" c:identifier="vips_sdf" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/create/sdf.c"
           line="360">Create a signed distance field (SDF) image of the given @shape.

Different
shapes use different combinations of the optional arguments, see below.

@shape [enum@Vips.SdfShape.CIRCLE]: create a circle centred on @a, radius @r.

@shape [enum@Vips.SdfShape.BOX]: create a box with top-left corner @a and
bottom-right corner @b.

@shape [enum@Vips.SdfShape.ROUNDED_BOX]: create a box with top-left corner @a
and bottom-right corner @b, whose four corners are
rounded by the four-element float array @corners. @corners will default to
0.0.

@shape [enum@Vips.SdfShape.LINE]: draw a line from @a to @b.

::: tip "Optional arguments"
    * @a: [struct@ArrayDouble], first point
    * @b: [struct@ArrayDouble], second point
    * @r: `gdouble`, radius
    * @corners: [struct@ArrayDouble], corner radii

::: seealso
    [ctor@Image.grey], [method@Image.grid], [ctor@Image.xyz].</doc>
      <source-position filename="libvips/include/vips/create.h" line="91"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/create/sdf.c"
             line="394">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/create/sdf.c"
               line="362">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/sdf.c"
               line="363">horizontal size</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/sdf.c"
               line="364">vertical size</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="shape" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/sdf.c"
               line="365">SDF to create</doc>
          <type name="SdfShape" c:type="VipsSdfShape"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/sdf.c"
               line="366">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="shutdown" c:identifier="vips_shutdown">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/init.c"
           line="714">Call this to drop caches, close plugins, terminate background threads, and
finalize any internal library testing.

[func@shutdown] is optional. If you don't call it, your platform will
clean up for you. The only negative consequences are that the leak checker
and the profiler will not work.

You may call [func@INIT] many times and [func@shutdown] many times, but you
must not call [func@INIT] after [func@shutdown]. In other words, you cannot
stop and restart libvips.

::: seealso
    [func@profile_set], [func@leak_set].</doc>
      <source-position filename="libvips/include/vips/vips.h" line="175"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="sines" c:identifier="vips_sines" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/create/sines.c"
           line="149">Creates a float one band image of the a sine waveform in two
dimensions.

The number of horizontal and vertical spatial frequencies are
determined by the variables @hfreq and @vfreq respectively.  The
function is useful for creating displayable sine waves and
square waves in two dimensions.

If horfreq and verfreq are integers the resultant image is periodical
and therefore the Fourier transform does not present spikes

Pixels are normally in [-1, +1], set @uchar to output [0, 255].

::: tip "Optional arguments"
    * @hfreq: `gdouble`, horizontal frequency
    * @vreq: `gdouble`, vertical frequency
    * @uchar: `gboolean`, output a uchar image

::: seealso
    [ctor@Image.grey], [ctor@Image.xyz].</doc>
      <source-position filename="libvips/include/vips/create.h" line="85"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/create/sines.c"
             line="177">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/create/sines.c"
               line="151">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/sines.c"
               line="152">image size</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/sines.c"
               line="153">image size</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/sines.c"
               line="154">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="sink_memory" c:identifier="vips_sink_memory">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/sinkmemory.c"
           line="310">Loops over @im, generating it to a memory buffer attached to @im. It is
used by vips to implement writing to a memory buffer.

::: seealso
    [method@Image.sink], [method@Image.get_tile_size],
    [ctor@Image.new_memory].</doc>
      <source-position filename="libvips/include/vips/generate.h" line="62"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/sinkmemory.c"
             line="321">0 on success, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/sinkmemory.c"
               line="312">generate this image to memory</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="slist_equal" c:identifier="vips_slist_equal">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/util.c"
           line="75">Test two lists for equality.</doc>
      <source-position filename="libvips/include/vips/util.h" line="253"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/util.c"
             line="82">`TRUE` if @l1 is equal to @l2. `FALSE` otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="l1" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/util.c"
               line="77">a [struct@GLib.SList]</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="guint8"/>
          </type>
        </parameter>
        <parameter name="l2" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/util.c"
               line="78">another [struct@GLib.SList]</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="guint8"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="slist_filter" c:identifier="vips_slist_filter">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/util.c"
           line="220">Remove all occurrences of an item from a list.
Returns the new head of the list.</doc>
      <source-position filename="libvips/include/vips/util.h" line="265"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/util.c"
             line="230">new head of @list</doc>
        <type name="GLib.SList" c:type="GSList*">
          <type name="guint8"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="list" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/util.c"
               line="222">a [struct@GLib.SList]</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="guint8"/>
          </type>
        </parameter>
        <parameter name="fn" transfer-ownership="none" scope="call">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/util.c"
               line="223">function to call for each element.</doc>
          <type name="SListMap2Fn" c:type="VipsSListMap2Fn"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/util.c"
               line="224">user data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/util.c"
               line="225">user data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="slist_fold2" c:identifier="vips_slist_fold2">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/util.c"
           line="190">Fold over a slist, applying @fn to each element.</doc>
      <source-position filename="libvips/include/vips/util.h" line="262"/>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/util.c"
             line="200">`NULL` if @fn returns `NULL` for all arguments, otherwise the first
non-`NULL` value from @fn.</doc>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="list" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/util.c"
               line="192">a [struct@GLib.SList]</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="guint8"/>
          </type>
        </parameter>
        <parameter name="start"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/util.c"
               line="193">initial value for the accumulator</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="fn" transfer-ownership="none" scope="call">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/util.c"
               line="194">function to apply to each list element</doc>
          <type name="SListFold2Fn" c:type="VipsSListFold2Fn"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/util.c"
               line="195">user data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/util.c"
               line="196">user data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="slist_free_all" c:identifier="vips_slist_free_all">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/util.c"
           line="269">Free a [struct@GLib.SList] of things which need [func@GLib.free]ing.</doc>
      <source-position filename="libvips/include/vips/util.h" line="267"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="list" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/util.c"
               line="271">a [struct@GLib.SList]</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="guint8"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="slist_map2" c:identifier="vips_slist_map2">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/util.c"
           line="101">Map over a slist. _copy() the list in case the callback changes it.</doc>
      <source-position filename="libvips/include/vips/util.h" line="255"/>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/util.c"
             line="110">`NULL` if @fn returns `NULL` for all arguments, otherwise the first
non-`NULL` value from @fn.</doc>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="list" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/util.c"
               line="103">a [struct@GLib.SList]</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="guint8"/>
          </type>
        </parameter>
        <parameter name="fn" transfer-ownership="none" scope="call">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/util.c"
               line="104">function to apply to each list element</doc>
          <type name="SListMap2Fn" c:type="VipsSListMap2Fn"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/util.c"
               line="105">user data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/util.c"
               line="106">user data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="slist_map2_rev" c:identifier="vips_slist_map2_rev">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/util.c"
           line="129">Map backwards. We _reverse() rather than recurse and unwind to save stack.</doc>
      <source-position filename="libvips/include/vips/util.h" line="257"/>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/util.c"
             line="138">`NULL` if @fn returns `NULL` for all arguments, otherwise the first
non-`NULL` value from @fn.</doc>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="list" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/util.c"
               line="131">a [struct@GLib.SList]</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="guint8"/>
          </type>
        </parameter>
        <parameter name="fn" transfer-ownership="none" scope="call">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/util.c"
               line="132">function to apply to each list element</doc>
          <type name="SListMap2Fn" c:type="VipsSListMap2Fn"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/util.c"
               line="133">user data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/util.c"
               line="134">user data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="slist_map4" c:identifier="vips_slist_map4">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/util.c"
           line="158">Map over a slist. _copy() the list in case the callback changes it.</doc>
      <source-position filename="libvips/include/vips/util.h" line="259"/>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/util.c"
             line="169">`NULL` if @fn returns `NULL` for all arguments, otherwise the first
non-`NULL` value from @fn.</doc>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="list" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/util.c"
               line="160">a [struct@GLib.SList]</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="guint8"/>
          </type>
        </parameter>
        <parameter name="fn" transfer-ownership="none" scope="call">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/util.c"
               line="161">function to apply to each list element</doc>
          <type name="SListMap4Fn" c:type="VipsSListMap4Fn"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/util.c"
               line="162">user data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/util.c"
               line="163">user data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="c"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/util.c"
               line="164">user data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="d"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/util.c"
               line="165">user data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="start_many" c:identifier="vips_start_many">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/generate.c"
           line="494">Start function for many images in. @a is a pointer to
a `NULL`-terminated array of input images.

::: seealso
    [method@Image.generate], [func@allocate_input_array]</doc>
      <source-position filename="libvips/include/vips/generate.h" line="69"/>
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/generate.c"
               line="496">image to generate</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/generate.c"
               line="497">user data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/generate.c"
               line="498">user data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="start_one" c:identifier="vips_start_one">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/generate.c"
           line="426">Start function for one image in. Input image is @a.

::: seealso
    [method@Image.generate].</doc>
      <source-position filename="libvips/include/vips/generate.h" line="65"/>
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="out" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/generate.c"
               line="428">image to generate</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/generate.c"
               line="429">user data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/generate.c"
               line="430">user data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="stop_many" c:identifier="vips_stop_many">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/generate.c"
           line="466">Stop function for many images in. @a is a pointer to
a `NULL`-terminated array of input images.

::: seealso
    [method@Image.generate].</doc>
      <source-position filename="libvips/include/vips/generate.h" line="71"/>
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="seq"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/generate.c"
               line="468">sequence value</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/generate.c"
               line="469">user data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/generate.c"
               line="470">user data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="stop_one" c:identifier="vips_stop_one">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/generate.c"
           line="445">Stop function for one image in. Input image is @a.

::: seealso
    [method@Image.generate].</doc>
      <source-position filename="libvips/include/vips/generate.h" line="67"/>
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="seq"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/generate.c"
               line="447">sequence value</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/generate.c"
               line="448">user data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/generate.c"
               line="449">user data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="strdup" c:identifier="vips_strdup">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/memory.c"
           line="171">[func@GLib.strdup] a string. When @object is freed, the string will be freed for
you.  If @object is `NULL`, you need to
free the memory yourself with [func@GLib.free].

This function cannot fail.

::: seealso
    [func@malloc].</doc>
      <source-position filename="libvips/include/vips/memory.h" line="99"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/memory.c"
             line="185">a pointer to the allocated memory</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/memory.c"
               line="173">allocate memory local to this [class@Object], or `NULL`</doc>
          <type name="Object" c:type="VipsObject*"/>
        </parameter>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/memory.c"
               line="174">string to copy</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="strtod" c:identifier="vips_strtod">
      <source-position filename="libvips/include/vips/util.h" line="345"/>
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <type name="gdouble" c:type="double*"/>
        </parameter>
      </parameters>
    </function>
    <function name="sum" c:identifier="vips_sum" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/arithmetic/sum.c"
           line="174">This operation sums all images in @in and writes the result to @out.

If the images differ in size, the smaller images are enlarged to match the
largest by adding zero pixels along the bottom and right.

If the number of bands differs, all but one of the images
must have one band. In this case, n-band images are formed from the
one-band images by joining n copies of the one-band images together, and then
the n-band images are operated upon.

The input images are cast up to the smallest common format (see table
Smallest common format in
[arithmetic](libvips-arithmetic.html)), then the
following table is used to determine the output type:

## [func@Image.sum] type promotion

| input type     | output type    |
|----------------|----------------|
| uchar          | uint           |
| char           | int            |
| ushort         | uint           |
| short          | int            |
| uint           | uint           |
| int            | int            |
| float          | float          |
| double         | double         |
| complex        | complex        |
| double complex | double complex |

In other words, the output type is just large enough to hold the whole
range of possible values.

::: seealso
    [method@Image.add].</doc>
      <source-position filename="libvips/include/vips/arithmetic.h"
                       line="198"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/arithmetic/sum.c"
             line="217">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/sum.c"
               line="176">array of input images</doc>
          <array length="2" zero-terminated="0" c:type="VipsImage**">
            <type name="Image" c:type="VipsImage*"/>
          </array>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/sum.c"
               line="177">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/sum.c"
               line="178">number of input images</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/arithmetic/sum.c"
               line="179">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="svgload" c:identifier="vips_svgload" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/svgload.c"
           line="1105">Render a SVG file into a VIPS image.

Rendering uses the librsvg library and should be fast.

Use @dpi to set the rendering resolution. The default is 72. Additionally,
you can scale by setting @scale. If you set both, they combine.

This function only reads the image header and does not render any pixel
data. Rendering occurs when pixels are accessed.

SVGs larger than 10MB are normally blocked for security. Set @unlimited to
allow SVGs of any size.

A UTF-8 string containing custom CSS can be provided via @stylesheet.
During the CSS cascade, the specified stylesheet will be applied with a
User Origin. This feature requires librsvg 2.48.0 or later.

If @high_bitdepth is set and the version of cairo supports it
(e.g. cairo &gt;= 1.17.2), enable 128-bit scRGB output (32-bit per channel).

::: tip "Optional arguments"
    * @dpi: `gdouble`, render at this DPI
    * @scale: `gdouble`, scale render by this factor
    * @unlimited: `gboolean`, allow SVGs of any size
    * @stylesheet: `gchararray`, custom CSS
    * @high_bitdepth: `gboolean`, enable scRGB 128-bit output

::: seealso
    [ctor@Image.new_from_file].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="875"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/svgload.c"
             line="1141">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/svgload.c"
               line="1107">file to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/svgload.c"
               line="1108">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/svgload.c"
               line="1109">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="svgload_buffer"
              c:identifier="vips_svgload_buffer"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/svgload.c"
           line="1156">Read a SVG-formatted memory block into a VIPS image. Exactly as
[ctor@Image.svgload], but read from a memory buffer.

You must not free the buffer while @out is active. The
[signal@Object::postclose] signal on @out is a good place to free.

::: tip "Optional arguments"
    * @dpi: `gdouble`, render at this DPI
    * @scale: `gdouble`, scale render by this factor
    * @unlimited: `gboolean`, allow SVGs of any size
    * @stylesheet: `gchararray`, custom CSS
    * @high_bitdepth: `gboolean`, enable scRGB 128-bit output

::: seealso
    [ctor@Image.svgload].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="878"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/svgload.c"
             line="1179">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="buf" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/svgload.c"
               line="1158">memory area to load</doc>
          <array length="1" zero-terminated="0" c:type="void*">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/svgload.c"
               line="1159">size of memory area</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/svgload.c"
               line="1160">image to write</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/svgload.c"
               line="1161">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="svgload_source"
              c:identifier="vips_svgload_source"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/svgload.c"
           line="1242">Exactly as [ctor@Image.svgload], but read from a source.

::: seealso
    [ctor@Image.svgload].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="884"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/svgload.c"
             line="1253">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="source" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/svgload.c"
               line="1244">source to load from</doc>
          <type name="Source" c:type="VipsSource*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/svgload.c"
               line="1245">image to write</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/svgload.c"
               line="1246">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="svgload_string"
              c:identifier="vips_svgload_string"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/svgload.c"
           line="1201">Exactly as [ctor@Image.svgload], but read from a string. This function
takes a copy of the string.

::: tip "Optional arguments"
    * @dpi: `gdouble`, render at this DPI
    * @scale: `gdouble`, scale render by this factor
    * @unlimited: `gboolean`, allow SVGs of any size
    * @stylesheet: `gchararray`, custom CSS
    * @high_bitdepth: `gboolean`, enable scRGB 128-bit output

::: seealso
    [ctor@Image.svgload].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="881"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/svgload.c"
             line="1220">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/svgload.c"
               line="1203">string to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/svgload.c"
               line="1204">image to write</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/svgload.c"
               line="1205">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="switch" c:identifier="vips_switch" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/conversion/switch.c"
           line="226">The @tests images are evaluated and at each point the index of the first
non-zero value is written to @out. If all @tests are false, the value
(@n + 1) is written.

Images in @tests must have one band. They are expanded to the
bounding box of the set of images in @tests, and that size is used for
@out. @tests can have up to 255 elements.

Combine with [method@Image.case] to make an efficient multi-way [method@Image.ifthenelse].

::: seealso
    [method@Image.maplut], [method@Image.case], [method@Image.ifthenelse].</doc>
      <source-position filename="libvips/include/vips/conversion.h"
                       line="320"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/conversion/switch.c"
             line="246">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="tests" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/switch.c"
               line="228">test these images</doc>
          <array length="2" zero-terminated="0" c:type="VipsImage**">
            <type name="Image" c:type="VipsImage*"/>
          </array>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/conversion/switch.c"
               line="229">output index image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/switch.c"
               line="230">number of input images</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/conversion/switch.c"
               line="231">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="system" c:identifier="vips_system" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/system.c"
           line="352">[ctor@Image.system] runs a command, optionally passing a set of images in and
optionally getting an image back. The command's stdout is returned in @log.

First, if @in is set, the array of images are written to files. See
[ctor@Image.new_temp_file] to see how temporary files are created.
If @in_format is something like `%s.png`, the file will be written in PNG
format. By default, @in_format is `%s.tif`.

If @out_format is set, an output filename is formed in the same way. Any
trailing `[options]` are stripped from @out_format.

The command string to run is made by substituting the first set of `%s`
in @cmd_format for the names of the input files, if @in is set, and then
the next `%s` for the output filename, if @out_format is set.
You can put a number between the `%` and the `s` to change the order
in which the substitution occurs.

The command is executed with [`popen()`](man:popen(3)) and the output
captured in @log.

After the command finishes, if @out_format is set, the output image is
opened and returned in @out. You can append `[options]` to @out_format to
control how this open happens.

Closing @out image will automatically delete the output file.

Finally the input images are deleted.

If @cache is set, this call will be added to the libvips operation cache
and reused if possible.

For example, this call will run the ImageMagick convert program on an
image, using JPEG files to pass images into and out of the convert command.

```c
VipsArrayImage *in;
VipsImage *out;
char *log;

if (vips_system("convert %s -swirl 45 %s",
        "in", in,
        "out", &amp;out,
        "in_format", "%s.jpg",
        "out_format", "%s.jpg",
        "cache", TRUE,
        "log", &amp;log,
        NULL))
    error ...
```

::: tip "Optional arguments"
    * @in: [struct@ArrayImage], array of input images
    * @out: [class@Image], output, image
    * @in_format: `gchararray`, write input files like this
    * @out_format: `gchararray`, write output filename like this
    * @cache: `gboolean`, cache this call
    * @log: `gchararray`, output, stdout of command is returned here</doc>
      <source-position filename="libvips/include/vips/image.h" line="579"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/system.c"
             line="415">0 on success, -1 on failure.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="cmd_format" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/system.c"
               line="354">command to run</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/system.c"
               line="355">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="text" c:identifier="vips_text" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/create/text.c"
           line="661">Draw the string @text to an image.

@out is normally a one-band 8-bit
unsigned char image, with 0 for no text and 255 for text. Values between
are used for anti-aliasing.

Set @rgba to enable RGBA output. This is useful for colour emoji rendering,
or support for pango markup features like `&lt;span
foreground="red"&gt;Red!&lt;/span&gt;`.

@text is the text to render as a UTF-8 string. It can contain Pango markup,
for example `&lt;i&gt;The&lt;/i&gt;Guardian`.

@font is the font to render with, as a fontconfig name. Examples might be
`sans 12` or perhaps `bitstream charter bold 10`.

You can specify a font to load with @fontfile. You'll need to also set the
name of the font with @font.

@width is the number of pixels to word-wrap at. By default, lines of text
wider than this will be broken at word boundaries.
Use @wrap to set lines to wrap on word or character boundaries, or to
disable line breaks.

Set @justify to turn on line justification.
@align can be used to set the alignment style for multi-line
text to the low (left) edge centre, or high (right) edge. Note that the
output image can be wider than @width if there are no
word breaks, or narrower if the lines don't break exactly at @width.

@height is the maximum number of pixels high the generated text can be. This
only takes effect when @dpi is not set, and @width is set, making a box.
In this case, [ctor@Image.text] will search for a @dpi and set of line breaks
which will just fit the text into @width and @height.

You can use @autofit_dpi to read out the DPI selected by auto fit.

@dpi sets the resolution to render at. "sans 12" at 72 dpi draws characters
approximately 12 pixels high.

@spacing sets the line spacing, in points. It would typically be something
like font size times 1.2.

You can read the coordinate of the top edge of the character from `Xoffset`
/ `Yoffset`. This can be helpful if you need to line up the output of
several [ctor@Image.text].

::: tip "Optional arguments"
    * @font: `gchararray`, font to render with
    * @fontfile: `gchararray`, load this font file
    * @width: `gint`, image should be no wider than this many pixels
    * @height: `gint`, image should be no higher than this many pixels
    * @align: [enum@Align], set justification alignment
    * @justify: `gboolean`, justify lines
    * @dpi: `gint`, render at this resolution
    * @autofit_dpi: `gint`, output, auto-fitted DPI
    * @rgba: `gboolean`, enable RGBA output
    * @spacing: `gint`, space lines by this in points
    * @wrap: [enum@TextWrap], wrap lines on characters or words

::: seealso
    [func@Image.bandjoin], [func@Image.composite].</doc>
      <source-position filename="libvips/include/vips/create.h" line="75"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/create/text.c"
             line="730">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/create/text.c"
               line="663">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="text" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/text.c"
               line="664">utf-8 text string to render</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/text.c"
               line="665">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="thread_execute" c:identifier="vips_thread_execute">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/threadpool.c"
           line="137">A newly created or reused thread will execute @func with the
argument @data.</doc>
      <source-position filename="libvips/include/vips/thread.h" line="46"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/threadpool.c"
             line="146">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/threadpool.c"
               line="139">a name for the thread (useful for debugging)</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="func"
                   transfer-ownership="none"
                   scope="async"
                   closure="2">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/threadpool.c"
               line="140">a function to execute in the libvips threadset</doc>
          <type name="GLib.Func" c:type="GFunc"/>
        </parameter>
        <parameter name="data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/threadpool.c"
               line="141">an argument to supply to @func</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="thread_isvips" c:identifier="vips_thread_isvips">
      <source-position filename="libvips/include/vips/thread.h" line="43"/>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
    </function>
    <function name="thread_shutdown" c:identifier="vips_thread_shutdown">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/init.c"
           line="691">Free any thread-private data and flush any profiling information.

This function needs to be called when a thread that has been using vips
exits. It is called for you by [func@shutdown] and for any threads created
within the thread pool.

You will need to call it from threads created in
other ways or there will be memory leaks. If you do not call it, vips
will generate a warning message.

It may be called many times, and you can continue using vips after
calling it. Calling it too often will reduce performance.</doc>
      <source-position filename="libvips/include/vips/vips.h" line="177"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="threadpool_run"
              c:identifier="vips_threadpool_run"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/threadpool.c"
           line="600">This function runs a set of threads over an image. Each thread first calls
@start to create new per-thread state, then runs
@allocate to set up a new work unit (perhaps the next tile in an image, for
example), then @work to process that work unit. After each unit is
processed, @progress is called, so that the operation can give
progress feedback. @progress may be `NULL`.

The object returned by @start must be an instance of a subclass of
[class@ThreadState]. Use this to communicate between @allocate and @work.

@allocate and @start are always single-threaded (so they can write to the
per-pool state), whereas @work can be executed concurrently. @progress is
always called by
the main thread (ie. the thread which called [func@threadpool_run]).

::: seealso
    [func@concurrency_set].</doc>
      <source-position filename="libvips/include/vips/threadpool.h"
                       line="138"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/threadpool.c"
             line="627">0 on success, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="im" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/threadpool.c"
               line="602">image to loop over</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="start" transfer-ownership="none" scope="async">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/threadpool.c"
               line="603">allocate per-thread state</doc>
          <type name="ThreadStartFn" c:type="VipsThreadStartFn"/>
        </parameter>
        <parameter name="allocate" transfer-ownership="none" scope="async">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/threadpool.c"
               line="604">allocate a work unit</doc>
          <type name="ThreadpoolAllocateFn" c:type="VipsThreadpoolAllocateFn"/>
        </parameter>
        <parameter name="work" transfer-ownership="none" scope="async">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/threadpool.c"
               line="605">process a work unit</doc>
          <type name="ThreadpoolWorkFn" c:type="VipsThreadpoolWorkFn"/>
        </parameter>
        <parameter name="progress" transfer-ownership="none" scope="async">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/threadpool.c"
               line="606">give progress feedback about a work unit, or `NULL`</doc>
          <type name="ThreadpoolProgressFn" c:type="VipsThreadpoolProgressFn"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/threadpool.c"
               line="607">client data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="thumbnail"
              c:identifier="vips_thumbnail"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/resample/thumbnail.c"
           line="1308">Make a thumbnail from a file.

Shrinking is done in three stages: using any
shrink-on-load features available in the image load library, using a block
shrink, and using a lanczos3 shrink. At least the final 200% is done with
lanczos3. The output should be high quality, and the operation should be
quick.

See [ctor@Image.thumbnail_buffer] to thumbnail from a memory buffer, or
[ctor@Image.thumbnail_source] to thumbnail from an arbitrary byte source.

By default, libvips will only use the first frame of animated or multipage
images. To thumbnail all pages or frames, pass `n=-1` to the loader in
@filename, for example `"x.gif[n=-1]"`.

The output image will fit within a square of size @width x @width. You can
specify a separate height with the @height option. Set either @width or
@height to a very large number to ignore that dimension.

If you set @crop, then the output image will fill the whole of the @width x
@height rectangle, with any excess cropped away. See [method@Image.smartcrop] for
details on the cropping strategy.

Normally the operation will upsize or downsize as required to fit the image
inside or outside the target size. If @size is set to [enum@Vips.Size.UP],
the operation will only upsize and will just copy if asked to downsize.
If @size is set to [enum@Vips.Size.DOWN], the operation will only downsize
and will just copy if asked to upsize.
If @size is [enum@Vips.Size.FORCE], the image aspect ratio will be broken
and the image will be forced to fit the target.

Normally any orientation tags on the input image (such as EXIF tags) are
interpreted to rotate the image upright. If you set @no_rotate to `TRUE`,
these tags will not be interpreted.

Shrinking is normally done in sRGB colourspace. Set @linear to shrink in
linear light colourspace instead. This can give better results, but can
also be far slower, since tricks like JPEG shrink-on-load cannot be used in
linear space.

If you set @output_profile to the filename of an ICC profile, the image
will be transformed to the target colourspace before writing to the
output. You can also give an @input_profile which will be used if the
input image has no ICC profile, or if the profile embedded in the
input image is broken.

Use @intent to set the rendering intent for any ICC transform. The default
is [enum@Vips.Intent.RELATIVE].

Use @fail_on to control the types of error that will cause loading to fail.
The default is [enum@Vips.FailOn.NONE], ie. thumbnail is permissive.

::: tip "Optional arguments"
    * @height: `gint`, target height in pixels
    * @size: [enum@Size], upsize, downsize, both or force
    * @no_rotate: `gboolean`, don't rotate upright using orientation tag
    * @crop: [enum@Interesting], shrink and crop to fill target
    * @linear: `gboolean`, perform shrink in linear light
    * @input_profile: `gchararray`, fallback input ICC profile
    * @output_profile: `gchararray`, output ICC profile
    * @intent: [enum@Intent], rendering intent
    * @fail_on: [enum@FailOn], load error types to fail on

::: seealso
    [ctor@Image.thumbnail_buffer].</doc>
      <source-position filename="libvips/include/vips/resample.h" line="84"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/resample/thumbnail.c"
             line="1381">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/resample/thumbnail.c"
               line="1310">file to read from</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/resample/thumbnail.c"
               line="1311">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/resample/thumbnail.c"
               line="1312">target width in pixels</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/resample/thumbnail.c"
               line="1313">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="thumbnail_buffer"
              c:identifier="vips_thumbnail_buffer"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/resample/thumbnail.c"
           line="1563">Exactly as [ctor@Image.thumbnail], but read from a memory buffer.

One extra optional argument, @option_string, lets you pass options to the
underlying loader.

::: tip "Optional arguments"
    * @height: `gint`, target height in pixels
    * @size: [enum@Size], upsize, downsize, both or force
    * @no_rotate: `gboolean`, don't rotate upright using orientation tag
    * @crop: [enum@Interesting], shrink and crop to fill target
    * @linear: `gboolean`, perform shrink in linear light
    * @input_profile: `gchararray`, fallback input ICC profile
    * @output_profile: `gchararray`, output ICC profile
    * @intent: [enum@Intent], rendering intent
    * @fail_on: [enum@FailOn], load error types to fail on
    * @option_string: `gchararray`, extra loader options

::: seealso
    [ctor@Image.thumbnail].</doc>
      <source-position filename="libvips/include/vips/resample.h" line="87"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/resample/thumbnail.c"
             line="1591">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="buf" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/resample/thumbnail.c"
               line="1565">memory area to load</doc>
          <array length="1" zero-terminated="0" c:type="void*">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/resample/thumbnail.c"
               line="1566">size of memory area</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/resample/thumbnail.c"
               line="1567">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/resample/thumbnail.c"
               line="1568">target width in pixels</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/resample/thumbnail.c"
               line="1569">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="thumbnail_source"
              c:identifier="vips_thumbnail_source"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/resample/thumbnail.c"
           line="1777">Exactly as [ctor@Image.thumbnail], but read from a source.

One extra
optional argument, @option_string, lets you pass options to the underlying
loader.

::: tip "Optional arguments"
    * @height: `gint`, target height in pixels
    * @size: [enum@Size], upsize, downsize, both or force
    * @no_rotate: `gboolean`, don't rotate upright using orientation tag
    * @crop: [enum@Interesting], shrink and crop to fill target
    * @linear: `gboolean`, perform shrink in linear light
    * @input_profile: `gchararray`, fallback input ICC profile
    * @output_profile: `gchararray`, output ICC profile
    * @intent: [enum@Intent], rendering intent
    * @fail_on: [enum@FailOn], load error types to fail on
    * @option_string: `gchararray`, extra loader options

::: seealso
    [ctor@Image.thumbnail].</doc>
      <source-position filename="libvips/include/vips/resample.h" line="94"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/resample/thumbnail.c"
             line="1805">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="source" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/resample/thumbnail.c"
               line="1779">source to thumbnail</doc>
          <type name="Source" c:type="VipsSource*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/resample/thumbnail.c"
               line="1780">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/resample/thumbnail.c"
               line="1781">target width in pixels</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/resample/thumbnail.c"
               line="1782">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="tiffload" c:identifier="vips_tiffload" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/tiffload.c"
           line="465">Read a TIFF file into a VIPS image.

It is a full baseline TIFF 6 reader,
with extensions for tiled images, multipage images, XYZ and LAB colour
space, pyramidal images and JPEG compression, including CMYK and YCbCr.

@page means load this page from the file. By default the first page (page
0) is read.

@n means load this many pages. By default a single page is read. All the
pages must have the same dimensions, and they are loaded as a tall, thin
"toilet roll" image. The [const@META_PAGE_HEIGHT] metadata
tag gives the height in pixels of each page. Use -1 to load all pages.

Setting @autorotate to `TRUE` will make the loader interpret the
orientation tag and automatically rotate the image appropriately during
load.

If @autorotate is `FALSE`, the metadata field [const@META_ORIENTATION] is set
to the value of the orientation tag. Applications may read and interpret
this field
as they wish later in processing. See [method@Image.autorot]. Save
operations will use [const@META_ORIENTATION], if present, to set the
orientation of output images.

If @autorotate is `TRUE`, the image will be rotated upright during load and
no metadata attached. This can be very slow.

If @subifd is -1 (the default), the main image is selected for each page.
If it is 0 or greater and there is a SUBIFD tag, the indexed SUBIFD is
selected. This can be used to read lower resolution layers from
bioformats-style image pyramids.

Use @fail_on to set the type of error that will cause load to fail. By
default, loaders are permissive, that is, [enum@Vips.FailOn.NONE].

When using libtiff 4.7.0+, the TIFF loader will limit memory allocation
for decoding each input file to 50MB to prevent denial of service attacks.
Set @unlimited to remove this limit.

Any ICC profile is read and attached to the VIPS image as
[const@META_ICC_NAME]. Any XMP metadata is read and attached to the image
as [const@META_XMP_NAME]. Any IPTC is attached as [const@META_IPTC_NAME]. The
image description is
attached as [const@META_IMAGEDESCRIPTION]. Data in the photoshop tag is
attached as [const@META_PHOTOSHOP_NAME].

::: tip "Optional arguments"
    * @page: `gint`, load this page
    * @n: `gint`, load this many pages
    * @autorotate: `gboolean`, use orientation tag to rotate the image
      during load
    * @subifd: `gint`, select this subifd index
    * @fail_on: [enum@FailOn], types of read error to fail on
    * @unlimited: `gboolean`, remove all denial of service limits

::: seealso
    [ctor@Image.new_from_file], [method@Image.autorot].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="636"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/tiffload.c"
             line="530">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/tiffload.c"
               line="467">file to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/tiffload.c"
               line="468">decompressed image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/tiffload.c"
               line="469">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="tiffload_buffer"
              c:identifier="vips_tiffload_buffer"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/tiffload.c"
           line="545">Read a TIFF-formatted memory block into a VIPS image. Exactly as
[ctor@Image.tiffload], but read from a memory source.

You must not free the buffer while @out is active. The
[signal@Object::postclose] signal on @out is a good place to free.

::: tip "Optional arguments"
    * @page: `gint`, load this page
    * @n: `gint`, load this many pages
    * @autorotate: `gboolean`, use orientation tag to rotate the image
      during load
    * @subifd: `gint`, select this subifd index
    * @fail_on: [enum@FailOn], types of read error to fail on
    * @unlimited: `gboolean`, remove all denial of service limits

::: seealso
    [ctor@Image.tiffload].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="639"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/tiffload.c"
             line="570">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="buf" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/tiffload.c"
               line="547">memory area to load</doc>
          <array length="1" zero-terminated="0" c:type="void*">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/tiffload.c"
               line="548">size of memory area</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/tiffload.c"
               line="549">image to write</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/tiffload.c"
               line="550">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="tiffload_source"
              c:identifier="vips_tiffload_source"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/tiffload.c"
           line="592">Exactly as [ctor@Image.tiffload], but read from a source.

::: tip "Optional arguments"
    * @page: `gint`, load this page
    * @n: `gint`, load this many pages
    * @autorotate: `gboolean`, use orientation tag to rotate the image
      during load
    * @subifd: `gint`, select this subifd index
    * @fail_on: [enum@FailOn], types of read error to fail on
    * @unlimited: `gboolean`, remove all denial of service limits

::: seealso
    [ctor@Image.tiffload].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="642"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/tiffload.c"
             line="612">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="source" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/tiffload.c"
               line="594">source to load</doc>
          <type name="Source" c:type="VipsSource*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/tiffload.c"
               line="595">image to write</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/tiffload.c"
               line="596">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="tonelut" c:identifier="vips_tonelut" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/create/tonelut.c"
           line="310">[ctor@Image.tonelut] generates a tone curve for the adjustment of image
levels.

This is mostly designed for adjusting the L* part of a LAB image in
a way suitable for print work, but you can use it for other things too.

The curve is an unsigned 16-bit image with (@in_max + 1) entries,
each in the range [0, @out_max].

@Lb, @Lw are expressed as 0-100, as in LAB colour space. You
specify the scaling for the input and output images with the @in_max and
@out_max parameters.

::: tip "Optional arguments"
    * @in_max: `gint`, input range
    * @out_max: `gint`, output range
    * @Lb: `gdouble`, black-point [0-100]
    * @Lw: `gdouble`, white-point [0-100]
    * @Ps: `gdouble`, shadow point (eg. 0.2)
    * @Pm: `gdouble`, mid-tone point (eg. 0.5)
    * @Ph: `gdouble`, highlight point (eg. 0.8)
    * @S: `gdouble`, shadow adjustment (+/- 30)
    * @M: `gdouble`, mid-tone adjustment (+/- 30)
    * @H: `gdouble`, highlight adjustment (+/- 30)</doc>
      <source-position filename="libvips/include/vips/create.h" line="104"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/create/tonelut.c"
             line="340">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/create/tonelut.c"
               line="312">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/tonelut.c"
               line="313">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="tracked_aligned_alloc"
              c:identifier="vips_tracked_aligned_alloc">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/memory.c"
           line="349">Allocate an area of memory aligned on a boundary specified
by @align that will be tracked by [func@tracked_get_mem]
and friends.

If allocation fails, [func@tracked_aligned_alloc] returns `NULL`
and sets an error message.

You must only free the memory returned with [func@tracked_aligned_free].

::: seealso
    [func@tracked_malloc], [func@tracked_aligned_free], [func@malloc].</doc>
      <source-position filename="libvips/include/vips/memory.h" line="108"/>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/memory.c"
             line="366">a pointer to the allocated memory, or `NULL` on error.</doc>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/memory.c"
               line="351">number of bytes to allocate</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
        <parameter name="align" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/memory.c"
               line="352">specifies the alignment</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="tracked_aligned_free"
              c:identifier="vips_tracked_aligned_free">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/memory.c"
           line="244">Only use it to free memory that was
previously allocated with [func@tracked_aligned_alloc]
with a `NULL` first argument.

::: seealso
    [func@tracked_aligned_alloc].</doc>
      <source-position filename="libvips/include/vips/memory.h" line="104"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="s"
                   transfer-ownership="full"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/memory.c"
               line="246">memory to free</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="tracked_close" c:identifier="vips_tracked_close">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/memory.c"
           line="465">Exactly as [`close()`](man:close(2)), but update the number of files currently open via
[func@tracked_get_files]. This is used
by the vips operation cache to drop cache when the number of files
available is low.

You must only close file descriptors opened with [func@tracked_open].

::: seealso
    [func@tracked_open], [func@tracked_get_files].</doc>
      <source-position filename="libvips/include/vips/memory.h" line="119"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/memory.c"
             line="479">a file descriptor, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="fd" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/memory.c"
               line="467">file to `close()`</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="tracked_free" c:identifier="vips_tracked_free">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/memory.c"
           line="203">Only use it to free memory that was
previously allocated with [func@tracked_malloc]
with a `NULL` first argument.

::: seealso
    [func@tracked_malloc].</doc>
      <source-position filename="libvips/include/vips/memory.h" line="102"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="s"
                   transfer-ownership="full"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/memory.c"
               line="205">memory to free</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="tracked_get_allocs" c:identifier="vips_tracked_get_allocs">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/memory.c"
           line="552">Returns the number of active allocations.</doc>
      <source-position filename="libvips/include/vips/memory.h" line="114"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/memory.c"
             line="557">the number of active allocations</doc>
        <type name="gint" c:type="int"/>
      </return-value>
    </function>
    <function name="tracked_get_files" c:identifier="vips_tracked_get_files">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/memory.c"
           line="573">Returns the number of open files.</doc>
      <source-position filename="libvips/include/vips/memory.h" line="121"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/memory.c"
             line="578">the number of open files</doc>
        <type name="gint" c:type="int"/>
      </return-value>
    </function>
    <function name="tracked_get_mem" c:identifier="vips_tracked_get_mem">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/memory.c"
           line="506">Returns the number of bytes currently allocated via [func@malloc] and
friends. vips uses this figure to decide when to start dropping cache, see
[class@Operation].</doc>
      <source-position filename="libvips/include/vips/memory.h" line="110"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/memory.c"
             line="513">the number of currently allocated bytes</doc>
        <type name="gsize" c:type="size_t"/>
      </return-value>
    </function>
    <function name="tracked_get_mem_highwater"
              c:identifier="vips_tracked_get_mem_highwater">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/memory.c"
           line="529">Returns the largest number of bytes simultaneously allocated via
[func@tracked_malloc]. Handy for estimating max memory requirements for a
program.</doc>
      <source-position filename="libvips/include/vips/memory.h" line="112"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/memory.c"
             line="536">the largest number of currently allocated bytes</doc>
        <type name="gsize" c:type="size_t"/>
      </return-value>
    </function>
    <function name="tracked_malloc" c:identifier="vips_tracked_malloc">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/memory.c"
           line="286">Allocate an area of memory that will be tracked by [func@tracked_get_mem]
and friends.

If allocation fails, [func@tracked_malloc] returns `NULL` and
sets an error message.

You must only free the memory returned with [func@tracked_free].

::: seealso
    [func@tracked_free], [func@malloc].</doc>
      <source-position filename="libvips/include/vips/memory.h" line="106"/>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/memory.c"
             line="301">a pointer to the allocated memory, or `NULL` on error.</doc>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/memory.c"
               line="288">number of bytes to allocate</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="tracked_open" c:identifier="vips_tracked_open">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/memory.c"
           line="424">Exactly as [`open()`](man:open(2)), but the number of files currently open via
[func@tracked_open] is available via [func@tracked_get_files]. This is used
by the vips operation cache to drop cache when the number of files
available is low.

You must only close the file descriptor with [func@tracked_close].

@pathname should be utf8.

::: seealso
    [func@tracked_close], [func@tracked_get_files].</doc>
      <source-position filename="libvips/include/vips/memory.h" line="117"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/memory.c"
             line="442">a file descriptor, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="pathname" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/memory.c"
               line="426">name of file to open</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/memory.c"
               line="427">flags for `open()`</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="mode" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/memory.c"
               line="428">open mode</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_depth" c:identifier="vips_type_depth">
      <source-position filename="libvips/include/vips/object.h" line="676"/>
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_find" c:identifier="vips_type_find">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/object.c"
           line="2949">Search below @basename, return the [alias@GObject.Type] of the class
whose name or @nickname matches, or 0 for not found.
If @basename is `NULL`, the whole of [class@Object] is searched.

This function uses a cache, so it should be quick.

::: seealso
    [func@class_find]</doc>
      <source-position filename="libvips/include/vips/object.h" line="678"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="2963">the [alias@GObject.Type] of the class, or 0 if the class is not found.</doc>
        <type name="GType" c:type="GType"/>
      </return-value>
      <parameters>
        <parameter name="basename" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/object.c"
               line="2951">name of base class</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="nickname" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/object.c"
               line="2952">search for a class with this nickname</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_map" c:identifier="vips_type_map" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/object.c"
           line="2750">Map over a type's children. Stop when @fn returns non-`NULL`
and return that value.</doc>
      <source-position filename="libvips/include/vips/object.h" line="672"/>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="2760">`NULL` if @fn returns `NULL` for all arguments, otherwise the first
non-`NULL` value from @fn.</doc>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="base" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/object.c"
               line="2752">base type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="fn" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/object.c"
               line="2753">call this function for every type</doc>
          <type name="TypeMap2Fn" c:type="VipsTypeMap2Fn"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/object.c"
               line="2754">client data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/object.c"
               line="2755">client data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_map_all"
              c:identifier="vips_type_map_all"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/object.c"
           line="2780">Map over a type's children, direct and indirect. Stop when @fn returns
non-`NULL` and return that value.</doc>
      <source-position filename="libvips/include/vips/object.h" line="674"/>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/object.c"
             line="2789">`NULL` if @fn returns `NULL` for all arguments, otherwise the first
non-`NULL` value from @fn.</doc>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="base" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/object.c"
               line="2782">base type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="fn" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/object.c"
               line="2783">call this function for every type</doc>
          <type name="TypeMapFn" c:type="VipsTypeMapFn"/>
        </parameter>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/object.c"
               line="2784">client data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="uhdrload" c:identifier="vips_uhdrload" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/uhdrload.c"
           line="838">Read an UltraHDR image.

The UltraHDR image is decoded as a tone-mapped SDR base image
plus a gainmap attached as image metadata.

Either process the SDR image and update the gainmap if necessary, or use
[method@Image.uhdr2scRGB] to convert the SDR + gainmap image to full scRGB
HDR.

[method@Image.uhdrsave] can write both scRGB HDR and SDR plus gainmap
images.

Set @shrink to shrink the returned image by an integer factor during load.

::: tip "Optional arguments"
    * @shrink: `gint`, shrink by this factor on load

::: seealso
    [ctor@Image.new_from_file], [method@Image.uhdr2scRGB].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="918"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/uhdrload.c"
             line="864">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/uhdrload.c"
               line="840">file to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/uhdrload.c"
               line="841">decompressed image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/uhdrload.c"
               line="842">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="uhdrload_buffer"
              c:identifier="vips_uhdrload_buffer"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/uhdrload.c"
           line="879">Exactly as [ctor@Image.uhdrload], but read from a buffer.

::: tip "Optional arguments"
    * @shrink: `gint`, shrink by this factor on load</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="921"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/uhdrload.c"
             line="891">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="buf" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/uhdrload.c"
               line="881">memory area to load</doc>
          <array length="1" zero-terminated="0" c:type="void*">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/uhdrload.c"
               line="882">size of memory area</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/uhdrload.c"
               line="883">image to write</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/uhdrload.c"
               line="884">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="uhdrload_source"
              c:identifier="vips_uhdrload_source"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/uhdrload.c"
           line="913">Exactly as [ctor@Image.uhdrload], but read from a source.

::: tip "Optional arguments"
    * @shrink: `gint`, shrink by this factor on load</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="924"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/uhdrload.c"
             line="924">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="source" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/uhdrload.c"
               line="915">source to load from</doc>
          <type name="Source" c:type="VipsSource*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/uhdrload.c"
               line="916">decompressed image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/uhdrload.c"
               line="917">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_area" c:identifier="vips_value_get_area">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/type.c"
           line="1561">Get the pointer from an area. Don't touch count (area is static).</doc>
      <source-position filename="libvips/include/vips/type.h" line="260"/>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/type.c"
             line="1568">The pointer held by @value.</doc>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1563">get from this value</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="length"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1564">optionally return length here</doc>
          <type name="gsize" c:type="size_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_array" c:identifier="vips_value_get_array">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/type.c"
           line="1782">Return the pointer to the array held by @value.
Optionally return the other properties of the array in @n, @type,
@sizeof_type.

::: seealso
    [func@value_set_array].</doc>
      <source-position filename="libvips/include/vips/type.h" line="287"/>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/type.c"
             line="1796">The array address.</doc>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1784">[struct@GObject.Value] to get from</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="n"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1785">return the number of elements here, optionally</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="type"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1786">return the type of each element here, optionally</doc>
          <type name="GType" c:type="GType*"/>
        </parameter>
        <parameter name="sizeof_type"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1787">return the sizeof each element here, optionally</doc>
          <type name="gsize" c:type="size_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_array_double"
              c:identifier="vips_value_get_array_double">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/type.c"
           line="1863">Return the start of the array of doubles held by @value.
optionally return the number of elements in @n.

::: seealso
    [ctor@ArrayDouble.new].</doc>
      <source-position filename="libvips/include/vips/type.h" line="291"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/type.c"
             line="1874">The array address.</doc>
        <array length="1" zero-terminated="0" c:type="double*">
          <type name="gdouble" c:type="double"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1865">[struct@GObject.Value] to get from</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="n"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1866">return the number of elements here, optionally</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_array_image"
              c:identifier="vips_value_get_array_image">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/type.c"
           line="1906">Return the start of the array of images held by @value.
optionally return the number of elements in @n.

::: seealso
    [func@value_set_array_image].</doc>
      <source-position filename="libvips/include/vips/image.h" line="599"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/type.c"
             line="1917">The array address.</doc>
        <array length="1" zero-terminated="0" c:type="VipsImage**">
          <type name="Image" c:type="VipsImage*"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1908">[struct@GObject.Value] to get from</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="n"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1909">return the number of elements here, optionally</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_array_int"
              c:identifier="vips_value_get_array_int">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/type.c"
           line="1820">Return the start of the array of ints held by @value.
optionally return the number of elements in @n.

::: seealso
    [ctor@ArrayInt.new].</doc>
      <source-position filename="libvips/include/vips/type.h" line="296"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/type.c"
             line="1831">The array address.</doc>
        <array length="1" zero-terminated="0" c:type="int*">
          <type name="gint" c:type="int"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1822">[struct@GObject.Value] to get from</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="n"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1823">return the number of elements here, optionally</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_array_object"
              c:identifier="vips_value_get_array_object"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/type.c"
           line="1946">Return the start of the array of [class@GObject.Object] held by @value.
Optionally return the number of elements in @n.

::: seealso
    [ctor@Area.new_array_object].</doc>
      <source-position filename="libvips/include/vips/type.h" line="301"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/type.c"
             line="1957">The array address.</doc>
        <array length="1" zero-terminated="0" c:type="GObject**">
          <type name="GObject.Object" c:type="GObject*"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1948">[struct@GObject.Value] to get from</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="n"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1949">return the number of elements here, optionally</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_blob" c:identifier="vips_value_get_blob">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/type.c"
           line="1737">Returns the data pointer from a blob. Optionally returns the length too.

blobs are things like ICC profiles or EXIF data. They are relocatable, and
are saved to VIPS files for you coded as base64 inside the XML. They are
copied by copying reference-counted pointers.

::: seealso
    [func@value_set_blob]</doc>
      <source-position filename="libvips/include/vips/type.h" line="276"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/type.c"
             line="1751">The pointer held
by @value.</doc>
        <array length="1" zero-terminated="0" c:type="void*">
          <type name="guint8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1739">GValue to set</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="length"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1740">optionally return length of memory area</doc>
          <type name="gsize" c:type="size_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_ref_string"
              c:identifier="vips_value_get_ref_string">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/type.c"
           line="1637">Get the C string held internally by the [struct@GObject.Value].</doc>
      <source-position filename="libvips/include/vips/type.h" line="271"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/type.c"
             line="1644">The C string held by @value.</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1639">[struct@GObject.Value] to get from</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="length"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1640">return length here, optionally</doc>
          <type name="gsize" c:type="size_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_save_string"
              c:identifier="vips_value_get_save_string">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/type.c"
           line="1580">Get the C string held internally by the GValue.</doc>
      <source-position filename="libvips/include/vips/type.h" line="263"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/type.c"
             line="1586">The C string held by @value.</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1582">GValue to get from</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_is_null" c:identifier="vips_value_is_null">
      <source-position filename="libvips/include/vips/object.h" line="595"/>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="psoec" transfer-ownership="none">
          <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_area" c:identifier="vips_value_set_area">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/type.c"
           line="1542">Set value to be a ref-counted area of memory with a free function.</doc>
      <source-position filename="libvips/include/vips/type.h" line="258"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1544">set this value</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="free_fn"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   scope="async"
                   closure="2">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1545">data will be freed with this function</doc>
          <type name="CallbackFn" c:type="VipsCallbackFn"/>
        </parameter>
        <parameter name="data"
                   transfer-ownership="full"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1546">set @value to track this pointer</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_array" c:identifier="vips_value_set_array">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/type.c"
           line="1760">Set @value to be an array of things.

This allocates memory but does not
initialise the contents: get the pointer and write instead.</doc>
      <source-position filename="libvips/include/vips/type.h" line="284"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1762">[struct@GObject.Value] to set</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1763">number of elements</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1764">the type of each element</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="sizeof_type" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1765">the sizeof each element</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_array_double"
              c:identifier="vips_value_set_array_double">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/type.c"
           line="1882">Set @value to hold a copy of @array. Pass in the array length in @n.

::: seealso
    [method@ArrayDouble.get].</doc>
      <source-position filename="libvips/include/vips/type.h" line="293"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1884">[struct@GObject.Value] to get from</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="array"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1885">array of doubles</doc>
          <array length="2" zero-terminated="0" c:type="const double*">
            <type name="gdouble" c:type="double"/>
          </array>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1886">the number of elements</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_array_image"
              c:identifier="vips_value_set_array_image">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/type.c"
           line="1925">Set @value to hold an array of images. Pass in the array length in @n.

::: seealso
    [method@ArrayImage.get].</doc>
      <source-position filename="libvips/include/vips/image.h" line="601"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1927">[struct@GObject.Value] to get from</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1928">the number of elements</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_array_int"
              c:identifier="vips_value_set_array_int">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/type.c"
           line="1839">Set @value to hold a copy of @array. Pass in the array length in @n.

::: seealso
    [method@ArrayInt.get].</doc>
      <source-position filename="libvips/include/vips/type.h" line="298"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1841">[struct@GObject.Value] to get from</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="array"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1842">array of ints</doc>
          <array length="2" zero-terminated="0" c:type="const int*">
            <type name="gint" c:type="int"/>
          </array>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1843">the number of elements</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_array_object"
              c:identifier="vips_value_set_array_object">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/type.c"
           line="1965">Set @value to hold an array of [class@GObject.Object]. Pass in the array
length in @n.

::: seealso
    [func@value_get_array_object].</doc>
      <source-position filename="libvips/include/vips/type.h" line="303"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1967">[struct@GObject.Value] to set</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1968">the number of elements</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_blob" c:identifier="vips_value_set_blob">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/type.c"
           line="1677">Sets @value to hold a @data. When @value is freed, @data will be
freed with @free_fn. @value also holds a note of the size of the memory
area.

blobs are things like ICC profiles or EXIF data. They are relocatable, and
are saved to VIPS files for you coded as base64 inside the XML. They are
copied by copying reference-counted pointers.

::: seealso
    [func@value_get_blob]</doc>
      <source-position filename="libvips/include/vips/type.h" line="278"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1679">GValue to set</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="free_fn"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   scope="async">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1680">free function for @data</doc>
          <type name="CallbackFn" c:type="VipsCallbackFn"/>
        </parameter>
        <parameter name="data" transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1681">pointer to area of
memory</doc>
          <array length="3" zero-terminated="0" c:type="void*">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1683">length of memory area</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_blob_free"
              c:identifier="vips_value_set_blob_free">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/type.c"
           line="1709">Just like [func@value_set_blob], but when
@value is freed, @data will be
freed with [func@GLib.free].

This can be easier to call for language bindings.

::: seealso
    [func@value_set_blob]</doc>
      <source-position filename="libvips/include/vips/type.h" line="281"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1711">GValue to set</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="data" transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1712">pointer to area of
memory</doc>
          <array length="2" zero-terminated="0" c:type="void*">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1714">length of memory area</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_ref_string"
              c:identifier="vips_value_set_ref_string">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/type.c"
           line="1652">Copies the C string @str into @value.

vips_ref_string are immutable C strings that are copied between images by
copying reference-counted pointers, making them much more efficient than
regular [struct@GObject.Value] strings.

@str should be a valid utf-8 string.</doc>
      <source-position filename="libvips/include/vips/type.h" line="273"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1654">[struct@GObject.Value] to set</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1655">C string to copy into the GValue</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_save_string"
              c:identifier="vips_value_set_save_string">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/type.c"
           line="1594">Copies the C string into @value.

@str should be a valid utf-8 string.</doc>
      <source-position filename="libvips/include/vips/type.h" line="265"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1596">GValue to set</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1597">C string to copy into the GValue</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_save_stringf"
              c:identifier="vips_value_set_save_stringf"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/type.c"
           line="1614">Generates a string and copies it into @value.</doc>
      <source-position filename="libvips/include/vips/type.h" line="267"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1616">GValue to set</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="fmt" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1617">`printf()`-style format string</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/type.c"
               line="1618">arguments to `printf()`-formatted @fmt</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="vector_disable_targets"
              c:identifier="vips_vector_disable_targets">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/vector.cpp"
           line="173">Takes a bitfield of targets to disable on the runtime platform.
Handy for testing and benchmarking purposes.

This can also be set using the `VIPS_VECTOR` environment variable.</doc>
      <source-position filename="libvips/include/vips/vector.h" line="53"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="disabled_targets" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/vector.cpp"
               line="175">A bitfield of targets to disable at runtime.</doc>
          <type name="gint64" c:type="gint64"/>
        </parameter>
      </parameters>
    </function>
    <function name="vector_get_builtin_targets"
              c:identifier="vips_vector_get_builtin_targets">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/vector.cpp"
           line="115">Gets a bitfield of builtin targets that libvips was built with.</doc>
      <source-position filename="libvips/include/vips/vector.h" line="47"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/vector.cpp"
             line="120">a bitfield of builtin targets.</doc>
        <type name="gint64" c:type="gint64"/>
      </return-value>
    </function>
    <function name="vector_get_supported_targets"
              c:identifier="vips_vector_get_supported_targets">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/vector.cpp"
           line="132">Gets a bitfield of enabled targets that are supported on this CPU. The
targets returned may change after calling [func@vector_disable_targets].</doc>
      <source-position filename="libvips/include/vips/vector.h" line="49"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/vector.cpp"
             line="138">a bitfield of supported CPU targets.</doc>
        <type name="gint64" c:type="gint64"/>
      </return-value>
    </function>
    <function name="vector_isenabled" c:identifier="vips_vector_isenabled">
      <source-position filename="libvips/include/vips/vector.h" line="42"/>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
    </function>
    <function name="vector_set_enabled" c:identifier="vips_vector_set_enabled">
      <source-position filename="libvips/include/vips/vector.h" line="44"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="enabled" transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="vector_target_name" c:identifier="vips_vector_target_name">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/vector.cpp"
           line="152">Generates a human-readable ASCII string descriptor for a specific target.</doc>
      <source-position filename="libvips/include/vips/vector.h" line="51"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/vector.cpp"
             line="158">a string describing the target.</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="target" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/vector.cpp"
               line="154">A specific target to describe.</doc>
          <type name="gint64" c:type="gint64"/>
        </parameter>
      </parameters>
    </function>
    <function name="verror" c:identifier="vips_verror" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="160">Append a message to the error buffer.

::: seealso
    [func@error].</doc>
      <source-position filename="libvips/include/vips/error.h" line="54"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="162">the source of the error</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="fmt" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="163">`printf()`-style format string for the error</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="ap" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="164">arguments to the format string</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function name="verror_system"
              c:identifier="vips_verror_system"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/error.c"
           line="223">Format the string in the style of [`printf()`](man:printf(3)) and append to the error buffer.
Then create and append a localised message based on the system error code,
usually the value of errno.

::: seealso
    [func@error_system].</doc>
      <source-position filename="libvips/include/vips/error.h" line="59"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="err" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="225">the system error code</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="226">the source of the error</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="fmt" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="227">`printf()`-style format string for the error</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="ap" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/error.c"
               line="228">arguments to the format string</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function name="version" c:identifier="vips_version">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/init.c"
           line="1250">Get the major, minor or micro library version, with @flag values 0, 1 and
2.

Get the ABI current, revision and age (as used by Meson) with @flag
values 3, 4, 5.</doc>
      <source-position filename="libvips/include/vips/vips.h" line="191"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/init.c"
             line="1260">library version number</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="flag" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/iofuncs/init.c"
               line="1252">which field of the version to get</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="version_string" c:identifier="vips_version_string">
      <doc xml:space="preserve"
           filename="libvips/iofuncs/init.c"
           line="1236">Get the VIPS version as a static string, including a build date and time.
Do not free.</doc>
      <source-position filename="libvips/include/vips/vips.h" line="189"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/iofuncs/init.c"
             line="1242">a static version string</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
    </function>
    <function name="vipsload" c:identifier="vips_vipsload" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/vipsload.c"
           line="318">Read in a vips image.

::: seealso
    [method@Image.vipssave].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="470"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/vipsload.c"
             line="329">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/vipsload.c"
               line="320">file to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/vipsload.c"
               line="321">decompressed image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/vipsload.c"
               line="322">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="vipsload_source"
              c:identifier="vips_vipsload_source"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/vipsload.c"
           line="344">Exactly as [ctor@Image.vipsload], but read from a source.</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="473"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/vipsload.c"
             line="352">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="source" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/vipsload.c"
               line="346">source to load from</doc>
          <type name="Source" c:type="VipsSource*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/vipsload.c"
               line="347">decompressed image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/vipsload.c"
               line="348">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="webpload" c:identifier="vips_webpload" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/webpload.c"
           line="427">Read a WebP file into a VIPS image.

Use @page to select a page to render, numbering from zero.

Use @n to select the number of pages to render. The default is 1. Pages are
rendered in a vertical column, with each individual page aligned to the
left. Set to -1 to mean "until the end of the document". Use [method@Image.grid]
to change page layout.

Use @scale to specify a scale-on-load factor. For example, 2.0 to double
the size on load. Animated webp images don't support shrink-on-load, so a
further resize may be necessary.

The loader supports ICC, EXIF and XMP metadata.

::: tip "Optional arguments"
    * @page: `gint`, page (frame) to read
    * @n: `gint`, load this many pages
    * @scale: `gdouble`, scale by this much on load

::: seealso
    [ctor@Image.new_from_file].</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="552"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/webpload.c"
             line="456">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/webpload.c"
               line="429">file to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/webpload.c"
               line="430">decompressed image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/webpload.c"
               line="431">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="webpload_buffer"
              c:identifier="vips_webpload_buffer"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/webpload.c"
           line="471">Read a WebP-formatted memory block into a VIPS image. Exactly as
[ctor@Image.webpload], but read from a memory buffer.

You must not free the buffer while @out is active. The
[signal@Object::postclose] signal on @out is a good place to free.

::: tip "Optional arguments"
    * @page: `gint`, page (frame) to read
    * @n: `gint`, load this many pages
    * @scale: `gdouble`, scale by this much on load

::: seealso
    [ctor@Image.webpload]</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="555"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/webpload.c"
             line="492">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="buf" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/webpload.c"
               line="473">memory area to load</doc>
          <array length="1" zero-terminated="0" c:type="void*">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/webpload.c"
               line="474">size of memory area</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/webpload.c"
               line="475">image to write</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/webpload.c"
               line="476">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="webpload_source"
              c:identifier="vips_webpload_source"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/foreign/webpload.c"
           line="514">Exactly as [ctor@Image.webpload], but read from a source.

::: tip "Optional arguments"
    * @page: `gint`, page (frame) to read
    * @n: `gint`, load this many pages
    * @scale: `gdouble`, scale by this much on load

::: seealso
    [ctor@Image.webpload]</doc>
      <source-position filename="libvips/include/vips/foreign.h" line="549"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/foreign/webpload.c"
             line="530">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="source" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/webpload.c"
               line="516">source to load from</doc>
          <type name="Source" c:type="VipsSource*"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/foreign/webpload.c"
               line="517">image to write</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/foreign/webpload.c"
               line="518">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="worley" c:identifier="vips_worley" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/create/worley.c"
           line="343">Create a one-band float image of [Worley
noise](https://en.wikipedia.org/wiki/Worley_noise).

Use @cell_size to set the size of the cells from which the image is
constructed. The default is 256 x 256.

If @width and @height are multiples of @cell_size, the image will tessellate.

::: tip "Optional arguments"
    * @cell_size: `gint`, size of Worley cells

::: seealso
    [ctor@Image.perlin], [ctor@Image.fractsurf], [ctor@Image.gaussnoise].</doc>
      <source-position filename="libvips/include/vips/create.h" line="162"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/create/worley.c"
             line="364">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/create/worley.c"
               line="345">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/worley.c"
               line="346">horizontal size</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/worley.c"
               line="347">vertical size</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/worley.c"
               line="348">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="xyz" c:identifier="vips_xyz" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/create/xyz.c"
           line="237">Create a two-band uint32 image where the elements in the first band have the
value of their x coordinate and elements in the second band have their y
coordinate.

You can make any image where the value of a pixel is a function of its (x,
y) coordinate by combining this operator with the arithmetic operators.

Set @csize, @dsize, @esize to generate higher dimensions and add more
bands. The extra dimensions are placed down the vertical axis. Use
[method@Image.grid] to change the layout.

::: tip "Optional arguments"
    * @csize: `gint`, size for third dimension
    * @dsize: `gint`, size for fourth dimension
    * @esize: `gint`, size for fifth dimension

::: seealso
    [ctor@Image.grey], [method@Image.grid], [ctor@Image.identity].</doc>
      <source-position filename="libvips/include/vips/create.h" line="62"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/create/xyz.c"
             line="263">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/create/xyz.c"
               line="239">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/xyz.c"
               line="240">horizontal size</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/xyz.c"
               line="241">vertical size</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/xyz.c"
               line="242">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="zone" c:identifier="vips_zone" introspectable="0">
      <doc xml:space="preserve"
           filename="libvips/create/zone.c"
           line="100">Create a one-band image of a zone plate.

Pixels are normally in [-1, +1], set @uchar to output [0, 255].

::: tip "Optional arguments"
    * @uchar: `gboolean`, output a uchar image

::: seealso
    [ctor@Image.eye], [ctor@Image.xyz].</doc>
      <source-position filename="libvips/include/vips/create.h" line="88"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libvips/create/zone.c"
             line="117">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libvips/create/zone.c"
               line="102">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/zone.c"
               line="103">image size</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/zone.c"
               line="104">image size</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libvips/create/zone.c"
               line="105">`NULL`-terminated list of optional named arguments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
